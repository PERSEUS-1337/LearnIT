{
    "title": "BkgyvHSWFV",
    "content": "In this paper, the focus is on AI systems tackling construction challenges in Minecraft, specifically building complex structures using hierarchical task networks. The advantages and disadvantages of classical and HTN planning models for house construction scenarios are compared. Minecraft presents unique challenges for AI, such as evaluating reinforcement learning techniques. Previous research has explored planning models for controlling agents in the game world, including learning from textual descriptions of actions and observing players' actions. In contrast to previous research focusing on online goal-reasoning and planning models for controlling agents in Minecraft, this paper aims to develop a natural-language system for giving construction instructions to human users. The goal is to generate a construction plan for building structures in Minecraft, without considering the natural-language and dialogue aspects of the problem. The Minecraft world is viewed as a Blocksworld domain for construction planning purposes. The Minecraft world is seen as a Blocksworld domain for construction planning. Blocks can be placed in a 3D environment, with a hierarchy of objects like rows, walls, and houses. Hierarchical planning is used to construct high-level objects efficiently. Various models are devised for constructing a house, including classical PDDL planning and hierarchical planning approaches. The baseline classical planning model outputs a sequence of actions without considering high-level objects, making it difficult to describe in natural language. A second classical planning model encodes the construction of high-level objects through auxiliary actions. HTN planning allows for straightforward modeling of object hierarchy, with tasks for building each type of high-level object. Unlike classical planning, HTN planners have their own input language, with specific models for individual HTN planners like PANDA planning system BID3 BID2 and SHOP2 BID14. In a simple scenario, two HTN planners, PANDA planning system BID3 BID2 and SHOP2 BID14, are used to construct a house in Minecraft. The house consists of stone walls, a stone roof, and a door, with each element further decomposed into individual blocks. Low-level details are abstracted away, focusing on construction elements. The Minecraft environment is modeled as a 3D grid with various block types available in creative mode. The Minecraft environment is modeled as a 3D grid with various block types available in creative mode. Planning focuses on construction actions like placing or removing blocks in high-level structures. A classical planning model in PDDL language includes actions for putting and removing blocks at different locations. The goal specifies the block type for each location, with preconditions for adjacent non-empty locations. The goal is to have a set of block at facts. The Minecraft environment is represented as a 3D grid with different block types. Planning involves construction actions like placing or removing blocks in high-level structures. A classical planning model in PDDL language includes actions for putting and removing blocks at different locations. The goal is to have a set of block at facts. To address the limitation of ignoring the high-level structure of objects, auxiliary actions are introduced to represent the construction of high-level objects, such as building a wall with specified attributes. The Minecraft environment is represented as a 3D grid with different block types. Planning involves construction actions like placing or removing blocks in high-level structures. To address the limitation of ignoring the high-level structure of objects, auxiliary actions are introduced to represent the construction of high-level objects, such as building a wall with specified attributes. These actions decompose the construction of a wall into several rows, ensuring that no other high-level object is being constructed at the moment. The actions build rows of a given length on the corresponding location and direction, updating the location for the rest of the wall to be built and decreasing its height by one. The action end wall finishes the construction of the wall when the height is zero. The HTN models encode high-level object construction by defining tasks like build house, build wall, and build row, which are decomposed into primitive tasks like place-block and remove-block. Two HTN planners, PANDA and SHOP2, are considered. PANDA uses an HTN formalism that combines classical and HTN planning, describing high-level objects as tasks without special predicates. The HTN model defines tasks for building a house, wall, roof, row of blocks, and door. Methods decompose tasks recursively, building from bottom to top. Buildhouse decomposes into four walls, roof, and door. Builddoor specifies blocks to remove for the door. The SHOP2 model follows a hierarchical task structure similar to the PANDA model, with methods for decomposing the house into walls and rows of blocks. It can call arbitrary LISP functions and represent locations using integers as coordinates. This allows for the computation of row endpoints and the construction of walls by alternating row directions. The model defines a method for removing two blocks to form a door, which may be more intuitive for communication with a human user. The construction of walls involves alternating row directions. Two recursive decompositions are defined for building walls. Different methods are used for changing row directions. Performance evaluation is done on models scaled with respect to construction size and 3D world size. Different planners are used for classical planning models. The PANDA planning system implements various algorithms for classical planning models, including heuristic search with the FF heuristic for LAMA planner and depth-first search for SHOP2. Experiments were conducted on an Intel i5 4200U processor with time and memory limits. The first experiment involved scaling the size of a house in a 3D world incrementally. The planners show good scalability in search time for solving problems up to 9\u02c69\u02c69 in just a few seconds. The non-hierarchical PDDL planning model has the worst search performance and longer plans. There is a significant gap between search and total time for PANDA and PDDL models due to the grounding phase overhead. SHOP2 is not impacted by this as it does not do any preprocessing or grounding. The size of the world environment has a greater impact on the performance of PANDA and PDDL models than the size of the construction. The number of operators and facts in the preprocessing directly influences the planner's performance. Increasing the world size does not affect the performance of SHOP2. In the Minecraft game, the size of the world significantly affects the performance of planners like PANDA and PDDL models. While SHOP2 is not impacted by world size, the preprocessing phase overhead dominates total time for PANDA. Search time increases linearly with world size due to heuristic evaluation overhead. Experiments show that planners struggle as world size increases, even in simple construction scenarios. Planners like SHOP2 perform well in Minecraft worlds with millions of blocks, but may struggle with additional constraints or quality optimization. Adjusting the model to build auxiliary structures when necessary could alleviate this issue, but would require more complex task decompositions. The SHOP2 model struggles with unexpected situations due to the need for task decompositions, while PANDA allows for insertion of primitive actions to increase planner robustness. However, the task insertion process slows down the search and may require more efficient methods. Our models are still a simple prototype and do not capture the full complexity of the domain. We plan to extend them in different directions to better describe actions and method decompositions in natural language. Consideration of the user's visibility may be important for easier description of objects in their field of view. The challenge of effectively modeling the field of vision in natural language may involve using external solvers. An interesting extension is to consider how easy it is to express actions in natural language, such as reducing action cost for placing blocks near easily referred to objects like landmarks."
}