{
    "title": "SygQlT4FwS",
    "content": "The paper introduces a new approach to source code obfuscation using text-based recurrent neural network (RNN) encoder-decoder models for generating ciphertext and keys. The proposed solution utilizes RNN models to obfuscate code, generate deobfuscation keys, and improve stealth and execution cost compared to existing methods. Experiments show positive results in character variation, dissimilarity to original code, and consistent obfuscated code length. Traditional obfuscation tactics aim to protect software by making logic less recognizable, but can still be reverse-engineered. DeepObfusCode is a proposed methodology using neural networks to convert plaintext source code into ciphertext, allowing users to self-execute programs without revealing the code's inner workings. This approach aims for complete obfuscation rather than incremental obfuscation, suggesting the use of asymmetric key infrastructure. The methodology of code obfuscation using neural networks aims for complete obfuscation with asymmetric key infrastructure. It can be adopted for efficient protection of proprietary code or cloud computing services. The algorithmic architecture ensures anonymity of the codebase during execution. The objective is to mask computational processes and logic to protect trade secrets and confidential data. Code obfuscation involves hiding the meaning behind source code to protect secrets, intellectual property, or confidential data. There are eight generalized methods, including name obfuscation, data obfuscation, and code flow obfuscation. Source code obfuscation focuses on rendering code un-understandable to third parties. Sub-techniques like control ordering and data aggregation are used to reduce code understandability. The proposed method of code obfuscation involves complete obfuscation using randomly generated characters to prevent reverse-engineering. Existing evaluation methods focus on qualitative surveys of difficulty, but a quantitative comparison is needed. The proposed source code obfuscation method will be quantitatively compared against existing methods using a modified framework. The comparison metrics include code potency, resilience, and stealth to evaluate the degree of obfuscation, ability to withstand attacks, and difficulty in manual de-obfuscation. The proposed obfuscation method, DeepObfusCode, focuses on detecting misdirecting statements and interpreting confusing identifiers. It measures execution cost by comparing the time required for obfuscation and execution of obfuscated code to the original code. The method generates a ciphertext that cannot be reverse-engineered manually, making code potency and resilience irrelevant metrics. Evaluation focuses on stealth and execution time, utilizing neural networks in cryptography and steganography. Recent implementations in cryptography and steganography include using style transfer to encrypt secret images within a cover image, n-dimensional convolutional neural networks for data encryption, and multilayer perception models for encrypting and decrypting satellite images. There is also a focus on neural networks that can operate on encrypted data. This growing interest in encrypting data using neural networks extends to encrypting source code itself, with the potential to decrypt and execute using generated model files. The proposed obfuscation method utilizes text-based encoder-decoders in character generation to convert one string into another. It involves a primary RNN encoder-decoder model with randomly-set weights to generate obfuscated text from original code, followed by a secondary RNN encoder-decoder model. The obfuscation method uses text-based encoder-decoders to generate obfuscated text from original code. A secondary RNN encoder-decoder model is trained to calculate weights for generating the original text, with the weights serving as the key. The process involves initializing character sets, assigning weights, and processing text strings for the encoder and decoder models. The obfuscation method involves processing text strings to prepare inputs for encoder and decoder models. Unique character sets and dictionaries are created for indexing characters. Model weights are randomly generated to determine the degree of randomness in the ciphertext generation. The obfuscation method involves processing text strings for encoder and decoder models. Ciphertext Generation function C(p) uses plaintext (p) and weights (w rand) to generate ciphertext (c). The output is decoded using an index-to-character dictionary to create the final ciphertext. This ciphertext is used with the plaintext to generate a key through training the model for a set number of iterations. Early Stopping mechanisms can be applied after around 2000 iterations. After processing text strings for encoder and decoder models, the ciphertext is generated using the Ciphertext Generation function C(p) with plaintext (p) and weights (w rand). The key is generated through training the model for a specific number of iterations, typically around 2000. Export the encoder and decoder model files in HDF5 format and the metadata in pickle format. The Key Generation function K(p, c) sets weights while minimizing the loss function. Testing for executable code is done after decoding the ciphertext, and if it fails, the model is retrained. During live execution, the obfuscated code (ciphertext) and key pair are retained. The function K(c, k) is modified to accept ciphertext and model files. The obfuscated code is run on a server by passing it to an execution engine along with the model files. The output value is executed immediately upon return. The obfuscation method is evaluated based on stealth and execution cost. Parameters like code potency or resilience are not applicable as the method completely regenerates the code. Testing for stealthiness involves measuring the complexity and randomness compared to the original code. The comparison involves obfuscating recognized well-obfuscated code and comparing the distance from the original code. The obfuscation method is evaluated based on stealth and execution cost by comparing the distance in similarity between the original code and obfuscated code samples obtained from the IOCCC contest. Five obfuscated-deobfuscated paired samples were used for the experiment, available at https://github.com/dattasiddhartha-1/dsource. The obfuscation method was extensively tested by performing obfuscation for 100 iterations on each de-obfuscated sample to obtain 500 obfuscated code samples in total. Levenshtein Distance was used to measure the distance between the original de-obfuscated code and the IOCCC obfuscated code, as well as between the original de-obfuscated code and each sample's DeepObfusCode obfuscated code. The results showed that DeepObfusCode obfuscation had a greater degree of randomness compared to the original source text. The experiment compared the proposed obfuscation method to the benchmark IOCCC obfuscated text, showing an average improvement in dissimilarity. Set 2 of the experiment, however, indicated that the benchmark outperformed the proposed method due to the presence of repetitive characters as junk code insertions. Removing set 2 resulted in a higher average improvement, supporting the effectiveness of the proposed obfuscation method in stealth. The experimental design focused on measuring how ciphertext generation time and key generation time varied with plaintext length. Strings of varying lengths were randomly generated, and six main variables were recorded for testing. The simulation was run on a Python Jupyter notebook on Windows 10 with a Nvidia Geforce 1070 GTX graphics card. The experiment focused on measuring ciphertext and key generation time based on plaintext length. Ciphertext generation showed no clear pattern, while key generation displayed a linear pattern. Longer source code increased key generation time, indicating suitability for smaller code bases or systems with ample computing resources. Key generation time complexity is O(n). The experiment also provided insights into the obfuscation model's properties. The experiment provided insights into the properties of the obfuscation model, showing that the ciphertext character variation is widely distributed regardless of plaintext length, and the ciphertext length remains low (average 72 characters) regardless of plaintext length. This reduces storage requirements for obfuscated code. The cipher generation algorithm produces short random ciphertexts, making it difficult for malicious actors to reverse-engineer the ciphertext. The model file consists of 3 layers of arrays, with the main layer containing 8 arrays. The main layer contains 8 arrays with varying array lengths. Generating random floats for a large number of values is necessary to de-obfuscate the code. A correlation matrix in Figure 7 summarizes the relationships between properties tested in the experiment. The obfuscation methodology uses RNN encoder-decoder models to generate ciphertext from source code. The obfuscation methodology utilizes RNN encoder-decoder models to generate ciphertext from source code, providing stealth and readability advantages for larger code bases. Key generation may require more time and computational resources but is less intensive than manual obfuscation, making it suitable for services with confidential plaintext source code that need to execute securely."
}