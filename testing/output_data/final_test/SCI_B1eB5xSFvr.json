{
    "title": "B1eB5xSFvr",
    "content": "DiffSim is a new differentiable programming language designed for high-performance physical simulations. It outperforms hand-engineered CUDA versions and TensorFlow, making neural network optimization faster and more efficient. However, differentiating physical simulators doesn't always provide useful gradients, and the study proposes solutions to improve this issue. DiffSim is a differentiable programming language for physical simulations, aiming to improve gradient quality. It integrates a neural network controller with a simulation module, with simulations having up to 2048 time steps and 1000 parallel operations per step. Differentiable simulators are crucial in machine learning systems, as they optimize controllers faster than reinforcement learning algorithms. DiffSim is a new differentiable programming language designed for high-performance physical simulations on CPU and GPU. It utilizes a \"megakernel\" approach to fuse multiple computation stages into a single kernel for better arithmetic intensity compared to TensorFlow and PyTorch. DiffSim is an imperative programming language for physical simulations, offering parallel loops and control flows for tasks like handling collisions and building solvers. It simplifies porting existing simulation code and provides flexible indexing for element-wise operations on arrays. DiffSim allows direct manipulation of array elements via arbitrary indexing, enabling partial updates of global arrays and simplifying common simulation patterns. The explicit indexing syntax also aids in compiler access optimizations. A tailored two-scale automatic differentiation system in DiffSim is ideal for developing complex and high-performance differentiable physical simulators, potentially with neural network controllers. DiffSim enables quick implementation and differentiation of 10 physical simulators, including rigid bodies, deformable objects, and fluids. It is based on the Taichi programming language, known for its high performance and productivity on modern hardware. Taichi's design allows for easy switching between different data layouts and access to data structures with indices. The compiler optimizes performance based on both data structure and algorithm information. Taichi, a high-performance programming language, is used for writing physical simulators efficiently. DiffSim, embedded in Python, compiles code to Taichi IR, which is compiled, statically-typed, parallel, and differentiable. The Taichi compiler extends to automatically differentiate generated IR. A mass-spring simulator is demonstrated using DiffSim frontend. Global variables are allocated for the simulator. The Taichi C++14 frontend allocates global variables for a mass-spring system simulation, including tensors for state variables and arrays for spring properties. Kernels are defined to model Hooke's law and perform time integration with damping. DiffSim's automatic differentiation system aims to generate gradient simulators automatically. DiffSim's automatic differentiation system aims to generate gradient simulators automatically with minimal code changes. By using a two-scale approach, they combine Source Code Transformation (SCT) for differentiating within kernels and a lightweight tape for end-to-end simulation differentiation, achieving both performance and flexibility. DiffSim's automatic differentiation system utilizes global tensors as checkpoints for gradient evaluation in imperative programming. To ensure well-defined differentiation, they impose rules on global data access, such as atomic accumulation for multiple writes and no read accesses until accumulation is complete. The system includes a tape for recording kernel launches and replaying gradient kernels during backpropagation. In forward simulators, programmers may make subtle changes to satisfy rules, like recording the history of variables instead of just the latest values. Memory consumption issues can be alleviated through checkpointing. Users can specify storage of adjoint tensors using Taichi data structure description language. Taichi kernels consist of multiple levels of for loops and a body block for easier automatic differentiation. To simplify automatic differentiation in Taichi kernels, two basic code transforms are introduced: flattening branching by replacing \"if\" statements with the ternary operator and eliminating mutable local variables to achieve single-assignment IR. These transformations help streamline the loop bodies for easier reverse-mode AD. DiffSim simplifies automatic differentiation by eliminating mutable local variables and transforming code to achieve single-assignment IR. It preserves parallel loop structures and handles loops without mutable variables. Global variables are recommended for data access rules. Forward simulation uses the \"parallel-for\" construct from Taichi for parallelism. DiffSim simplifies automatic differentiation by transforming code to achieve single-assignment IR. It uses the \"parallel-for\" construct from Taichi for forward simulation, ensuring thread safety with atomic operations. A lightweight tape records kernel execution for gradient kernel replay in reverse order. Global tensors store intermediate results, reducing tape overhead compared to other systems. DiffSim AD evaluates gradients with respect to input global tensors, not input parameters. It allows for optimization by defining loss functions and using custom complex kernels for better stability. The user can override gradients with ti.complex_kernel and ti.complex_kernel_grad decorators. DiffSim allows for custom gradients and complex kernels to implement checkpointing. It is evaluated on various physical simulators, with results reproducible using provided scripts. The focus is on building a differentiable continuum simulation for soft robotics applications, following ChainQueen's implementation and using the moving least squares material point method. The simulator can easily translate the original CUDA simulator into DiffSim syntax. Using DiffSim, a soft robot can be trained to move forward with an open-loop controller. The implementation in DiffSim is more efficient than manual gradient implementations and TensorFlow, with shorter code and faster performance. A smoke simulator with semi-Lagrangian advection and implicit pressure projection was also implemented, allowing for optimization of the velocity field to change fluid patterns. DiffSim enables the creation of a velocity field to transform fluid patterns. Performance comparison with PyTorch, Autograd, and JAX shows Taichi outperforms array-based systems. A rigid body simulator supporting collision, friction, and actuation is built for optimizing robot controllers. The simulation is differentiable except for discontinuities, leading to misleading gradients due to rigid body collisions. Improving collision gradients involves adjusting parameters like initial ball height to achieve desired outcomes. The text discusses the issue of misleading gradients in simulations due to rigid body collisions. A solution is proposed involving continuous collision resolution to improve gradient quality in controller optimization tasks. The technique of precise time of impact (TOI) is found to significantly enhance gradient quality without affecting forward simulation. In a study on robot controller optimization, it was found that differentiating physical simulators may not always provide useful gradients, even if the simulator performs forward simulation well. The complexity of physical simulation requires composing basic operations into complex ones, leading to unsatisfactory performance. Previous work focused on transforming scalar code for derivatives, such as in learning from 3D scenes. DiffSim is a new differentiable programming language tailored for building high-performance physical simulators. It supports megakernels, imperative programming, and flexible indexing. DiffSim has been used to create 10 simulators integrated into deep neural networks, showing improved performance and productivity compared to existing systems. This programming language aims to facilitate research in differentiable physical simulation within the machine learning and robotics communities. DiffSim is a differentiable programming language focused on high-performance physical simulators, supporting megakernels and imperative programming. It offers both low-level and high-level operations, with a focus on convolutions for computer vision tasks. However, users may need to combine low-level operations to achieve desired high-level operations, leading to temporary buffers and excessive GPU kernel launches. This can result in significant slowdown compared to optimized CUDA implementations. DiffSim is a differentiable programming language designed for high-performance physical simulators, offering both low-level and high-level operations. It addresses issues such as excessive GPU kernel launches and lack of producer-consumer locality. The system transforms primal kernels into adjoint form for automatic differentiation, with a focus on checkpointing via complex kernels. Checkpointing via complex kernels is demonstrated in the diffmpm example, showing how recomputation can save memory space during simulation cycles. By redoing certain steps during the backward simulation time step, memory consumption can be reduced significantly. This optimization allows for reusing grid states and allocating only one copy, instead of multiple copies, resulting in more efficient memory usage. The text discusses reducing space consumption in high-resolution simulations by using segment-wise checkpointing. By splitting the simulation into segments and storing only the first state in each segment during forward simulation, memory usage can be optimized. This approach allows for efficient backpropagation within segments, resulting in a total space consumption of O(S + n/S). Additionally, a 3D differentiable liquid simulator is implemented, which can be coupled with elastic object simulation. In Autograd, 10 Jacobi iterations are used for pressure projection, which may not fully eliminate divergence in larger simulations. Backpropagation through 10 iterations is successful, but for longer processes like MGPCG with 5 multigrid levels and 50 conjugate gradient iterations, numerical accuracy may be insufficient due to numerical drift in conjugate gradients. DiffSim can be used for forward MGPCG implementation. DiffSim allows users to implement the forward MGPCG solver while manually implementing the backward part of the Poisson solve. It provides \"complex kernels\" to override the built-in AD system. The wave equation is used to model shallow water height field evolution, with a finite difference time-domain method used for discretization. The wave simulator in DiffSim simulates shallow water using a grid of resolution 128 \u00d7 128 and 256 time steps. The loss function is defined with 200 gradient descent iterations. The final time step T and target height field \u00fb are optimized using 200 gradient descent iterations. The \"Taichi\" symbol is set as the target pattern for wave evolution. Mass-spring robots with ground collision and a NN controller are designed to maximize forward movement. A differentiable rigid body simulator is used for optimizing billiards strategy with collision resolution based on conservation laws. The rigid body simulator deals with collisions that can be non-differentiable at certain points, similar to ReLU activation in neural networks. Despite these discontinuities, gradients are still useful for optimization in impulse-based rigid body simulations, especially with a time-of-impact fix. Differentiable renderers are implemented to visualize refracting water surfaces. Differentiable renderers are used to visualize refracting water surfaces by reconstructing water surface models and refracting camera rays. An adversarial optimization goal is set to fool VGG-16 into mistaking a refracted squirrel image for a goldfish. Additionally, a basic volume renderer is implemented using ray marching to integrate a density field over each camera ray, with the goal of optimizing the density field to produce target images. The curr_chunk discusses the process of rendering candidate images and computing an L2 loss between them and target images. It also mentions using Coulomb's law in a scenario with electrodes carrying static charge. A two-layer neural network controller manipulates the electrodes to guide a red ball following a blue ball's path. The implementation of rigid body simulation is slightly more complex. Initialization is crucial in physical processes to avoid flat lands and local minima. The curr_chunk discusses the challenges of flat lands and local minima in physical processes, using examples from billiards and rigid body simulations. It highlights the importance of proper initialization to avoid getting trapped in non-trivial local minima. Real-world physical processes may contain discontinuities even in ideal models, leading to unexpected outcomes. In rigid body simulations, corners hitting the ground first can result in discontinuities due to numerical precision issues. Safeguarding the parameter r is crucial for gradient stability to avoid inaccurate gradients. Friction in rigid bodies with collisions can also lead to discontinuities in final positions."
}