{
    "title": "BJxOZ04Kvr",
    "content": "Implementing correct method invocation is crucial for software developers, but it can be challenging due to the complexity of method structures. The InvocMap code completion tool helps developers by predicting nested method invocations not listed in the input method names. It analyzes method invocations at four levels of abstraction and uses a Machine Translation engine to map from the first to the third level. Developers only need to add local variables from the generated expression to complete the code. The approach was evaluated on popular libraries like JDK, Android, GWT, Joda-Time, Hibernate, and Xstream. InvocMap is a code completion tool that predicts nested method invocations in Java code. It achieves an accuracy rate of up to 84% in F1-score using a training corpus of 2.86 million method invocations. This tool helps developers with auto code completion by analyzing method invocations at different levels of abstraction. Developers only need to add local variables from the generated expression to complete the code. The Java Development Tool (JDT) library provides a list of Abstract Syntax Tree (AST) Node types to help developers interact with and analyze Java source code snippets. Method Invocation (MI) is a fundamental AST Node used for making API calls in Java projects. MI contains the method name, receiver, and list of arguments. The structure of a Method Invocation (MI) in Java can be complex, resembling a deep AST tree due to the different types of AST Nodes it can be composed of. An example in Listing 1 shows a MI with nested MIs and local variables. Type casting is used to ensure semantic correctness. The representation of a MI also depends on the code context. The representation of Method Invocation (MI) in Java relies on code context. Examples 2A and 2B in Listings 2 and 3 show the implementation of API android.content.Intent.getBooleanExtra(). The MIs differ in AST structure, with Listing 2 involving adding or removing an application package and Listing 3 involving network status checking. This results in 2 static Field Accesses Intent.EXTRA REPLACING and ConnectivityManager.EXTRA NO CONNECTIVITY. The code snippet involves invalidating a rectangle offset and setting its coordinates in Android. The examples show different implementations of API android.content.Intent.getBooleanExtra() in Java, with one involving package addition/removal and the other involving network status checking. Implementing an effective method invocation in Android requires strong developer background and experience. Even with the same API and context, developers face challenges in implementation. This hinders writing appropriate method invocations, requiring time to remember the correct structure. This work aims to address these challenges. InvocMap is a code completion tool designed to help developers efficiently implement method invocations in Android. It accepts method names as input and generates ASTs as translation results, requiring only information about local variables and literals to complete the code. This tool aims to simplify the process of writing method invocations by providing suggestions based on the input method names. Statistical Machine Translation (SMT) is used in Natural Language Processing (NLP) for translating between languages. A proposed direction for code completion for Method Invocation involves learning the translation from abstract information of MIs to their detailed information represented by AST with a complex structure. The approach involves analyzing the information inside a typical MI, dividing it into four levels of abstraction, defining context information for each MI, and building an SMT engine to infer from the abstract layer of MI to the AST structure. Experiments are conducted to evaluate the accuracy of the code completion technique in two datasets. The research involves experiments to test the accuracy of a code completion technique using data from Github and online forums. Contributions include designing rules for extracting code tokens, proposing an algorithm for abstracting method invocations in AST, and building an SMT system for learning from code context. InvocMap provides a plugin for Java code editors to write method names. InvocMap provides a plugin for Java code editors that allows developers to write method names, which are then translated to ASTs. These ASTs simplify the complex structure of method invocations, requiring developers to only add local variables, methods, or literals to complete the code. The Statistical Translation module infers ASTs for code completion by learning from data extracted from Github. This statistical approach leverages the knowledge of experienced developers to train a machine learning model. The text discusses the process of implementing Method Invocations (MIs) using a machine learning model to assist non-experienced developers. It involves analyzing source code and code corpus to extract sequences of tokens using Train AST Visitor and Test AST Visitor modules. Different levels of abstraction for method invocations are defined, ranging from method name to Abstract Syntax Tree with placeholders for local variables and methods. The text discusses 4 levels of abstraction in Method Invocation (MI), with level 4 being the complete Abstract Syntax Tree. Each MI also has a local context defined. The implementation involves representing the AST in level 3 with 4 fields for code, argument types, imported APIs, and MI type, creating a unique identification token. In our work, we focus on inferring from level 1 to level 3 by translation, using local context information to help developers retrieve the AST of implementation. The suggested terms for local entities include \"System\" and \"+\". Level 1 of abstraction involves Partial Qualified Name (PQN) information, while Level 2 involves Fully Qualified Name (FQN) information for other AST Nodes. Nodes contain Fully Qualified Name (FQN) information for different types of AST Nodes. The Context Extractor module extracts tokens from AST Nodes to provide context for Method Invocation (MI) prediction. MI tokens include method name mapping and local context information. The extraction process is implemented in the Train AST Visitor and Test AST Visitor modules. The source and target languages store information about token abstraction levels for Method Invocation (MI). Local context information is stored at different abstraction levels in both languages. An algorithm is proposed to extract level 3 abstraction in MI, using AST Visitors and an InvocAbstractVisitor class. The InvocAbstractVisitor defined in Listing 5 visits elements inside the MI, abstracts local entities, and stores code information, required types, and imported APIs. The visitStructure() function in Listing 5 handles different types of AST Nodes. After abstracting to AST Level3, the object is checked against a dictionary for existing objects. If not found, a new unique id is generated and added to the dictionary. The dictionary stores abstraction information for MIs at layer 3 during training. The SMT model, consisting of language and translation models, is used to map source and target languages. The language model (LM) predicts the next token based on previous tokens, with the n-gram LM being utilized here. A more extensive target language corpus leads to higher LM prediction quality. Uni-gram LM, commonly used in SE research, has limitations in considering word usage history. The n-gram LM, proposed by Jurafsky & Martin, is applied to a target language AST with m tokens. The translation model calculates the probability of translating a phrase from the source language to the target language. Data preparation involves selecting a corpus from well-known libraries like JDK, Android, GWT, Joda-Time, Hibernate, and XStream for evaluation. The study generated a corpus by selecting 1000 top Java projects from Github and parsing Java source files using InvocMap. Training the SMT model required a high-end computer with specific configurations, and testing involved evaluating the translation ability from method names to ASTs. The local context for method names increased in complexity for testing. The local context for method names increases in complexity from level 1 to level 3. Level 1 involves only method names for translation, level 2 includes partial class names of local entities, and level 3 adds information about local entities and words from the method name. This simulates developers' varying levels of memory and understanding of code structures. The evaluation metrics for method name and MI recognition include Precision and Recall. Out of Vocabulary (OOV) results are categorized as Out of Source (OOS) or Out of Target (OOT). The parallel corpus is split for training and testing, with 10% used for testing and the rest for training. Ten-fold cross-validation is performed on the full dataset of 2.86 Million MIs from 1000 Github projects. The F1 score increases from 73.06% to 84.4% from configuration 1 to configuration 3. The F1 score increases from 73.06% to 84.4% in configuration 3 by providing more local context information with method names. Out of Vocabulary expressions are higher, causing a decrease in recall compared to previous research. Our work infers MI in level 3 of abstraction, which contains more detailed structure. An example in the Intrinsic Evaluation shows the testing scenario where developers input only println in the code environment. The study involved collecting code snippets from online forums to evaluate the accuracy of predicting method invocations. Results showed that even with minimal context, the approach correctly predicted 68.5% of cases. In the evaluation, the approach predicted method invocations with 68.5% accuracy. With additional configuration levels, the accuracy increased to 84%. The highest accuracy was achieved with GWT and the lowest with Hibernate, attributed to the complexity of APIs in Hibernate. The analysis showed that 72% of method names had more than 100 mappings in the parallel corpus, indicating the complexity of implementation for each method. The precision of method invocation prediction decreases from 96.47% to 87.68% with a higher number of mappings. Machine Learning in Software Engineering faces challenges in code generation, with low accuracy in code inference from documentation due to noise data and the complexity of AST Node structure. In our work, we focus on inferring complex Abstract Syntax Tree structures of Method Invocations at level 3 abstraction. Previous research has generated code from natural language descriptions, but we take a different approach by utilizing surrounding context along with textual descriptions for code generation. In our work, we propose InvocMap, a SMT engine for inferring ASTs of method invocations from method names and code context. Evaluation on Github projects and online forums shows potential for auto code completion. InvocMap abstracts method invocations at four levels and provides an algorithm for AST inference. Future work includes extending the approach. Future works involve extending the SMT model to support inputs from multiple natural language descriptions of method invocations and exploring machine learning techniques for accuracy improvement."
}