{
    "title": "BJxN9Hvf-V",
    "content": "Traditional load-balancing policies are facing challenges due to the rapid growth of cloud infrastructure. In heterogeneous systems, traditional solutions like JSQ result in increased communication overhead. Low-communication alternatives like JSQ(d) and the JIQ scheme either lack stability or offer poor performance. The Loosely-Shortest-Queue family of load balancing algorithms introduces a new approach to low-communication load balancing. Each dispatcher maintains a different approximation of server queue lengths and routes jobs to the shortest queue. Communication is only used to update approximations. The policy is formally proven to be strongly stable and can achieve throughput optimality with minimal communication. The Loosely-Shortest-Queue load balancing algorithms are proven to be stable and outperform other low-communication policies in heterogeneous cloud service systems. The design of load balancing algorithms for parallel server systems has become challenging due to the increasing size and heterogeneity of cloud services. In modern large-scale systems, various accelerated devices like GPUs, FPGAs, and ASICs are used alongside multiple generations of CPUs. VMs and containers are commonly deployed to share resources on servers, leading to unpredictable heterogeneity. Traditional load-balancing methods like JSQ may not be as effective in these scenarios. In single-centralized-dispatcher scenarios, the dispatcher serves as the access point to servers, tracking queue lengths by receiving notifications from each server. Communication overhead is minimal, with only one message per job. However, in growing clouds with multiple dispatchers, implementing a policy like JSQ becomes challenging due to increased communication messages per job as the number of dispatchers (m) rises. Scaling the number of dispatchers in cloud systems is challenging due to high communication overhead and lack of service guarantees with heterogeneous servers. Multi-dispatcher services are decomposed into independent single-dispatcher services, leading to unpredictable guarantees and communication bursts. Scalable policies for heterogeneous systems with multiple dispatchers are limited, with suggested policies based on join-the-idlequeue (JIQ). In heterogeneous settings, policies like JSQ(d) and JSQ(d, m) are used for routing decisions in cloud systems with multiple dispatchers. JSQ(d) samples d queues uniformly at random, while JSQ(d, m) samples the m shortest queues from the previous decision in addition to d new queues. JSQ(d) is stable in homogeneous servers but leads to poor performance and instability in heterogeneous servers. On the other hand, JSQ(d, m) has been shown to be stable with a single dispatcher but offers poor performance and has not been explored with multiple dispatchers. In heterogeneous settings, policies like JSQ(d) and JSQ(d, m) are used for routing decisions in cloud systems with multiple dispatchers. The proof is completed by showing that routing decisions in W R do not depend on system state. A simple sufficiency condition is developed to prove a policy belongs to the Loosely-Shortest-Queue family. This condition ensures a non-zero probability of server updates to dispatchers at each time-slot. Loosely-Shortest-Queue policies aim to achieve low communication overhead regardless of push or pull-based communication methods. The newest low communication policies, including Loosely-Shortest-Queue, offer strong theoretical guarantees and outperform other policies in various system scenarios. Extensive simulations demonstrate the stability and superior performance of Loosely-Shortest-Queue policies compared to alternatives within an equivalent communication budget. In a system with dispatchers balancing jobs among servers, job arrivals are forwarded immediately without storage. The total job arrival process is assumed to be i.i.d. over time slots with finite first and second moments. The division of arriving jobs among dispatchers follows an arbitrary policy not based on queue lengths. Dispatchers use limited information to send jobs to the shortest queue. Communication updates their local views to improve approximations of server queue sizes. Positive probability of job arrivals at all dispatchers is assumed, covering scenarios with time-varying arrival rates. In scenarios with non-independent arrival rates, jobs are forwarded to servers by dispatchers. Each server has a FIFO queue, and the potential service offered to each queue is defined. The service process of each server is assumed to be i.i.d. over time slots with finite first and second moments. Additionally, all service processes are mutually independent across servers. The Loosely-Shortest-Queue family of load balancing policies assumes independent service processes across servers and arrival processes. Dispatchers hold local-view estimations of server queue lengths and follow specific assumptions to define these policies. The Loosely-Shortest-Queue load balancing policy offers flexibility in design. It follows a local view based routing approach where dispatchers use JSQ policy based on queue lengths. A policy is termed as Loosely-ShortestQueue if it meets specific assumptions. Any Loosely-Shortest-Queue policy is proven to be stable, with strong stability defined by a constant upper bound on the sum of queue lengths. Strong stability is a key concept in queueing systems, ensuring finite average backlog and delay. It also implies other forms of stability like steady state stability and rate stability. Theorem 1 states that under sub-critical conditions, any Loosely-Shortest-Queue policy is strongly stable. The proof involves queue dynamics and rearranging equations. The text discusses the analysis of a queueing system by introducing two additional policies, JSQ and WeightedRandom (W R), to show the similarity of routing decisions. This allows for the independence needed to proceed with the analysis. The text introduces JSQ and WeightedRandom (W R) policies for routing jobs in a queueing system to achieve independence for analysis. It then discusses the routing of jobs to servers based on queue length and random selection, leading to further analysis by manipulating equations. The text introduces the W R policy for routing jobs in a queueing system to achieve independence for analysis. Lemmas are introduced to evaluate expected values, leading to the observation that certain variables are independent. The linearity of expectation is applied to derive further results. The W R policy for routing jobs in a queueing system is introduced to achieve independence for analysis. Lemmas are used to evaluate expected values, showing that certain variables are independent. The linearity of expectation is applied to derive additional results, leading to strong stability implications. The proof concludes with strong stability implications for policies in queueing systems, emphasizing the importance of Assumption 1 for establishing Loosely-ShortestQueue policies. A simplified sufficient condition is developed to ensure stable policies with low communication budgets, capturing various communication techniques between servers and dispatchers. The proof establishes strong stability implications for policies in queueing systems, emphasizing the importance of Assumption 1 for Loosely-ShortestQueue policies. A simplified condition is developed to ensure stable policies with low communication budgets. In this section, examples of push-based and pull-based communication policies are provided for Loosely-Shortest-Queue. The pull-based approach may offer better performance but can have additional implementation overhead compared to the push-based approach. Both frameworks are considered for policies with low communication overhead that can be unstable even with a single dispatcher. The JSQ(d) policy is a popular low-communication push-based load balancing approach, but it is not stable in heterogeneous systems even with a single dispatcher. An alternative Loosely-Shortest-Queue policy with similar communication budget is strongly stable for any number of dispatchers. This policy involves each dispatcher holding a local array of server queue length approximations and sending jobs to the minimum one among them. The approximations are updated based on job arrivals and random sampling of distinct queues. The Loosely-Shortest-Queue-Sample(d) policy updates local array entries based on random sampling of distinct queues, without estimating other dispatchers' actions or considering information age. Stability proof relies on sample messages, not job increments. The Loosely-Shortest-Queue-Sample(d) policy ensures strong stability in multi-dispatcher heterogeneous systems, even for d = 1. By sampling queues at each dispatcher, the system remains strongly stable under sub-critical conditions. The Loosely-Shortest-Queue-Sample(d) policy guarantees strong stability in multi-dispatcher heterogeneous systems, even for d = 1, by sampling queues at each dispatcher. This policy ensures strong stability under sub-critical conditions and leverages important idleness signals from servers. The Loosely-Shortest-Queue-Update(p) policy, chosen randomly, sends messages based on server idleness signals. It aims to prevent immediate starvation and maintain local views close to approximations, providing an advantage at high loads. This policy is similar to one in BID25 for a single dispatcher and homogeneous servers, ensuring strong stability in multi-dispatcher heterogeneous systems. The Loosely-Shortest-Queue-Update(p) policy ensures strong stability in multi-dispatcher heterogeneous systems by sending update messages based on server idleness signals. This policy prevents immediate starvation and maintains local views close to approximations, even at high loads. The system is proven to be strongly stable under this policy, regardless of the value of p. The Loosely-Shortest-Queue-Update(p) policy guarantees strong stability in multi-dispatcher heterogeneous systems by sending update messages based on server idleness signals. This policy prevents immediate starvation and maintains local views close to approximations, even at high loads. The system is proven to be strongly stable under this policy, regardless of the value of p. The updated dispatcher ensures that a job would be completed at each time slot, concluding the proof. TAB1 summarizes stability properties and communication requirements of load balancing techniques. LooselyShortest-Queue policy allows immediate routing decisions, unlike push-based policies. JSQ(2) policy incurs delay in sampling servers. Assumption 1 applies for constant time delay in update messages. The Loosely-Shortest-Queue policy requires minimal space and computational complexity for implementation. Each dispatcher needs to hold an array of server queue length estimations, which incurs negligible overhead. Despite potentially requiring O(n) operations for decision making, it allows immediate routing decisions compared to other policies like JIQ and JSQ(2). The Loosely-Shortest-Queue policy utilizes a priority queue for efficient decision-making, resulting in minimal overhead. It allows immediate routing decisions and can handle tens to hundreds of millions of queue length updates per second. Extensive evaluation of this approach is conducted using different parameter settings. The Loosely-Shortest-Queue policy, along with variations like Loosely-Shortest-Queue-U pdate(p), are compared to other queue algorithms in heterogeneous systems. Measurements include time-averaged number of jobs, mean delay, stability region, and communication overhead. The study covers scenarios with low and high skew, single and multi-dispatcher setups, and includes results for homogeneous systems in the appendix. The study evaluates the performance of Loosely-Shortest-Queue policy in heterogeneous systems with different server types. Results show that LSQ-U pdate(0.01) is stable, while JIQ is not stable. The simulation includes a single dispatcher and 10 heterogeneous servers, with communication overhead per time slot considered. In a larger scale scenario with 10 dispatchers and 100 heterogeneous servers, LSQ-U pdate(0.01) remains stable with similar communication overhead. Loosely-Shortest-QueueSample(2) outperforms JSQ(2) in all three scenarios, with JIQ showing instability as the proportion of weak servers decreases. LSQ-U pdate(0.01) consistently outperforms JSQ with lower communication budget. In a scenario with highly skewed heterogeneous servers, Loosely-Shortest-QueueSample(2) outperforms JSQ(2). The job arrival process is Poisson, while server service processes are geometrically distributed. The simulation includes strong and weak servers with a ratio of 10 between their service rates. The results are shown in FIG7 for a small scale scenario with a single dispatcher and 10 servers. Loosely-Shortest-Queue-Sample(2) is stable and outperforms JSQ(2) in scenarios with highly skewed heterogeneous servers. JIQ is unstable with a decreased stability region, while LSQ-Update(0.01) remains stable with similar communication overhead. JSQ(2) shows degradation, especially when the number of strong and weak servers is similar. LSQ-Sample(2) is always stable with identical communication overhead, and even LSQ-Sample(1) is stable with less communication overhead. In a larger scale scenario with 10 dispatchers and 100 servers, LSQ approaches remain stable and perform well with low communication overhead. LSQ-Update(1) is slightly worse than JSQ but with significantly less communication overhead. LSQ-Update(0.01) and LSQ-Sample(2) are stable with good performance using similar communication budgets as JIQ and JSQ(2). The Loosely-Shortest-Queue approach consistently guarantees stability. The Loosely-Shortest-Queue approach ensures stability with low communication overhead, outperforming other low-communication techniques in various scenarios. It indirectly addresses the incast problem in parallel multidispatcher systems and shows a trade-off between push-based LSQ-Sample(d) and pull-based LSQ-Update(p) approaches for minimal communication overhead. LSQ-Update(p) performs better at low loads. LSQSample(d) is better at high loads, while LSQUpdate(p) is better at low loads. The Loosely-Shortest-Queue approach offers strong theoretical guarantees and performance with low communication overhead. It can construct stable policies with minimal communication budget, regardless of using pull or push messages. The Loosely-Shortest-Queue approach provides strong stability with minimal communication overhead. Two dispatcher sampling rules achieve strong stability with average message rate at most r. Push-based and pull-based communication examples are given to illustrate this concept. Theorem 2 allows for designing strongly stable policies with hybrid communication methods. The Loosely-Shortest-Queue approach offers stable, scalable policies with low communication overhead. Examples show the effectiveness of LSQ-U pdate(p) at low loads and LSQ-Sample(d) at high loads. Hybrid communication methods combine advantages of JIQ and JSQ(d). Various lemmas are provided to support the main theoretical result. The proofs of lemmas towards Theorem 1 show that the optimal solution is the JSQ policy. Using Lemma 4, we derive key results and conclude the proof independently for each dispatcher applying the WR policy. The Loosely-Shortest-Queue family of load balancing algorithms was introduced in this paper. The optimal solution is the JSQ policy, proven independently for each dispatcher using the WR policy. The Loosely-Shortest-Queue family of load balancing algorithms was introduced in this paper, establishing their strong stability and simplified conditions for implementation. These policies allow for stable systems with low communication budgets in various scenarios, outperforming other known policies like JSQ(2) and JIQ. The Loosely-Shortest-Queue approach shows potential for scalable load balancing policies, offering better performance than JIQ as load increases. JIQ performs similarly to JSQ at low loads but degrades quickly with higher loads. This aligns with theoretical results indicating JIQ is worse than JSQ at high loads. In a larger scale scenario with 10 dispatchers and 100 servers, Loosely-Shortest-Queue-Update(1) performs slightly worse than JSQ but with significantly less communication overhead. Despite some degradation in performance due to multiple dispatchers, Loosely-Shortest-Queue-Update(1) remains stable and efficient. Loosely-Shortest-Queue-Update(0.01) outperforms JIQ with similar communication overhead. Loosely-Shortest-Queue-Update(2) is better than JSQ(2) with the same overhead."
}