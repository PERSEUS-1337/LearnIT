{
    "title": "HJgRIrHWt4",
    "content": "Hierarchical planning, specifically Hierarchical Task Networks, involves decomposing tasks into sub-tasks until primitive actions are obtained. Plan verification requires a complete plan to find a task that decomposes to it, while plan recognition involves finding a task that decomposes to a plan with a given prefix. This paper explains how plans can be verified and recognized using parsing, a method borrowed from formal grammars. Hierarchical planning is a significant approach to automated planning, encoding abstract plans as hierarchical task networks (HTNs) where compound tasks are decomposed into sub-tasks and actions, with additional constraints like partial ordering and causal links specified by decomposition methods. The verification of plans in Hierarchical Task Networks (HTNs) can be done using parsing-based systems, which support HTN fully by transforming the problem to SAT BID2. Plan recognition, on the other hand, involves adding a sequence of actions to form a complete plan, with parsing becoming popular for solving this problem due to the similarity between hierarchical plans and formal grammars. Plan recognition is a generalization of plan verification, with approaches using parsing or string rewriting. HTN planning problems lie between context-free and context-sensitive languages, requiring attribute grammars for full coverage. The undecidable nature of HTNs makes plan recognition challenging, with the current approach translating it to a planning problem. The paper focuses on verification and recognition of HTN plans using parsing, derived from a plan verification technique. It introduces novel methods to simplify verification and extend it to solve the plan recognition problem efficiently. The proposed methods cover full HTNs including task interleaving and decomposition constraints. The paper introduces novel methods to simplify plan recognition for HTN plans by not requiring information about possible top tasks and an initial state as input. This is particularly useful for plan/task recognition, where existing methods need a set of candidate tasks to select from. The methods proposed cover full HTNs including task interleaving and decomposition constraints. The paper introduces novel methods to simplify plan recognition for HTN plans by not requiring information about possible top tasks and an initial state as input. World states are modelled as sets of propositions that are true in those states and actions are changing the validity of certain propositions. Each action is described by sets of propositions representing positive preconditions. The paper presents techniques for planning problems, where actions have positive and negative effects on states. A solution is a sequence of actions leading from an initial state to a goal state. The plan verification problem involves determining if a sequence of actions forms a valid plan from an initial state to a goal state. Extensions to the basic STRIPS model include Hierarchical Task Networks BID3, which incorporate control knowledge in the form of task networks with sub-tasks and constraints. The planning problem in Hierarchical Task Networks (HTN) involves decomposing compound tasks into primitive actions, which are then linearly ordered to satisfy constraints. The obtained plan must be applicable to the initial state, similar to classical planning. Actions are denoted as a_i, with S_i representing the state after action a_i. In Hierarchical Task Networks (HTN) planning, tasks are decomposed into actions denoted as a_i, with S_i as the state after the action. Constraints like precedence, precondition, and prevailing conditions are used in the decomposition methods. The HTN plan verification and recognition problems involve determining if a sequence of actions forms a valid plan obtained from compound tasks, with the initial state possibly given as input. The HTN plan verification and recognition problems involve determining if a sequence of actions forms a valid plan obtained from compound tasks, with the initial state possibly given as input. The proposed hierarchical plan verification algorithm simplifies the process by directly checking all constraints in the input plan, making it easier to implement and faster than existing methods. The algorithm calculates intermediate states by propagating information about propositions in action preconditions and effects to verify plan causally consistency. It ensures every action is applicable and propagates preconditions to earlier states if not provided by the action. This process simplifies plan validation and recognition. The algorithm detects invalid plans by parsing tasks and composing actions. Each task is represented by a quadruplet (T, s, e, I) where T is the task, s is the index of the first action, e is the index of the last action, and I is a Boolean vector. This simplifies checks of decomposition constraints. The algorithm composes new tasks by applying decomposition rules to known sub-tasks. It merges sub-tasks by checking that actions come from a single sub-task and meet decomposition constraints. If all tests pass, the new task is added to a set of tasks. The algorithm composes new tasks by applying decomposition rules to known sub-tasks, merging them if they meet decomposition constraints. Tasks are added to a set until all actions are decomposed or no new tasks can be composed. The algorithm is sound and complete, as it returns a task decomposed into all actions. Plan recognition can be achieved by extending a plan verification algorithm with additional actions. The algorithm efficiently composes tasks by merging sub-tasks based on decomposition rules. It utilizes a verification algorithm that stores actions independently and generates states between actions only when combining them. This approach resembles the Graphplan algorithm. The algorithm efficiently composes tasks by merging sub-tasks based on decomposition rules. It utilizes a verification algorithm that selects candidate actions for each position in the plan and forms a causally valid plan. The algorithm starts with actions a1,...,an and finds compound tasks that decompose to subsets of these actions. If a task decomposing to all current actions is found, then the recognized plan is described. The algorithm efficiently composes tasks by merging sub-tasks based on decomposition rules. It starts with actions a1,...,an and finds compound tasks that decompose to subsets of these actions. The algorithm then adds primitive tasks corresponding to possible actions at position n + 1. It continues to compose new tasks using previously added primitive tasks until the goal task is found. The algorithm is sound and semi-complete, ensuring the shortest plan with a given prefix. The algorithm for plan recognition is semi-complete, as it will eventually find a plan with a given prefix at the (k + 1)-th iteration. However, if no plan with the prefix exists, the algorithm will not stop. The algorithm maintains a timeline for each compound task to verify constraints, a key difference from the verification algorithm. The paper discusses timelines as ordered sequences of slots describing actions, effects, and states for task T. Two sets of propositions are used to model positive and negative effects, as well as propositions that must and must not be true before an action. Interleaving of tasks can result in slots from one task being between actions of another task in the plan. The paper discusses timelines as ordered sequences of slots describing actions, effects, and states for task T. Interleaving of tasks can result in empty slots between actions. Sub-tasks are merged slot by slot to create a compound task, ensuring each action is generated by exactly one task. The function APPLYPRE updates slots based on before constraints, checking consistency to ensure no proposition is true and false at the same state. The proposed techniques handle task interleaving by allowing actions from different tasks to form a plan. The plan recognition algorithm can also serve for plan verification when a complete plan is given. The algorithm composes tasks in iterations, constructing timelines with empty slots based on the exact location of actions in the plan. Tasks are merged to form alternative decomposition trees, leading to a complete timeline spanning the plan. The algorithm composes tasks in iterations, constructing timelines with empty slots based on the exact location of actions in the plan. Tasks are merged to form alternative decomposition trees, leading to a complete timeline spanning the plan. The algorithm efficiently handles method constraints by using the complete plan with states for verification. Algorithm 1 efficiently verifies constraints using the complete plan with states, running the propagation of states once. The Boolean vector I is used to identify actions for each task, ensuring constraints are checked only once when composing new tasks. The plan recognition algorithm efficiently derives tasks from a given plan prefix, adding actions sequentially to form primitive tasks. The algorithm ensures constraints are checked only once when composing new tasks. The plan recognition algorithm efficiently derives tasks from a given plan prefix by adding actions sequentially to form primitive tasks. The algorithm ensures constraints are checked only once when composing new tasks, such as adding tasks T0, T2, T1, T3, T4, and T7 in a specific order to achieve success. The plan recognition algorithm efficiently derives tasks by adding actions sequentially to form primitive tasks. Algorithm 2 adds actions a 5 and a 7 as possible tasks at position 7, using tasks T 1 , T 3 , T 4 from the previous iteration. It successfully composes tasks T 0 , T 2, T 1 , T 3 , T 4, and T 7 in a specific order. The parsing technique for verification and recognition of HTN plans is novel and covers all decomposition constraints. Implementation and empirical evaluation of both techniques are the next steps. The verification algorithm is faster than previous approaches, but the efficiency of the plan recognition technique compared to existing compilation techniques is unclear due to different approaches used. The parsing technique for HTN plans involves regenerating the known plan prefix with heuristics to reduce overhead. It operates like a generate-and-test process controlled by hierarchical structure, ensuring the shortest extension of the plan prefix is found."
}