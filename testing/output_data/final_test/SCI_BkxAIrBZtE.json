{
    "title": "BkxAIrBZtE",
    "content": "Hierarchical Task Networks (HTN) use extra domain knowledge to guide search towards planning tasks. HTN planners can make calls to external processes during decomposition, but this is computationally expensive. This paper introduces semantic attachments for HTN planning using semi co-routines to link the planning process to custom unifications outside of the planner. The planner introduced in this paper utilizes co-routines to enhance backtracking and search through parallel dimensions of the state-space, particularly in domains with numerical variables. It outperforms existing numeric planners in various domains without requiring extensive domain knowledge. Numeric planning problems, such as those involving real-valued functions for tasks like robot navigation, present challenges in expressing variables and functions efficiently, as well as in finding optimal solutions. In this paper, the Semantic Attachment (SA) construct is extended for HTN planning to improve efficiency in reasoning about fluents with numeric values. The approach focuses on depth-first search HTN implementation without heuristic guidance, ensuring free variables are fully grounded before task decomposition continues. The approach extends the Semantic Attachment construct for HTN planning to optimize the use of continuous resources involving numeric values. Planners often simplify complex objects to symbolic values for easier comparison, but this may lead to replanning. The goal is to utilize external formalisms to address these challenges. Our goal is to exploit external formalisms in HTN planning by introducing Semantic Attachments (SAs) to unify values like predicates. SAs are implemented as semi co-routines to iterate across values provided by an external function, extending classical HTN planning algorithms. The text introduces Semantic Attachments (SAs) for HTN planning to evaluate external predicates at execution time and a symbol-object table for better readability of plans. It compares the resulting HTN planner with a classical planner in mixed symbolic/numeric domains, showing speed gains with minimal domain knowledge. Classical planning algorithms transform world properties from initial to goal configurations using logical predicates and operators. The text discusses how operators and predicates are used in planning, with a focus on achieving the goal state through the application of operators with specific preconditions and effects. It also mentions the use of free variables for generalizing operators and the concept of grounding. Additionally, it touches on the optimality of plans based on criteria like the number of operators or effort required. The text also mentions PDDL as the standard language for describing planning domains and problems. Hierarchical planning in PDDL (Planning Domain Definition Language) involves using a hierarchy of domain knowledge recipes to decompose tasks into primitive and non-primitive tasks, which are further refined until only primitive tasks mapping to operators remain, resulting in the plan itself. The goal is implicitly achieved by the plan obtained from this decomposition process. Hierarchical planning in PDDL involves decomposing tasks into primitive and non-primitive tasks until only primitive tasks mapping to operators remain, resulting in the plan itself. Unlike classical planning, hierarchical planning only considers tasks from the decomposition process, limiting problem-solving ability but improving execution time. HTN planning is more complex than classical planning, including domain knowledge with potentially recursive tasks to solve a wider range of problems. Classical planners with heuristic functions can efficiently solve problems mixing symbolic and numeric values through a discretization process. Numeric features are crucial in domains where discretization is not possible, such as geometric or physics subproblems. Unlike symbolic approaches, numeric value comparison is challenging and requires explicit definition of rounding errors to avoid unnecessary comparisons. When dealing with complex object instances like polygons in object-oriented programming, details such as polygon point order and floating point errors are often irrelevant for planners and domain designers. These low-level specifications can be implemented through external function calls to improve expressiveness and computation in HTN planners. However, using external functions may have limitations if a specific function is relied upon. When dealing with complex object instances like polygons in object-oriented programming, external function calls can be used to improve expressiveness and computation in HTN planners. However, there are limitations to this approach if a function is used in a decomposition tree where backtracking is needed. An external function must return a list of values to try one at a time until one succeeds, which can be costly. On the other hand, a semantic attachment acts as an external predicate that unifies with one set of values at a time, saving time and memory during planning. The SA acts as a black box simulating part of the environment, encoding results in state variables orthogonal to other predicates. SAs are computed at execution time by co-routines, minimizing memory usage and delegating complex state-based operations to external methods. Numeric parts of the planning process are abstracted through SAs in a layer between the symbolic planner and external libraries, following a three-layer architecture inspired by de BID2's work. In the planning process, symbols are manipulated in the symbolic layer, while external objects are manipulated in the external layer based on specified libraries. Symbol-object table is used to compare and reuse object instances, ensuring consistency in symbol representation. Symbols can be transformed into object instances through external function calls and SAs, maintaining global consistency. The intermediate layer acts as a foreign function interface between the symbolic and external layers, allowing for seamless transformation of objects back into symbols. SAs can function as interpreted predicates, evaluating truth values and grounding free variables. Currently limited to method preconditions without disjunctions, SAs can be optimized during compilation to improve execution time. The abstract method example in Listing 1 shows how free variables are used as SAs. The compiled output in Algorithm 1 evaluates SAs after common predicates, with function calls occurring based on ground variables. The compilation phase may reorder preconditions for optimization. The limitations of current SA co-routines include the need to unify with valid values or have a stop condition within internal iterations. The HTN process requires a stop condition to prevent infinite backtracking and searching for new values. Domain designers should limit the number of times a SA can evaluate a call to avoid infinite loops. Implementing a counter in the internal state of a SA can help manage this, but it may lead to side-effects in external structures, complicating correctness proofs and debugging. The ability to inspect and debug domain descriptions involves checking for object collisions by calculating the distance between centroid positions. Mapping centroid position symbols to coordinate instances simplifies the process, allowing for comparison of symbols to determine if objects are near enough to collide. This method is illustrated in Figure 2, where centroid position symbols match symbols in a symbol-object table, mapping their values to point objects for distance computation. The symbol to object table maps symbols to object-oriented programming instances to hide procedural logic from the symbolic layer. Planning descriptions usually do not contain information about numeric intervals and precision, but the STEP SA algorithm unifies numbers within a given interval with a step. The STEP SA algorithm unifies numbers within a given interval with a step, avoiding complex effects in move operators by not updating adjacencies between planning objects during the planning process. The algorithm replaces the pointer of an object with a numeric symbol before resuming control to the HTN. Positions and adjacencies are managed in a partitioned space, either used to generate ground operators or stored as part of the state. Algorithm 3 outlines the two main cases in planning descriptions, where objects are ground and the co-routine resumes when both objects are adjacent. The ADJACENT SA implementation checks if two symbols map to adjacent positions or generates new positions to unify symbols. Empirical tests were conducted on a machine with Dual 6-core Xeon CPUs @2GHz / 48GB memory, repeating experiments three times for an average result. In the Plant Watering domain, agents move in a 2D grid to obtain water from taps and pour it on plants. Various state variables are represented as numeric fluents. The main problems are traveling to taps or plants and determining the top-level strategy. The HTN implementation is available on github.com/Maumagnaguagno/HyperTensioN U. In the Plant Watering domain, agents move in a 2D grid to obtain water from taps and pour it on plants. The top-level strategy involves traveling to taps or plants efficiently. One approach is to simplify the travel method by moving straight to the goal first. A modified ADJACENT SA algorithm considers the goal position. The top-level strategy also considers factors like proximity to taps or agents and water carrying capacity. A simple strategy involves traveling to a tap, loading water, and pouring it on plants until all are watered. The travel method is described using a modified JSHOP input language. Our approach, compared with ENHSP configurations, is faster with execution times constantly below 0.01s. The goal-driven ADJACENT SA algorithm involves coordinating pairs to move closer to the goal position in an obstacle-free scenario. In the Car Linear domain BID0, the goal is to control the acceleration of a car within speed limits, moving through one axis to reach its destination safely. The planner must decide when to adjust acceleration to control the car's speed and position safely. A STEP SA is used to iterate over time and enforce speed constraints. Comparison with ENHSP shows faster execution times. Simplifying the environment to geometric shapes aids in collision evaluation for agents moving in continuous space. One approach to simplifying the environment for faster collision evaluation is to find a circle or sphere that contains each obstacle. The best path is determined by the shortest lines between the initial position and goal, considering bitangent lines between obstacles and the amount of arc traversed on their borders. A possible strategy is to move straight to the goal or the closest obstacle to the goal, ensuring a visible target without obstacles in between. Consideration should also be given to the entrance direction to avoid cusped edges. The problem defined in FIG3 involves solving search over circular obstacles using bitangents. Two approaches can be taken: relying on an external solver to compute the entire path during or after HTN decomposition, or using parts of the external search to describe continuous search to the HTN planner. The continuous search to the HTN planner involves the VISIBLE function determining if a point on a circle can see the goal, and the CLOSEST SA generating unifications from one circle to another. This approach allows for dealing with failure at any moment and the ability to ask for N plans, forcing the HTN to backtrack and explore different paths. The execution time variance between solutions is not as important as their different approaches to obtaining a result. The external search in HTN planning involves computing bitangents on demand, using semantic attachments for defining external numerical functions, and improving planning speed by evaluating only relevant semantic attachments during path decomposition. This approach offers substantial speed improvements over classical planning methods. Our work introduces semantic attachments for HTNs, allowing designers to define external functions for operator grounding and dynamically generate symbolic representations of external values at planning time. This enhances plan readability and offers a new approach to search in SA-enabled domains within HTN planners. Future work includes implementing a cache for reusing previous values and a generic construction to access data from explored branches outside the state structure. The text discusses the development of semantic attachments for HTNs to incorporate external predicate information and domain knowledge. Future work involves comparing planners based on plan quality and exploring metrics for incorporating external knowledge into heuristic functions."
}