{
    "title": "rylaZ6iIDr",
    "content": "With the rise of IoT devices, our cyberspace is filled with diverse computing nodes, posing challenges for dynamic analysis to detect software bugs. Laelaps is introduced as a device emulator for running various software on low-cost IoT devices without specific device information encoded. This approach aims to address security concerns and advance IoT technology. Laelaps is a unique device emulator that can run diverse firmware without prior knowledge about the target device. It allows for dynamic analysis techniques like fuzzing testing and dynamic symbolic execution to identify vulnerabilities in low-end embedded devices. This approach addresses security concerns in IoT technology. A versatile device-agnostic software-based emulator is needed to execute various microcontroller firmware. The emulator must handle the diversity in hardware architecture, integrated features, and operating systems. Customizing the emulator for every type of equipment is nearly impossible due to the vast diversity in System-on-Chip (SoC) design methodology. Manufacturers integrate custom-made functions to make their products competitive. Manufacturers integrate custom-made functions in peripherals to stay competitive. For example, the NXP FRDM-K66F chip has over 50 different peripherals. Analyzing embedded firmware dynamically is challenging due to existing solutions being adhoc or specific to certain operating systems. Implementing a generic emulator for different peripherals requires significant effort. Existing work forwards peripheral signals to real devices and runs the rest of firmware in an emulator for analysis. Recent research has focused on virtualized execution of firmware without the need for specific back-end peripheral emulators. Previous work has also explored emulating Linux-based firmware using tools like FIRMADYNE and FIRM-AFL for file system extraction and grey-box fuzzing. In this work, Laelaps is introduced as a generic emulator for ARM Cortex-M based microcontroller units (MCUs), aiming to execute non-Linux firmware without real devices. It leverages symbolic execution and SMT to reason about expected inputs from peripherals and feed them to the firmware on the fly. The design combines concrete and symbolic execution in a full system emulator, QEMU. Laelaps uses a combination of concrete and symbolic execution in QEMU to handle unknown peripherals. Symbolic execution is effective in inferring peripheral inputs for logical and arithmetical calculations, guiding firmware execution when accessing unfamiliar peripherals. This approach helps generate proper inputs to navigate QEMU towards a path resembling real execution. One practical challenge in automatic test generation is exploring program paths, especially with peripherals. A tunable path selection strategy called CPSA helps prune the search space for the most promising path. Peripherals interact with firmware through interrupts, crucial in embedded systems driven largely by interrupts. QEMU supports interrupt delivery but lacks knowledge on when to assert an interrupt, requiring implementation by peripherals. \"Laelaps\" metaphorically represents the versatility of the proposed solution for analyzing firmware on ARM Cortex-M MCUs. The solution, developed on top of angr and QEMU, initializes the execution context for dynamic analysis. Evaluation on 30 firmware images shows applicability to various architectures, including IoT programs running FreeRTOS OS. The Laelaps tool enhances dynamic analysis of IoT firmware by making firmware fuzzing more efficient, assisting dynamic symbolic execution, enabling interactive debugging with GDB, and saving device state for future analysis. The Laelaps tool enhances dynamic analysis of IoT firmware by abstracting the system model of ARM Cortex-M based embedded microcontroller devices and designing a symbolically-guided emulator for full system device emulation. It facilitates the execution of advanced dynamic analysis tools like boofuzz, angr, and PANDA, enabling the identification of self-injected and real-world vulnerabilities. The ARM Cortex-M family is a dominant product in the microcontroller market, with over 22 billion units shipped. These devices include Cortex-M0, Cortex-M0+, Cortex-M3, and Cortex-M4 cores based on ARMv6-M, ARMv7-M, or ARMv8-M architectures. They are essential in IoT innovations due to their cost-effectiveness and power efficiency. Laelaps, an open-source tool, enhances dynamic analysis of IoT firmware to identify self-injected and real-world bugs. The ARM Cortex-M processors, based on ARMv6-M, ARMv7-M, or ARMv8-M architectures, do not support MMU, leading to a flat memory address space where application and operating system code coexist. This design choice excludes Linux kernel support but has fostered the development of alternative ecosystems like Amazon FreeRTOS and Arm Mbed OS. Peripheral functions are accessed through system memory registers, as everything, including ROM, RAM, and peripherals, is mapped into a single address space. ARM defines basic functionality and memory maps for core peripherals like the interrupt controller. ARM Cortex-M processors do not support MMU, leading to a flat memory address space. Peripheral functions are accessed through system memory registers. ARM defines basic functionality and memory maps for core peripherals like the interrupt controller. ARM sells licenses of its core design as intellectual property, allowing licensees to customize their implementation. MCU firmware execution is divided into device setup, base system setup, RTOS initialization, and task execution phases. Firmware execution involves dynamic memory allocation, copying code into memory regions, initializing core data structures, and starting the scheduler for RTOS. Tasks are then executed in a time-sharing manner. Hardware uncertainties pose challenges for emulator development, with improper emulation leading to bootstrap failure. Multiple valid execution paths exist due to different driver versions included by manufacturers for peripherals. Symbolic execution, a technique first proposed by King, is a powerful automated software testing method that treats program inputs as symbolic variables. It can generate concrete inputs to cover new program paths and has shown promising results in testing closed-source device drivers. Dynamic symbolic execution, also known as concolic execution, combines symbolic execution with concrete execution paths. This approach enhances fault tolerance in firmware emulation, allowing for successful analysis even with wrongly selected paths. Launched as Laelaps, the concolic execution approach for peripheral emulation aims to address the path explosion problem in concrete execution. Peripheral-specific search heuristics are proposed to mitigate this issue, showing practical effectiveness. Chip manufacturers often integrate custom-made peripherals into the system's address space, in addition to the core peripherals/functions supported by QEMU. The logic of custom-made peripherals mapped into the system's address space defines an Arm MCU device's behavior. QEMU, the emulator, only supports a few Arm-based microcontrollers, leaving gaps in emulation when interacting with unimplemented peripherals. QEMU lacks the logic of unknown peripherals, leading to paralysis when firmware accesses an unimplemented peripheral. Providing a random value can cause indefinite execution. Most peripheral accesses are not critical to firmware execution. The statement configures pin functionality on the board but does not affect firmware emulation. Many peripheral accesses influence firmware control flow logic, driving the execution path. QEMU can execute firmware correctly if the correct path is followed. A code snippet for a UART driver is provided, showing how values are read and written to registers for UART communication. Symbolic execution was used to determine the input needed to reach line 4 in the firmware. Peripheral drivers often use peripheral registers for calculations that impact control-flow decisions. A study of a UART interface sample revealed 134 read operations, with 30 directly affecting control flow. Inference of the correct path increases the chance of success. Laelaps combines concrete and symbolic execution to emulate firmware execution. While symbolic execution may not work for all peripheral read operations, it can be used to calculate suitable values for unknown peripheral inputs. This approach addresses the limitations of pure concrete and symbolic execution methods. Laelaps combines concrete and symbolic execution to emulate firmware execution, gaining advantages of both. It requires basic device information to initialize the environment and predicts proper read values for unknown memory accesses. Peripheral write operations are ignored as they do not affect program status. When an unknown read operation occurs, the processor context and memory are synchronized to the symbolic execution engine. During symbolic execution, unknown peripheral accesses are symbolized, and a path selection algorithm chooses the most promising path. Various events can terminate symbolic execution, such as synchronous exceptions or reaching the limit of executed branches. Long loops may transfer execution to the concrete engine to avoid consuming excessive time. Emulation does not remain in the symbolic engine indefinitely to prevent path explosion issues. During symbolic execution, a limit is set for the maximum branches encountered to avoid path explosion issues. Analysts can configure program points to terminate symbolic execution based on prior knowledge. The values of symbols navigating the execution path are evaluated and fed to QEMU to guide concrete execution. Laelaps alternates between QEMU and symbolic execution passes to push firmware execution forward. The Laelaps platform pushes firmware execution forward by switching between QEMU and symbolic execution passes. It includes core components like the state transfer module, symbolic execution module, and path selection algorithm. Device interrupts are emulated to progress execution. When an unknown peripheral read is detected, the program state is transferred to the symbolic execution engine. Laelaps synchronizes the processor context to the symbolic execution engine for further analysis. During symbolic execution, QEMU is suspended, and the symbolic execution engine works on its own RAM copy using a copy-on-access strategy. New symbols are assigned to peripheral read operations to account for the volatile nature of peripheral memory. Different addresses and times receive different symbols to capture the nondeterministic changes in values. During symbolic execution, different symbols are assigned to peripheral read operations at different times and addresses to capture volatile memory changes. Context switches in firmware involving tasks and event handlers are not handled correctly, leading to termination of symbolic execution to maintain the original execution mode. During symbolic execution, context switches trigger a transfer of execution to QEMU for handling synchronous exceptions like supervisor calls and exception returns. Laelaps holds solved symbols for replay, expecting QEMU to follow the same path. However, QEMU's emulation capability can deviate from the expected path, rendering solved symbols useless. To avoid discarding symbols due to exceptions, a practical approach is taken where QEMU resumes replay without accepting deviations. During symbolic execution, Laelaps handles unrecognized ARM instructions by either replacing them with NOP instructions or switching to QEMU for concrete execution. Predefined events trigger a switch back to QEMU when needed. During symbolic execution, Laelaps uses an SMT solver to find concrete inputs for symbolic formulas and steer QEMU's execution. Symbolic execution is slower than concrete execution, so it aims to minimize time spent while predicting similar paths. Long loops controlled by concrete counters are executed symbolically until completion, but this is inefficient for functions like memcpy and memset. At node 0x424, branches are explored, with the most promising path chosen. During symbolic execution, Laelaps selects the most promising path at each branching, avoiding infinite loops and re-executing old paths. It automatically detects long loops and transfers execution to QEMU when necessary. Laelaps's goal is to find the most promising path and direct QEMU towards it, despite the challenge of lacking high-level semantic information. The Context Preserving Scanning Algorithm (CPSA) is used to select the right branch during symbolic execution. CPSA prioritizes a \"right\" branch using main search heuristics. With Context_Depth set to two, each pass decides results for two branches. Forward_Depth set to three allows exploration of three future steps for each branch. The engine explores future steps for each branch, selecting the most promising path. In the code snippet, the Ethernet driver initializes the interface and configures the NIC with a PHY address. If the invocation fails, an assert function is called, leading to an infinite loop. The Ethernet driver initializes the interface and configures the NIC with a PHY address. PHY_Write interacts with NIC for configuration. Laelaps switches between QEMU and symbolic execution passes, affecting decision-making. Early concretization of symbolic values may lead to suboptimal decisions. The root reason for suboptimal decisions is early concretization of symbolic values, leading to over-constraining. Inspired by speculative symbolic execution, the approach delays invoking the constraint solver for bssReg, advancing along the path to solve it with ctlReg. Analysts can set a Context_Depth parameter to control the number of branches before invoking the solver, balancing fidelity and performance. However, a larger Context_Depth increases exploration time in symbolic execution. Symbolic execution can get stuck in an infinite loop when failed invocations to PHY_Write or PHY_Read occur. Analysts can set a Forward_Depth parameter to limit the number of basic blocks the symbolic engine can advance from a branch. Laelaps selects branches based on infinite-loop-elimination. The symbolic engine detects infinite loops by comparing execution states within explored paths. The symbolic engine in Laelaps uses infinite-loop-elimination to detect and avoid infinite loops during symbolic execution. This approach compares execution states within explored paths, focusing on registers with concrete values to determine if a path is an infinite loop. However, this heuristic may mistakenly filter out legitimate paths that appear to be infinite loops, such as those involving interrupt handlers. To address this issue, CPSA prioritizes paths with infinite loops at the lowest level, allowing for interrupts to be raised and handled effectively. The Laelaps symbolic engine uses infinite-loop-elimination to avoid infinite loops during symbolic execution by comparing execution states and prioritizing paths with infinite loops at the lowest level. This allows interrupts to be raised and handled effectively, ensuring that new paths are selected based on similarity measurements between historical and future paths. After prioritizing paths with infinite loops at the lowest level, Laelaps selects new paths based on similarity measurements. If multiple paths remain, the one with the highest address is chosen. The algorithm moves forward quickly due to sequential program execution and firmware initialization of peripherals. However, the fall-back path heuristic may not always choose the optimal branches for exception handler decisions, as seen in a UART interrupt handler code snippet. After prioritizing paths with infinite loops at the lowest level, Laelaps selects new paths based on similarity measurements. If multiple paths remain, the one with the highest address is chosen. The algorithm moves forward quickly due to sequential program execution and firmware initialization of peripherals. When an exception is detected, Laelaps changes the fall-back path to the one with the lowest address to handle unexpected events. This design may result in additional code execution, but interrupt handlers can handle unexpected events gracefully. CPSA preserves symbols across branches by going through three bases to single out a branch within Forward_Depth steps. It eliminates infinite loops, scores paths based on similarity, and selects a fall-back path based on execution context. This fills gap 1 in Figure 1, supporting firmware sequential execution even with unimplemented peripherals. In addition to generating data for firmware, peripherals also notify firmware when data is ready through interrupts. Firmware waits in low-power mode and wakes up when receiving an interrupt request. To address this, a python interface periodically delivers activated interrupts, which works well as firmware only activates a limited number of interrupts. Interrupt handlers can gracefully deal with unexpected events without causing significant impact on firmware execution. Laelaps automatically reasons about expected peripheral inputs. Laelaps automatically reasons about expected peripheral inputs by intercepting input channels and feeding them with manually generated test-cases, ensuring that randomly generated data does not impact firmware execution. Laelaps hooks network functions in FreeRTOS to analyze TCP/IP stack vulnerabilities disclosed by Zimperium zLabs in Dec 2018. Embedded chips integrate hardware-accelerated units for cryptographic computation, influencing critical program logic. Laelaps preserves context information by staying in the symbolic engine for up to Context_Depth branches. In order to overcome limitations in symbolic execution, analysts can leverage interfaces to override solutions and prevent unwanted execution outcomes. Laelaps successfully runs complex firmware images with human inputs. The CPSA algorithm scans paths, eliminating those with infinite loops, ensuring efficient program execution. The symbolic engine can avoid infinite loops by utilizing information provided by analysts, such as assertion mechanisms in firmware. Analysts can also override path selection decisions by providing branching locations and expected outcomes. The Laelaps tool allows analysts to override branch selection and rewrite values in QEMU based on provided information. It integrates with QEMU and angr, enhancing Avatar's capabilities for dynamic analysis on Cortex-M devices. The proposed CPSA tool, Laelaps, developed on top of angr and QEMU, provides firmware analysts with an easy-to-use Python interface for emulating Cortex-M devices. It requires essential chip information such as core type, ROM/RAM mapping range, and firmware loading details. This information can be obtained from official product descriptions, forums, or FCC ID webpage. The firmware analysis tool Laelaps, built on angr and QEMU, assists in emulating Cortex-M devices. It requires chip details like core type and firmware loading methods, obtained from official sources. Some firmware may need additional analysis if it relies on a bootloader. Unknown memory accesses are handled by angr for symbolic execution, with a mechanism inherited from Avatar for remote memory emulation. Avatar forwards unmapped memory regions in QEMU to a Python script, which emulates real peripheral behavior and feeds the result back to QEMU. To symbolically execute firmware, angr requires processor status and memory contents. Laelaps cannot use the GDB interface for memory synchronization, so Avatar was modified to sync additional Cortex-M registers and implement a custom memory synchronization interface. The GDB interface is typically used by Avatar to sync memory, demonstrated by synchronizing a Firefox process state from QEMU to angr for continued symbolic execution. Laelaps addresses the issue of predicting program counters for unknown peripherals by exporting all RAM regions through IPC in QEMU. This allows angr to directly access firmware RAM for symbolic execution, outperforming Avatar in memory synchronization. Laelaps forwards peripheral inputs to QEMU and injects interrupts using QMP commands. This allows for memory synchronization without transferring modifications back to QEMU. The QMP interface is used to randomly inject activated interrupts to QEMU. The QMP command \"inject-irq\" emulates a hardware interrupt by setting the interrupt status pending register bit. However, in the initial implementation, QMP commands cannot be executed concurrently with I/O handling threads in QEMU due to locking issues. A workaround was implemented by adding a 100\u00b5s delay in each I/O loop. We implemented a workaround by adding a 100\u00b5s delay in each I/O loop to address locking issues in QEMU. Empirical evaluations were conducted using 30 firmware images from four ARM Cortex-M based development boards to demonstrate Laelaps' device-agnostic firmware emulation capabilities. Traces collected on real devices were used as a ground truth to evaluate the fidelity of firmware execution in Laelaps. In testing Laelaps' firmware emulation, various real-time operating systems and bare-metal firmware were evaluated for their compatibility with different peripherals. The firmware images included drivers for a wide range of peripherals, from basic sensors to complex network interfaces. The SDK samples were designed to test the performance of Laelaps with different firmware configurations. The SDK samples were designed to test different peripherals, with drivers working in polling or interrupt mode. Laelaps successfully emulated 20 out of 30 firmware images without human intervention. For three complex images, human intervention was needed, with two requiring data input. Laelaps successfully emulated 20 out of 30 firmware images without human intervention. Seven images could not be handled even with human efforts. Reasons for failed emulations include delays between reading peripheral registers and using the values, and reliance on custom peripherals for complex computations. Detailed information on each firmware image is available in the Appendix. In the Appendix, detailed information on firmware images is provided, including the main peripherals tested by each image and the necessary depths for successful emulations. The CPSA algorithm utilizes heuristic rules such as infinite-loop-elimination, similarity, and fall-back to select an optimal branch. Results for firmware images #12 and #22 demonstrate the effectiveness of these rules in decision making. The CPSA algorithm uses heuristic rules to select an optimal branch for firmware images #12 and #22. The proportion of each rule depends on the firmware image and Forward_Depth value. Increasing Forward_Depth leads to longer execution times, but snapshots can be saved for analysis later. Comparison between Laelaps and real devices was done to assess similarity in execution traces. The firmware execution trace was collected on a real NXP FRDM-K66F development board using the ETM component. Laelaps does not have the ETM, but QEMU provides a logging facility for transparently printing out execution traces. The execution trace was collected using QEMU with the option \"-d exec,nochain\" to print out firmware addresses before each translation block. The trace marks the end of system setup, RTOS initialization, and the start of the first task. A comparison between traces from Laelaps and a real device is visualized in Figure 4, showing the full system execution from power-on to the first task. The bitmap in Figure 4 represents instruction traces with low addresses at the top and high addresses at the bottom. The execution trace collected on Laelaps and a real device is compared in Figure 4. The traces show similar path coverage, reaching essential milestones during firmware execution. However, differences in execution paths can occur even with the same coverage. The emulation does not need to faithfully honor the real execution path. Coverage similarity is demonstrated in Figure 4. Jaccard index is used to measure common instructions between collected traces. Alignment is done to compare interrupts separately, and results are combined. Jaccard index values are shown in Table 3. After aligning and combining results, Jaccard indexes were calculated for different bootstrap phases. Laelaps showed high similarity with the real device when all heuristics were applied. However, enabling only heuristic 3 resulted in a failed boot of the firmware image. Positive results in firmware emulation led to further exploration of using Laelaps for dynamic analysis on embedded devices. The researchers developed Laelaps, a tool that leverages six live analysis heuristics to detect memory bugs on embedded devices. They used PANDA as a platform to implement these heuristics and validated their approach by transferring initialized memory states from a real device to PANDA. Laelaps was successfully ported to PANDA and tested with the same firmware image, demonstrating its device-agnostic property. The tool was also used for fuzzing experiments with positive results. The researchers conducted fuzzing experiments using Laelaps, configured to mimic the STM32 Nucleo-L152RE board. They used boofuzz to fuzz the firmware, reusing the UART peripheral emulator from a previous study. The firmware, based on Mbed OS, integrated the Expat library for parsing XML files and had five types of memory corruption vulnerabilities. Inputs from the UART interface were used to trigger these vulnerabilities during fuzzing. The experiment involved using a fuzzer to trigger memory corruption vulnerabilities with different probabilities. Results showed a linear relationship between probability and detection ratio. Less corrupting inputs allowed more test cases to be run in one hour. Laelaps was able to boot firmware for dynamic analysis without a real device, and was tested on FreeRTOS-powered firmware vulnerabilities in the FreeR-TOS+TCP network stack. In the experiment, vulnerabilities in the FreeRTOS+TCP network stack were identified and tested using a PANDA plugin to redirect memory read operations. Four TCP and IP layer vulnerabilities were triggered successfully. Laelaps integrates a symbolic execution engine to find software bugs, starting from interesting points with valid concrete contexts. A stack buffer overflow was manually injected into FreeRTOS, triggering an \"unconstrained\" state during symbolic execution. Symbolic execution is used to address security issues in firmware. Inception and S2E are two approaches that utilize symbolic execution for testing firmware. Inception builds a Symbolic Virtual Machine on top of KLEE to test firmware images, while S2E is a concolic testing platform based on full system emulation. FIE modifies KLEE for targeted testing. Our approach focuses on analyzing embedded USB devices using domain knowledge to speed up symbolic execution of firmware. It improves performance significantly compared to unconstrained symbolic execution. Unlike previous methods that require a real device for testing, our approach infers proper inputs from peripherals on-the-fly using symbolic execution. Our approach speeds up symbolic execution of firmware for embedded USB devices by inferring inputs from peripherals on-the-fly. A related work proposed learning interactions between hardware and firmware without needing a specific emulator for each target hardware. Previous work focused on analyzing Linux-based firmware but cannot work for embedded systems with mixed kernel and tasks. For embedded systems with mixed kernel and tasks, emulating binary execution is challenging. Forced execution techniques aim to discover different execution paths in binaries, extending to JavaScript code, mobile binaries, and kernel rootkits. However, this approach lacks fidelity in honoring intended control flow, leading to random results and high false positives in analysis. This limits its appeal when authentic execution context is needed. Our proposed approach, Laelaps, is a device-agnostic emulator for ARM microcontrollers that leverages concolic execution to generate proper peripheral inputs dynamically. By prioritizing the most promising path, we ensure high fidelity in the emulation environment. Unlike existing forced execution techniques, Laelaps addresses system-level events like privileged instructions and interrupts. A path selection algorithm based on heuristics helps identify the optimal branch for finding the right input. Our path selection algorithm, implemented on QEMU and angr, successfully boots 20 out of 30 firmware images without human intervention. Laelaps, tested with fuzzing and symbolic execution, identifies self-injected and real-world bugs. Future plans include extending support to ARM Cortex-A and MIPS devices. Transferring processor state from QEMU to angr reveals the PC register discrepancy. In the context of transferring processor state from QEMU to angr, the text discusses addressing the discrepancy in the PC register by injecting instructions into the intermediate language. The prototype extends the supported number of interrupts to 140 and implements bit-banding for efficient atomic access of memory bits. Angr's memory model is extended to support this feature, which is already present in QEMU. We extended the memory model of angr to support bit-banding for efficient atomic memory access. This enhancement has been utilized by Laelaps to successfully emulate STM32 devices. Angr's default implementation does not treat CBZ and CBNZ instructions as basic block terminators, leading to abnormal behaviors. By enabling strict basic blocks in angr, we ensure proper branch selection. Additionally, some STM32 boards rely heavily on memory aliasing during booting. The memory model of angr was extended to redirect memory accesses for STM32 boards that rely on memory aliasing during booting. Collected firmware images were analyzed, detailing peripherals and their functions. One firmware image sets up an RTC hardware block for triggering alarms, while another allows user-controlled voltage signal input for ADC16 conversion. Typing any key triggers the conversion, which is checked until completion before reading the result value. The example demonstrates various functions using STM32 boards, including timing delay with systick interrupt, setting power modes and wakeup sources, using DAC module, triggering periodic interrupts with PIT hardware block, sending characters to console instantly, generating PWM signal with TPM driver. The SDK TPM driver is used to generate a combined PWM signal. User selects an input channel for voltage signal capture. An internal 6-bit DAC generates a fixed voltage. EWM counter is refreshed until button press, generating an interrupt. CMT operates in Time mode to modulate 11-bit data. FTM sets up a 40000hz carrier generator signal. The FTM hardware block triggers an interrupt every 1 millisecond, displaying a message on the UART terminal. The LPTMR hardware block triggers a periodic interrupt every 1 second, toggling an LED on the board. The board LED can be flashed using a thread by pressing a button, and XML files can be read from UART using expat for parsing."
}