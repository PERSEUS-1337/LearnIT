{
    "title": "Syl8Sn0cK7",
    "content": "We propose a meta-learning framework for syntax-guided program synthesis, addressing challenges of complex structures in logical specifications and grammars. The framework includes an encoder, a grammar adaptive policy network, and a reinforcement learning algorithm. It is evaluated on 214 cryptographic circuit synthesis tasks. The meta-learning framework for syntax-guided program synthesis efficiently adapts to unseen tasks, achieving significant speedup. It outperforms a search-based approach without learning and is comparable to state-of-the-art classical synthesis engines. Program synthesis involves automatically generating programs to meet functional requirements in various domains. The program synthesizer, known as syntax-guided synthesis (SyGuS), takes a logical formula \u03c6 and a grammar G as input to produce a program in G that satisfies \u03c6. Various synthesizers based on discrete techniques have targeted the SyGuS formulation, but they lack bias towards likely programs, limiting their efficiency. Recent works have explored using neural networks for program synthesis, but they have limitations in targeting likely programs. Neural networks for program synthesis have limitations in targeting general SyGuS tasks, as they assume a fixed grammar and omit functional requirements. In contrast, the SyGuS formulation allows for varying grammars and specifying functional requirements more flexibly. The paper proposes a framework for general SyGuS tasks that can capture common patterns across different specifications and grammars. It addresses limitations of existing approaches by utilizing a joint graph representation of syntactic and semantic constraints and a grammar adaptive policy network. The paper introduces a meta-learning framework for the Syntax-Guided Synthesis (SyGuS) problem, focusing on synthesizing cryptographic circuits free of side-channel attacks. It includes a grammar adaptive policy network and reinforcement learning training method for transferable representation and policy learning. The framework is compared against existing solvers and demonstrated as a meta-solver adaptable to new tasks. The paper introduces a meta-learning framework for the Syntax-Guided Synthesis (SyGuS) problem, focusing on synthesizing cryptographic circuits free of side-channel attacks. It includes a grammar adaptive policy network and reinforcement learning training method for transferable representation and policy learning. The goal is to efficiently synthesize the function f by satisfying syntactic and semantic constraints. One example is cryptographic circuit synthesis, where the synthesized circuit must be equivalent to the original circuit while avoiding side-channel attacks. The proposed method is not limited to this specific problem and aims to address tasks efficiently given a dataset of N tasks. The paper introduces a meta-learning framework for the Syntax-Guided Synthesis (SyGuS) problem, focusing on synthesizing cryptographic circuits free of side-channel attacks. It includes a grammar adaptive policy network and reinforcement learning training method for transferable representation and policy learning. The goal is to efficiently synthesize the function f by satisfying syntactic and semantic constraints. The setting poses difficulties in learning due to the unavailability of the ground truth target function and the constraint verification process. A reinforcement learning algorithm is formulated to address these challenges. Each task in the dataset is independent with different constraints, requiring a well-designed meta-learner for success. The paper introduces a meta-learning framework for the Syntax-Guided Synthesis (SyGuS) problem, focusing on synthesizing cryptographic circuits free of side-channel attacks. It includes a grammar adaptive policy network and reinforcement learning training method for transferable representation and policy learning. The goal is to efficiently synthesize the function f by satisfying syntactic and semantic constraints. The key to success lies in the design of the meta-learner, which is elaborated in Section 3. The meta-solver model is presented for solving the two problems formulated in Section 2, with a focus on transferring knowledge across tasks with different constraints. The Grammar Adaptive Policy Network is introduced to execute a program generation policy while adapting to different grammars encoded in each task specification. Key concepts in the SyGuS problem formulation, such as the semantic spec \u03c6, are formally defined. The grammar in spec \u03c6 differs from grammar G for the output program. Tokens may be shared between input spec and output program. V represents nonterminal tokens, \u03a3 represents terminal tokens, and s denotes the start of the language. Production rules in R define how the language is generated. The output function f generates a program satisfying syntactic and semantic constraints. In program generation, the output function f must meet syntactic and semantic constraints specified by \u03c6 and G. Each task has its own grammar and semantic requirements, requiring task-specific representations. Graphs are used to capture the rich structural information of programs, enabling generalization across different grammars. In program generation, the output function must adhere to syntactic and semantic constraints specified by \u03c6 and G. The approach extends BID2 by representing the semantic spec program \u03c6 and grammar G jointly in graphs. Information exchange between the two graphs is facilitated using Static Single Assignment (SSA) form. Global nodes for shared tokens and global links connecting these nodes and local nodes are introduced to construct the graph. The abstract syntax tree (AST) for the semantic spec program \u03c6 is built according to its grammar to create the graph representation framework. In program generation, the joint graph G(\u03c6, G) is encoded using graph neural networks to represent each node. Message passing style is used for information exchange between syntactic and semantic specifications. Global nodes for shared tokens link variable and operator nodes, enabling grammar adaptive program generation. For each node in the graph G, message passing style update is done using a parameterization. Node embeddings and global graph embeddings are obtained, along with embedding matrices for non-terminal nodes to enable grammar adaptive tree expansion. Different matrices are used for different edge types and propagation steps. This approach allows the meta-solver to generalize across different tasks. The meta-solver enables generalization across tasks by sharing task representation and program generation policy. Task conditional program generation is implemented using tree recursive generation in DFS order. A grammar adaptive policy network is proposed to handle different grammars in each task, parameterized by decision embedding. This mechanism is inspired by pointer networks and graph algorithm learning. The embedding matrix H \u03b1t is used for decision-making in each time step, obtained as described in Sec 3.2. The policy network is built in an auto-regressive way, with the probability of each action defined as \u03c0(a t |h(G), DISPLAYFORM2. In a reinforcement learning framework for the meta-solver, a policy network generates actions to expand non-terminals in a sequence until completion. The SAT solver is then invoked to return a binary flag. The parameters of the graph embedding and adaptive policy network are denoted as \u03b8, with the policy \u03c0 \u03b8 (f |\u03c6, G) generating f such that \u03c6 \u2261 f. In a reinforcement learning framework, the SAT solver returns a binary flag indicating if the task is complete. To smooth the reward, a test case buffer is maintained for each specification \u03c6. If f passes, a full reward is given, otherwise, a counter-example is generated. Interpolated examples around the counter-example are sampled, and the reward is based on the fraction of examples where f matches the output. The buffer is updated at the end of each episode for future use. In the meta-learning setting, the framework utilizes the Advantage Actor-Critic (A2C) for model training. A minibatch of instances is sampled from the training set D for each epoch, and the model performs a complete rollout using policy \u03c0 \u03b8 (f |\u03c6 i , G i ). The actor-critic method computes gradients w.r.t to \u03b8 of each instance, with \u03b3 as the discounting factor and V (s t ; \u03c9) as a state value estimator. This is implemented as a standard MLP with scalar output. Our framework utilizes a standard MLP with scalar output to fit the expected return. Gradients from each instance are averaged over a minibatch before applying to the parameter. The framework is evaluated on cryptographic circuit synthesis tasks from the 2017 SyGuS competition, which includes a challenging benchmark suite. The framework is tested on cryptographic circuit synthesis tasks with varying logical specifications and timing constraints, serving as a challenging testbed for representation learning. Experiments are conducted in two learning settings, testing the framework's ability to generalize to unseen specifications and grammars. The framework is tested on cryptographic circuit synthesis tasks with varying logical specifications and timing constraints. The model is evaluated in two learning settings to demonstrate its capacity in representation and policy learning. The test-on-train setting allows the model to solve one instance at a time without overfitting, while the meta-solver setting shows the model's ability to generalize to new tasks. The framework is compared to classical solvers in the formal methods community. The framework is compared to classical solvers in the formal methods community, including CVC4, ESymbolic, and Out-ofBox Solver. The maximum time in solving instances and average/median times are also provided. The framework can learn a transferable representation and policy for efficient adaptation to new tasks. ESymbolic is a generalization of EUSolver, replacing domain-specific heuristics with 2QBF for satisfiability checks. All solvers were run on the same platform with a single core CPU, measuring performance by the number of instances solved within a 6-hour limit. CVC4 has been actively improved for over a decade, redesigned and re-implemented in C++. Our framework, a proof-of-concept prototype implemented in Python, has not been tuned for running time performance like EUSolver. While EUSolver outperforms our framework in the number of solved instances due to specialized heuristics, our framework solves 4 instances that EUSolver fails to solve. Additionally, our framework complements the state-of-the-art solvers like CVC4 by solving instances that they cannot. Our framework outperforms the state-of-the-art CVC4 solver in solving difficult instances with better efficiency. It shows superior scalability compared to EUSolver, which relies on manually designed heuristics. Our framework learns to solve hard instances from scratch without requiring training data. The meta-solver learns to solve circuits synthesis tasks without training data. It is trained on 150 tasks for 35000 epochs and tested on 64 tasks. The model is finetuned on each task in the testing set to synthesize a correct program. Comparisons are made with an out-of-box solver on the test set tasks. The meta-solver significantly improves performance in solving tasks in the test set, solving 37 out of 64 tasks compared to the out-of-box solver's 36. It reduces the number of explored candidates by 4x on average for 40% of tasks, leading to a speedup distribution of at least 2x for most benchmarks. The meta-solver achieves significant speedup for most benchmarks, including orders of magnitude improvement for 10 out of 36 unseen tasks and solving one previously unsolvable task. Various techniques in symbolic program synthesis, neural program synthesis, and neural induction have been explored to automatically synthesize programs from specifications. Several approaches have been proposed to accelerate program solvers by modeling syntactic aspects, such as PHOG, log-bilinear tree-traversal models, and graph-based statistical models. Neural networks have also been used in works like DeepCoder, Bayou, and RobustFill for program synthesis. These approaches struggle with symbolic constraints and focus on avoiding overfitting, coping with few examples, and handling noisy examples. Our work relaxes specifications for general SyGuS formulation, focusing on learning programs with similar grammars. Unlike other approaches using neural networks as computational substrates, we propose integrating a neural learner with symbolic methods for program induction. Our framework integrates a neural learner with a symbolic verifier for scalability and correctness guarantees in program synthesis. It can handle tasks with varying grammar and weak supervision, utilizing a graph neural network, grammar adaptive network, and meta-learning method. Our framework, based on the Advantage Actor-Critic (A2C) framework, outperforms baseline and classical synthesis engines in solving tasks. It solves 141 out of 214 tasks, surpassing ESymbolic by 110. When trained as a meta-solver, it accelerates the solving process by 2\u00d7 to 100\u00d7, outperforming state-of-the-art solvers CVC4 and EUSolver on some tasks."
}