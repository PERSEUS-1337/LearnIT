{
    "title": "rkG3QTnQcN",
    "content": "Significant work has been done on communicating reasons for decision-making in automated scheduling systems, but less focus has been on explaining why systems can't find a solution when over-constrained. The agent resource-constrained project scheduling problem (ARCPSP) is introduced, which deals with agents executing tasks in parallel. A framework based on enumerating minimal unsatisfiable sets (MUS) and maximal satisfiable sets (MSS) is outlined to identify infeasibility sources and suggest potential fixes. The method can be applied to the ARCPSP to generate various explanations for an over-constrained situation. Automated planning and scheduling systems assist human users in developing plans. NASA mission planning involves human planners using automated scheduling systems to create daily and long-term plans for crew members. These systems generate plans while ensuring constraints are met. It is crucial for both planners and crew members to understand the reasoning behind scheduling decisions made by automated tools. Transparency in how these decisions are reached is essential when supporting human decision-making. Significant work has been done to provide human-understandable explanations for automated planning decisions. However, little work has been dedicated to explaining why plans or schedules cannot be generated under certain specifications. Human users may encounter infeasible configurations when using constraint satisfaction or optimization tools, making it challenging for them to fix these issues without understanding the solver's reasoning. Existing solutions for over-constrained problems have limitations that restrict their applicability in real-life scenarios. In this paper, a framework is proposed for generating human-understandable explanations of infeasibility in scheduling problems. These explanations consist of minimal sets of constraints causing infeasibility, along with suggestions for relaxations to achieve feasibility. Users can iterate over these explanations to make high-level decisions on solving infeasibility. The paper presents a system for explaining infeasible instances of problems by enumerating explanations at different levels of abstraction. It allows users to ask directed questions about feasibility and utilizes a strategy for generating minimal unsatisfiable sets (MUS) and maximal satisfiable sets (MSS) to interpret infeasibility. Existing methods focus on generating a single explanation, but this system aims to provide multiple explanations for overconstrained problems. The paper introduces a system for explaining infeasible instances of problems by generating multiple minimal unsatisfiable sets (MUS) to highlight various feasibility issues. It utilizes an enumeration strategy based on MARCO BID8 algorithm and focuses on the agent resource-constrained project scheduling problem (ARCPSP), which deals with asymmetric agents and task delegation. The paper introduces a system for explaining infeasible instances of problems by generating multiple minimal unsatisfiable sets (MUS) to highlight various feasibility issues in the agent resource-constrained project scheduling problem (ARCPSP). It provides a formal definition of ARCPSP, outlines a difference logic encoding for checking feasibility, and describes a framework for generating human-understandable explanations of infeasibility. The approach outlined in the paper can be adapted for different types of constraint satisfaction and optimization tools, planning, and scheduling problems. In Section 5, the paper discusses the trade-off between interpretability and expressibility of explanations. It introduces background information on satisfiability modulo theory and using sets to explain infeasibility in the ARCPSP problem. The formula \u03d5 is satisfiable if variables in X can make it TRUE, otherwise, it is unsatisfiable. The paper discusses implementing temporal constraints using difference logic (DL) for the agent resource-constrained project scheduling problem (ARCPSP). The Microsoft Z3 SMT solver is used to check satisfiability, with DL being more efficient than linear real arithmetic (LRA) methods. Bounds and atoms in DL are discussed for efficient problem solving. The paper discusses implementing temporal constraints using difference logic (DL) for the agent resource-constrained project scheduling problem (ARCPSP). Bounds x \u2264 k can be written as x \u2212 x 0 \u2264 k where x 0 is later set to zero. A minimal unsatisfiable set (MUS) is an unsatisfiable subset of constraints, while a maximal satisfiable set (MSS) is a satisfiable subset. A minimal correction set (MCS) is the complement of a maximal satisfiable set, representing constraints to be removed for satisfiability. MUSes, MSSes, and MCSes are locally maximal or minimal subsets, different from globally optimal subsets. A minimal unsatisfiable set (MUS) is an isolated subset of constraints where removing any single constraint would make the set satisfiable. To ensure feasibility of the entire set, a hitting set of MUSes must be removed, with every MCS being a combination of such a hitting set. Background constraints are hard constraints that must be satisfied, while the foreground includes the rest of the constraints in the set. A minimal conflict or relaxation in an over-constrained set of constraints with a background B is a subset of the foreground M \u2282 C \\ B that is unsatisfiable or satisfiable, respectively. Explanations consist of sequences of minimal conflicts and relaxations, incorporating a background of unmodifiable constraints. The problem formulated in the curr_chunk is an extension of the resource-constrained project scheduling problem (RCPSP), which includes a set number of agents executing tasks in parallel with compatibility constraints. This extends the RCPSP by introducing specific start and end times for each task. In an agent resource-constrained project scheduling problem (ARCPSP), the focus is on the feasibility of completing all tasks within specified time frames. The problem involves defining time ranges for task execution, task durations, compatibility sets, precedence relations, and agent resources. In an ARCPSP, tasks have defined resource demands and availability constraints. A feasible schedule must ensure no overlapping tasks, tasks within allowable time frames, compatible agent assignments, met precedence relations, and satisfied resource constraints. The resource constraints in an ARCPSP can be formulated using difference logic. Tasks are represented as sets being executed at specific times, and agents as integers. For mutually exclusive constraints, tasks sharing a resource cannot be executed simultaneously. Non-mutually exclusive constraints can be handled using minimal forbidden sets. Minimal forbidden sets, introduced by BID9, are unsatisfiable sets due to resource constraints. They consist of tasks that cannot be scheduled simultaneously without exceeding resource availability. A key feature is that a single task can be rescheduled to meet the constraint. Encoding this constraint involves ensuring that tasks in the set cannot all be executing at the same time. This method is similar to encoding the RCPSP with linear arithmetic, but it requires discretizing time and can be cumbersome with a large number of time-points. Additionally, the constraint cannot easily be formulated in terms of difference logic. Minimal forbidden sets are introduced to handle resource constraints in scheduling tasks. These sets consist of tasks that cannot be scheduled simultaneously without exceeding resource availability. The constraint can be reformulated as ensuring that at least two tasks in a set do not overlap at any time-point. This method is efficient in preventing resource conflicts in the context of the ARCPSP compared to other methods like linear arithmetic. The computational advantage of using difference logic over other methods is highlighted. Minimal forbidden sets are used to represent resource constraints in scheduling tasks efficiently. This method ensures that tasks violating resource constraints are identified as subsets that cannot be scheduled simultaneously. For example, in scheduling astronauts aboard the ISS, resource constraints are represented as minimal forbidden sets of tasks that cannot be scheduled together. The crew members are represented by elements of M = {M 1 , M 2 , \u00b7 \u00b7 \u00b7 , M m }. In the case of 6 astronauts, task execution bounds are from minute 120 to 840. The power resource availability is 1000 units. Tasks include 6 laboratory tasks with duration 120 and precedence constraints. Each laboratory task requires 400 units of power. Additionally, there are m weights and m treadmill tasks, each with a duration of 75 and unique completion requirements. The crew members are represented by elements of M = {M 1 , M 2 , \u00b7 \u00b7 \u00b7 , M m }. Tasks include weights, treadmill, meal, and miscellaneous tasks with specific time ranges and completion requirements for astronauts. Reusable resources R W and R T are defined with availability B W , B T = 1. Meal tasks have time ranges of (420, 540) and miscellaneous tasks have a time range of (120, 840) and can be completed by any astronaut. The tasks in the ARCPSP have specific power requirements and time ranges. A modification to the duration of tasks can lead to an unsolvable problem instance. The strategy for enumerating subsets is based on MARCO over other systems like CAMUS, focusing on quickly outputting MUSes. MARCO relies on four main functions to explore the feasibility of constraints. The algorithm for exploring constraints in the ARCPSP involves functions like BlockUp, BlockDown, Grow, and Shrink. A power set lattice of Boolean variables is maintained to check the satisfiability of sets. Constraints are iteratively added or removed based on satisfiability. The ARCPSP algorithm involves functions like BlockUp, BlockDown, Grow, and Shrink to explore constraints. Constraints are iteratively added or removed based on satisfiability. If the initial set is SAT, constraints are added until a minimal relaxation is found. If UNSAT, constraints are removed until a minimal conflict is found. BlockUp removes supersets of conflicts, while BlockDown removes subsets of relaxations. The subset enumeration algorithm explores constraints in a boolean lattice by generating new satisfying assignments and conflicts. Starting with an unsatisfiable conjunction of clauses, the algorithm iterates through shrinking, blocking up, and growing sets to find minimal conflicts and relaxations. The subset enumeration algorithm explores constraints in a boolean lattice by generating new satisfying assignments and conflicts. Starting with an unsatisfiable conjunction of clauses, the algorithm iterates through shrinking, blocking up, and growing sets to find minimal conflicts and relaxations. A new seed {C 3 } leads to a SAT set {C 3 , C 4 }, which is then blocked down to subsets {C 4 }, {C 3 }, {\u2205}. The output is {C 1 }, the complement of {C 3 , C 4 }. The lattice is entirely blocked off, resulting in a single conflict and relaxation. New variables S 0 and S m+1 mark the schedule bounds, preventing relaxation of temporal constraints outside the feasible schedule bounds. The algorithm explores constraints in a boolean lattice to find minimal conflicts and relaxations. Constraints like timeframe, compatibility, precedence, and resource are considered in the process. The method can be applied to individual constraints and sets of tasks. The schedule bounds are marked by new variables to prevent relaxation of temporal constraints outside feasible bounds. The algorithm explores constraints like timeframe, compatibility, precedence, and resource in a boolean lattice to find minimal conflicts and relaxations for each task in the schedule. The constraints are formatted as tuples of relevant tasks and constraint types. The full constraint explanation for Example 2 includes 14 minimal relaxations and 3 minimal conflicts. The full constraint explanation for Example 2 includes 14 minimal relaxations and 3 minimal conflicts. The omitted conflicts and relaxations are practically redundant. Computing the minimal forbidden sets took 2.11 seconds, while calculating the full explanation took 1.57 seconds. Relaxations suggest minimal changes to fix the schedule, while conflicts explain infeasibility reasons. For instance, removing the precedence between laboratory tasks 3 and 4 would make the schedule feasible, but conflicts show that all laboratory tasks' precedence does not fit the schedule. This information helps users adjust schedule parameters instead of voiding entire tasks. The explanation in the curr_chunk focuses on altering schedule parameters to address infeasibility in an ARCPSP problem. It suggests extending or shortening task durations to resolve conflicts. The text also mentions using subset enumeration algorithms to generate higher-level descriptions of infeasibility. The curr_chunk discusses using subset enumeration algorithms to create logical relationships between symbolic variables and constraints, enabling the generation of explanations for infeasibility. This involves pushing constraints to the background and populating the foreground with Boolean variables, which are then enumerated over. The size of the Boolean lattice depends on the constraints in the foreground. By replacing the foreground with Boolean variables representing tasks, explanations for infeasibility can be generated efficiently. Constraints are classified as individual or relational, with individual constraints involving single tasks and relational constraints involving multiple tasks. This approach reduces redundancies and produces compact descriptions of infeasibility. The constraints in the model involve single or multiple tasks, with individual constraints related to single tasks and relational constraints related to multiple tasks. Each task's Boolean variable implies the truth of its individual constraints, and all associated tasks' Boolean variables must be true for relational constraints to be satisfied. By toggling Boolean variables, the constraint lattice is constrained accordingly, allowing for efficient enumeration over task subsets. Executing the enumeration algorithm on a modified foreground for an overconstrained problem produced a set of conflicts and relaxations. The full explanation included 3 minimal relaxations and 17 minimal conflicts, taking 4.03 seconds to compute forbidden sets and 0.55 seconds for the full explanation. Task explanations are often more concise than constraint explanations due to variables representing multiple constraints, leading to fewer conflicts and relaxations. Task explanations offer straightforward explanations for over-constrained problems but lack the detail of constraint explanations. The constraint explanations help diagnose issues related to task precedence, while task explanations sacrifice detail for interpretability. By replacing the foreground with human-written specifications, redundancy in conflicts and relaxations is reduced. Tasks with similar scheduling specifications can be grouped together for more succinct expression. Specifications for tasks can be more succinctly expressed by utilizing similarities, such as meal tasks between 1pm and 2pm, lab tasks in sequence, and power constraints. Logical relationships can be drawn from these parameters. The specifications for tasks can be expressed more succinctly by utilizing similarities, such as meal tasks between 1pm and 2pm, lab tasks in sequence, and power constraints. Logical relationships can be drawn from these parameters to generate specification explanations with reduced size and fewer conflicts. The agent resource-constrained project scheduling problem (ARCPSP) introduces a trade-off between expressibility and interpretability of explanations. Low-level explanations provide detailed reasons for infeasibility but may be hard to understand, while high-level specification explanations offer more direct information but lack granularity. The ARCPSP is associated with a difference logic encoding. The paper proposes a framework for generating minimal conflicts and relaxations for the agent resource-constrained project scheduling problem (ARCPSP) using the MARCO algorithm. This framework can be applied to various scheduling and planning problems, with potential extensions to other formal languages like linear temporal logic. It suggests real-time generation of explanations for infeasibility in interactive scheduling software, allowing users to understand reasons for infeasibility and the impact of modifications on schedule feasibility. The paper proposes a framework for generating minimal conflicts and relaxations for the agent resource-constrained project scheduling problem (ARCPSP) using the MARCO algorithm. It suggests real-time generation of explanations for infeasibility in interactive scheduling software, allowing users to understand reasons for infeasibility and the impact of modifications on schedule feasibility. Investigating methods for synthesizing natural language sentences out of the explanations is also subject to future research. A preferential ordering of explanations may be achieved by adding and removing constraints during the Grow and Shrink steps based on the constraint preference ordering. Methods for enumerating disjoint conflicts may also be useful for producing a representative set of conflicts concisely. The most limiting bottleneck for scaling to larger problem instances in agent resource-constrained project scheduling is the exponential growth of minimal forbidden sets with the number of tasks. Lazy clause generation algorithms can efficiently represent resource constraints and adapt to implement consumable resources in an explainability setting."
}