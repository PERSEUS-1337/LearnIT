{
    "title": "Hkgs3aNYDS",
    "content": "The Expectation-Maximization (EM) algorithm is a fundamental tool in unsupervised machine learning. It is often used as an efficient way to solve Maximum Likelihood (ML) and Maximum A Posteriori estimation problems, especially for models with latent variables. It is also the algorithm of choice to fit mixture models: generative models that represent unlabelled points originating from $k$ different processes, as samples from $k$ multivariate distributions. In this work we define and use a quantum version of EM to fit a Gaussian Mixture Model. Given quantum access to a dataset of $n$ vectors of dimension $d$, our algorithm has convergence and precision guarantees similar to the classical algorithm, but the runtime is only polylogarithmic in the number of elements in the training set, and is polynomial in other parameters - as the dimension of the feature space, and the number of components in the mixture. We generalize further the algorithm by fitting any mixture model of base distributions in the exponential family. We discuss the performance of the algorithm on datasets that are expected to be classified successfully by those algorithms, arguing that on those cases we can give strong guarantees on the runtime. Over the last few years, the effort to find real world applications of quantum computers has greatly intensified. Along with chemistry, material sciences, finance, one of the fields where quantum computers are expected to be most beneficial is machine learning. A number of different algorithms have been proposed for quantum machine learning (Biamonte et al., 2017; Wiebe et al., 2017; Kerenidis & Prakash, 2018; Harrow et al., 2009; Suba\u015f\u0131 et al., 2019; Farhi & Neven, 2018) , both for the supervised and unsupervised setting, and despite the lack of large-scale quantum computers and quantum memory devises, some quantum algorithms have been demonstrated in proof-of-principle experiments (Li et al., 2015; Otterbach et al., 2017; Jiang et al., 2019) . Here, we look at Expectation-Maximization (EM), a fundamental algorithm in unsupervised learning, that can be used to fit different mixture models and give maximum likelihood estimates with the so-called latent variable models. Such generative models are one of the most promising approaches for unsupervised problems. The goal of a generative model is to learn a probability distribution that is most likely to have generated the data collected in a training set V \u2208 R n\u00d7d of n vectors of d features. Fitting the model consists in learning the parameters of a probability distribution p in a certain parameterized family that best describes our vectors v i . We will see that, thanks to this formulation, we can reduce a statistical problem into an optimization problem using maximum likelihood estimation (ML) estimation. The likelihood is the function that we use to measure how good a model is for explaining a given dataset. For a given machine learning model with parameters \u03b3, the likelihood of our data set V is the probability that the data have been generated by the model with parameters \u03b3, assuming each point is independent and identically distributed. We think the likelihood as a function of \u03b3, holding the dataset V fixed. For p(v i |\u03b3) the probability that a point v i comes from model \u03b3, the likelihood is defined as L(\u03b3; V ) := n i=1 p(v i |\u03b3). From this formula, we can see that in order to find the best parameters \u03b3 * of our model we need to solve an optimization problem. For numerical and analytical reasons, instead of maximizing the likelihood L, it is common practice to find the best model by maximizing the log-likelihood function (\u03b3; V ) = log L(\u03b3; V ) = n i=1 log p(v i |\u03b3). In this context, we want to find the model that maximizes the log-likelihood: \u03b3 * M L := arg max \u03b3 n i=1 log p(v i |\u03b3). The procedure to calculate the log-likelihood depends on the specific model under consideration. A possible solution would be to use a gradient based optimization algorithm on . Unfortunately, due to the indented landscape of the function, gradient based techniques often do not perform well. Therefore, it is common to solve the maximum likelihood estimation (or maximum a priori) problem using the Expectation-Maximization (EM) algorithm. EM is an iterative algorithm which is guaranteed to converge to a (local) optimum of the likelihood. This algorithm has a striking variety of applications, and has been successfully used for medical imaging (Balafar et al., 2010) , image restoration (Lagendijk et al., 1990) , problems in computational biology (Fan et al., 2010) , and so on. EM has been proposed in different works by different authors, but has been formalized as we know it only in 1977 (Dempster et al., 1977) . For more details, we refer to (Lindsay, 1995; Bilmes et al., 1998) . In this work, we introduce Quantum Expectation-Maximization (QEM), a new algorithm for fitting mixture models. We detail its usage in the context of Gaussian Mixture Models, and we extend the result to other distributions in the exponential family. We also generalize the result by showing how to compute the MAP: the Maximum A Posteriori estimate of a mixture model. MAP estimates can be seen as the Bayesian version of maximum likelihood estimation problems. MAP estimates are often preferred over ML estimates, due to a reduced propensity to overfit. Our main result can be stated as: Result (Quantum Expectation-Maximization). (see Theorem 3.9) For a data matrix V \u2208 R n\u00d7d stored in an appropriate QRAM data structure and for parameters \u03b4 \u03b8 , \u03b4 \u00b5 > 0 , Quantum Expectation-Maximization (QEM) fits a Maximum Likelihood (or a Maximum A Posteriori) estimate of a Gaussian Mixture Model with k components, in running time per iteration which is dominated by: where \u03a3 is a covariance matrix of a Gaussian distribution, \u03b7 is a parameter of the dataset related to the maximum norm of the vectors, \u03b4 \u03b8 , \u03b4 \u00b5 are error parameters in the QEM algorithm, \u00b5(< \u221a d) is a factor appearing in quantum linear algebra and \u03ba is the condition number of a matrix. Here we only kept the term in the running time that dominates for the range of parameters of interest. In Theorem 3.9 we explicate the running time of each step of the algorithm. The QEM algorithm runs for a number of iterations until a stopping condition is met (defined by a parameter \u03c4 > 0) which implies a convergence to a (local) optimum. Let's have a first high-level comparison of this result with the standard classical algorithms. The runtime of a single iteration in the standard implementation of the EM algorithm is at least O(knd 2 ) (Pedregosa et al., 2011; Murphy, 2012) . The advantage of the quantum algorithm is an exponential improvement with respect to the number of elements in the training set, albeit with a worsening on other parameters. It is crucial to find datasets where such a quantum algorithm can offer a speedup. For a reasonable range of parameters ( d = 40, k = 10, \u03b7 = 10, \u03b4 = 0.5, \u03ba(V ) = 25, \u03ba(\u03a3) = 5, \u00b5(\u03a3) = 4) which is motivated by some experimental evidence reported in Section 4, datasets where the number of samples in the order of O(10 12 ) might be processed faster on a quantum computer. One should expect that some of the parameters of the quantum algorithm can be improved, especially the dependence on the condition numbers and the errors, which can make enlarge the type of datasets where QEM can offer an advantage. Note that we expect the number of iterations of the quantum algorithm to be proportional to the number of iteration of the classical case. This is to be expected since the convergence rate does not change, and it is corroborated by previous experimental evidence in a similar scenario: the number of iterations needed by q-means algorithm for convergence, is proportional to the number of iterations of the classical k-means algorithm (Kerenidis et al., 2018) . Expectation-Maximization is widely used for fitting mixture models in machine learning (Murphy, 2012) . Most mixture models use a base distribution in the exponential family: Poisson (Church & Gale, 1995 ), Binomial, Multinomial, log-normal (Dexter & Tanner, 1972 ), exponential (Ghitany et al., 1994 , Dirichlet multinomial (Yin & Wang, 2014) , and others. EM is also used to fit mixtures of experts, mixtures of the student T distribution (which does not belong to the exponential family, and can be fitted with EM using (Liu & Rubin, 1995) ) and for factor analysis, probit regression, and learning Hidden Markov Models (Murphy, 2012). There is a fair amount of quantum algorithms that have been proposed in the context of unsupervised learning. (A\u00efmeur et al., 2013; Lloyd et al., 2013b; Otterbach et al., 2017) . Recently, classical machine learning algorithms were obtained by \"dequantizing\" quantum machine learning algorithms (Tang, 2018b; a; c; Gily\u00e9n et al., 2018a; Chia et al., 2018) . The runtime of these classical algorithm is poly-logarithmic in the dimensions of the dataset. However, the polynomial dependence on the rank, the error, and the condition number, make these new algorithms impractical on interesting datasets, as shown experimentally by (Arrazola et al., 2019) . Fast classical algorithm for GMM exists, albeit assuming only one shared covariance matrix (Dasgupta, 1999) , and without a polylogarithmic dependence in the number of elements in the training set. Independently of us, Miyahara, Aihara, and Lechner extended the q-means algorithm (Kerenidis et al., 2018) for Gaussian Mixture Models (Miyahara et al., 2019) , using similar techniques. The main difference is that in their work the update step is performed using a hard-clustering approach (as in the k-means algorithm), that is for updating the centroid and the covariance matrices of a cluster j, only the data points for which cluster j is nearest are taken into account. In our work, we use the soft clustering approach (as in the classical EM algorithm), that is for updating the centroid and the covariance matrices of cluster j, all the data points weighted by their responsibility for cluster j are taken into account. Both approaches have merits and can offer advantages (Kearns et al., 1998) . As is common in machine learning literature, we introduce the Expectation-Maximization algorithm by using it to fit Gaussian Mixture Models (GMM). Mixture models are a popular generative model in machine learning. The intuition behind mixture models is to model complicated distributions by using a group of simpler (usually uni-modal) distributions. In this setting, the purpose of the learner is to model the data by fitting the joint probability distribution which most likely have generated our samples. In this section we describe GMM: probably the most used mixture model used to solve unsupervised classification problems. In fact, given a sufficiently large number of mixture components, it is possible to approximate any density defined in R d (Murphy, 2012) . In unsupervised settings, we are given a training set of unlabeled vectors v 1 \u00b7 \u00b7 \u00b7 v n \u2208 R d which we represent as rows of a matrix V \u2208 R n\u00d7d . Let y i \u2208 [k] one of the k possible labels for a point v i . We posit that the joint probability distribution of the data p(v i , y i ) = p(v i |y i )p(y i ), is defined as follow: The \u03b8 j are the mixing weights, i.e. the probabilities that y i = j, and N (\u00b5 j , \u03a3 j ) is the Gaussian distribution centered in \u00b5 j \u2208 R d with covariance matrix \u03a3 j \u2208 R d\u00d7d . Note that the variables y i are unobserved, and thus are called latent variables. There is a simple interpretation for this model. We assume the data is created by first selecting an index j \u2208 [k] by sampling according to Multinomial(\u03b8), and then a vector v i is sampled from N (\u00b5 j , \u03a3 j ). Fitting a GMM to a dataset reduces to finding an assignment for the parameters: that best maximize the log-likelihood for a given dataset. Note that the algorithm used to fit GMM can return a local minimum which might be different than \u03b3 * : the model that represents the global optimum of the likelihood function. We use the letter \u03c6 to represent our base distribution, which in this case is the probability density function of a multivariate Gaussian distribution N (\u00b5, \u03a3). Using this formulation, a GMM is expressed as: p(v) = k j=1 \u03b8 j \u03c6(v; \u00b5 j , \u03a3 j ) where \u03b8 j are the mixing weights of the multinomial distribution such that k j=1 \u03b8 j = 1. The probability for an observation v i to be assigned to the component j is given by: . This value is called responsibility, and corresponds to the posterior probability of the sample i being assigned label j by the current model. As anticipated, to find the best parameters of our generative model, we maximize the log-likelihood of the data. For GMM, the likelihood is given by the following formula (Ng, 2012) Alas, it is seldom possible to solve maximum likelihood estimation analytically (i.e. by finding the zeroes of the derivatives of the log-like function, and this is one of those cases. Fortunately, Expectation-Maximization is an iterative algorithm that solves numerically the optimization problem of ML estimation. To complicate things, the likelihood function for GMM is not convex, and thus we might find some local minima (Hastie et al., 2009 ). If we were to know the latent variable y i , then the log-likelihood for GMM would be: This formula can be easily maximized with respect to the parameters \u03b8, \u00b5, and \u03a3. In the Expectation step we calculate the missing variables y i 's, given a guess of the parameters (\u03b8, \u00b5, \u03a3) of the model. Then, in the Maximization step, we use the estimate of the latent variables obtained in the Expectation step to update the estimate of the parameters. While in the Expectation step we calculate a lower bound on the likelihood, in the Maximization step we maximize it. Since at each iteration the likelihood can only increase, the algorithm is guaranteed to converge, albeit possibly to a local optimum (see (Hastie et al., 2009 ) for the proof). During the Expectation step all the responsibilities are calculated, while in the Maximization step we update our estimate on the parameters \u03b3 t+1 = (\u03b8 t+1 , \u00b5 t+1 , \u03a3 t+1 ). The stopping criterion for GMM is usually a threshold on the increment of the log-likelihood: if the log-likelihood changes less than a threshold between two iterations, then the algorithm stops. Notice that, since the value of the log-likelihood significantly depends on the amount of data points in the training sets, it is often preferable to adopt a scale-free stopping criterion, which does not depend on the number of samples. For instance, in the toolkit scikit-learn (Pedregosa et al., 2011 ) the stopping criterion is given by a tolerance on the average increment of the log-probability, which is chosen to be smaller than a certain \u03c4 , say 10 \u22123 . More precisely, the stopping criterion is |E[log p(v i ; \u03b3 Dataset assumptions in GMM As in q-means (Kerenidis et al., 2018) , we have an assumption on the dataset that all elements of the mixture contribute proportionally to the total responsibility: i, e This is equivalent to requiring that clusters share a comparable amount of points in the \"well-clusterability\" assumption in q-means (Kerenidis et al., 2018) . It is also equivalent to assuming that \u03b8 j /\u03b8 l = \u0398(1) \u2200j, l \u2208 [k]. For convenience, in this work, we also assume that the dataset is normalized such that the shortest vector has norm 1 and define \u03b7 := max i v i 2 to be the maximum norm squared of a vector in the dataset. This is not a necessary requirement for our dataset, but it will simplify the analysis of our algorithm, allowing us to give strict bounds on the runtime. Preliminaries We assume a basic understanding of quantum computing, we recommend Nielsen and Chuang (Nielsen & Chuang, 2002) where \u03c3 is the smallest singular value which is greater than \u03c4 . With nnz(V ) we mean the number of non-zero elements of the rows of V . When we say \u03ba(V ) we mean the condition number of the matrix V , that is the ratio between the biggest and the smallest (non-zero) singular value. All the tools used in this work, like quantum algorithms for computing distances and linear algebraic operations, are reported in the Supplementary Material section. In this section, we present a quantum Expectation-Maximization algorithm to fit a GMM. The algorithm can also be adapted fit other mixtures models where the probability distributions belong to the exponential family. As the GMM is both intuitive and one of the most widely used mixture models, our results are presented for the GMM case. A robust version of the EM algorithm Similar to the work of (Kerenidis et al., 2018), we define a \u2206-robust version of the EM algorithm which we use to fit a GMM. The difference between this formalization and the original EM for GMM is simple. Here we explain the numerical error introduced in the training algorithm. Quantum access to the mixture model As in the classical algorithm, we use some subroutines to compute the responsibilities and update our current guess of the parameters. The classical algorithm has clearly two separate steps for Expectation and Maximization. In contrast, the quantum algorithm uses a subroutine to compute the responsibilities inside the step that performs the Maximization, that is the subroutines for computing responsibilities are called multiple times during the quantum Maximization step. During the quantum Maximization step, the algorithm updates the model parameters \u03b3 t by creating quantum states corresponding to parameters \u03b3 t+1 and then recovering classical estimates for these parameters using quantum tomography or amplitude amplification. In order for this subroutines to be efficient, the values of the GMM are stored in QRAM data structures and are updated following each maximization step. Definition 1 (Quantum access to a GMM). We say that we have quantum access to a GMM if the dataset V \u2208 R n\u00d7d and model parameters \u03b8 j \u2208 R, \u00b5 j \u2208 R d , \u03a3 j \u2208 R d\u00d7d for all j \u2208 [k] are stored in QRAM data structures which allow us to perform in time O(polylog(d)) the following mappings: \u2022 |j |i |0 \u2192 |j |i |\u03c3 Require: Quantum access to a GMM model, precision parameters \u03b4 \u03b8 , \u03b4 \u00b5 , and threshold \u03c4 . Ensure: A GMM \u03b3 t that maximizes locally the likelihood (\u03b3; V ), up to tolerance \u03c4 . 1: Use a heuristic described at the beginning of this section to determine an initial guess for \u03b3 0 = (\u03b8 0 , \u00b5 0 , \u03a3 0 ), and store these parameters in the QRAM. 2: Use Lemma 3.1 to estimate the log determinant of the matrices {\u03a3 Step 1: Get an estimate of \u03b8 t+1 such that \u03b8 t+1 \u2212 \u03b8 t+1 \u2264 \u03b4 \u03b8 using Lemma 3.4. Step 2: Get an estimate {\u00b5 j t+1 } k j=1 by using Lemma 3.6 to estimate each \u00b5 t+1 j and |\u00b5 Step 3: Get an estimate {\u03a3 j t+1 } k j=1 by using Lemma 3.7 to estimate \u03a3 t+1 j F and |\u03a3 t+1 j such that Step 4: Estimate E[p(v i ; \u03b3 t+1 )] up to error \u03c4 /2 using Theorem 3.8. Step 5: Store \u03b3 t+1 in the QRAM, and use Lemma 3.1 to estimate the determinants {log det( . 10: Quantum initialization strategies exists, and are described in the Appendix. In this step of the quantum algorithm we are just showing how to compute efficiently the responsibilities as a quantum state. First, we compute the responsibilities in a quantum register, and then we show how to put them as amplitudes of a quantum state. We start by a classical algorithm used to efficiently approximate the log-determinant of the covariance matrices of the data. At each iteration of Quantum Expectation-Maximization we need to compute the determinant of the updated covariance matrices, which is done thanks to Lemma 3.1. We will see from the error analysis that in order to get an estimate of the GMM, we need to call Lemma 3.1 with precision for which the runtime of Lemma 3.1 gets subsumed by the running time of finding the updated covariance matrices through 3.7. Thus, we do not explicitly write the time to compute the determinant from now on in the algorithm and when we say that we update \u03a3 we include an update on the estimate of log(det(\u03a3)) as well. Lemma 3.1 (Determinant evaluation). There is an algorithm that, given as input a matrix \u03a3 and a parameter 0 < \u03b4 < 1, outputs an estimate log(det(\u03a3)) such that |log(det(\u03a3)) \u2212 log(det(\u03a3))| \u2264 with probability 1 \u2212 \u03b4 in time: Now we can state the main brick used to compute the responsability: a quantum algorithm for evaluating the exponent of a Gaussian distribution. Lemma 3.2 (Quantum Gaussian Evaluation). Suppose we have stored in the QRAM a matrix V \u2208 R n\u00d7d , the centroid \u00b5 \u2208 R d and the covariance matrix \u03a3 \u2208 R d\u00d7d of a multivariate Gaussian distribution \u03c6(v|\u00b5, \u03a3), as well as an estimate for log(det(\u03a3)). Then for 1 > 0, there exists a quantum algorithm that with probability 1 \u2212 \u03b3 performs the mapping, ) is the exponent for the Gaussian probability density function. The running time of the algorithm is Using controlled operations it is simple to extend the previous Theorem to work with multiple Gaussians distributions (\u00b5 j , \u03a3 j ). That is, we can control on a register |j to do |j |i |0 \u2192 |j |i |\u03c6(v i |\u00b5 j , \u03a3 j ) . In the next Lemma we will see how to obtain the responsibilities r ij using the previous Theorem and standard quantum circuits for doing arithmetic, controlled rotations, and amplitude amplification. The Lemma is stated in a general way, to be used with any probability distributions that belong to an exponential family. Lemma 3.3 (Calculating responsibilities). Suppose we have quantum access to a GMM with parameters There are quantum algorithms that can: 1. Perform the mapping |i |j |0 \u2192 |i |j |r ij such that |r ij \u2212 r ij | \u2264 1 with probability 1 \u2212 \u03b3 in time: ij with high probability in time: Now we need to get a new estimate for the parameters of our model. This is the idea: at each iteration we recover the new parameters of the model as quantum states, and then recover it using tomography, amplitude estimation, or sampling. Once the new model has been recovered, we update the QRAM such that we get quantum access to the model \u03b3 t+1 . The possibility to estimate \u03b8 comes from a call to the unitary we built to compute the responsibilities, and postselection. Lemma 3.4 (Computing \u03b8 t+1 ). We assume quantum access to a GMM with parameters \u03b3 t and let \u03b4 \u03b8 > 0 be a precision parameter. There exists an algorithm that estimates We use quantum linear algebra to transform the uniform superposition of responsibilities of the j-th mixture into the new centroid of the j-th Gaussian. Let R t j \u2208 R n be the vector of responsibilities for a Gaussian j at iteration t. The following claim relates the vectors R t j to the centroids \u00b5 t+1 j . Claim 3.5. Let R t j \u2208 R n be the vector of responsibilities of the points for the Gaussian j at time The proof is straightforward. Lemma 3.6 (Computing \u00b5 t+1 j ). We assume we have quantum access to a GMM with parameters \u03b3 t . For a pre- From the ability to calculate responsibility and indexing the centroids, we derive the ability to reconstruct the covariance matrix of the Gaussians as well. Again, we use quantum linear algebra subroutines and tomography to recover an approximation of each \u03a3 j . Recall that we have defined the matrix V \u2208 R n\u00d7d Lemma 3.7 (Computing \u03a3 t+1 j ). We assume we have quantum access to a GMM with parameters \u03b3 t . We also have computed estimates \u00b5 j t+1 of all centroids such that \u00b5 j t+1 \u2212 \u00b5 t+1 j \u2264 \u03b4 \u00b5 for precision parameter \u03b4 \u00b5 > 0. Then, there exists a quantum algorithm that outputs estimates for the new covariance matrices {\u03a3 with high probability, in time, Now we are going to show how it is possible to get an estimate of the log-likelihood using a quantum procedure and access to a GMM model. A good estimate is crucial, as it is used as stopping criteria for the quantum algorithm as well. Classically, we stop to iterate the EM algorithm when | (\u03b3 t ; V ) \u2212 (\u03b3 t+1 ; V )| < n , or equivalently, we can set a tolerance on the average increase in log probability: . From this we can estimate an upper bound on the log-likelihood as n log Lemma 3.8 (Quantum estimation of likelihood). We assume we have quantum access to a GMM with parameters \u03b3 t . For \u03c4 > 0, there exists a quantum algorithm that estimates E[p(v i ; \u03b3 t )] with absolute error \u03c4 in time Putting together all the previous Lemmas, we write the main result of the work. Theorem 3.9 (QEM for GMM). We assume we have quantum access to a GMM with parameters \u03b3 t . For parameters \u03b4 \u03b8 , \u03b4 \u00b5 , \u03c4 > 0, the running time of one iteration of the Quantum Expectation-Maximization (QEM) algorithm is For the range of parameters of interest, the running time is dominated by T \u03a3 . The proof follows directly from the previous lemmas. Note that the cost of the whole algorithm is given by repeating the Estimation and the Maximization steps several times, until the threshold on the log-likelihood is reached. Note also that the expression of the runtime can be simplified from the observation that the cost of performing tomography on the covariance matrices \u03a3 j dominates the cost. In this section, we present the results of some experiments on real datasets to bound the condition number and the other parameters of the runtime. Let's discuss the value of \u03ba(\u03a3), \u03ba(V ), \u00b5(\u03a3), and \u00b5(V ). We can thresholding the condition number by discarding small singular values of the matrix, as used in quantum linear algebra, might be advantageous. This is indeed done often in classical machine learning models, since discarding the eigenvalues smaller than a certain threshold might even improve upon the metric under consideration (i.e. often the accuracy), and is a form of regularization (Murphy, 2012, Section 6.5) . This is equivalent to limiting the eccentricity of the Gaussians. We can have a similar consideration on the condition number of the dataset \u03ba(V ). As shown before, the condition number of the matrix V appearing in Lemma 3.2 is \u03ba 2 (V ). Similarly, we can claim that the value of \u00b5(V ) will not increase significantly as we add vectors to the training set. Remember that we have some choice in picking the function \u00b5: in previous experiments we have found that choosing the maximum 1 norm of the rows of V lead to values of \u00b5 around 10, and also in this case we expect the samples of a well-clusterable (Kerenidis et al., 2018) dataset to be constant. Also, \u00b5 is bounded by the Frobenius norm of V . In case the matrix V can be clustered with high-enough accuracy by k-means, it has been showed that the Frobenius norm of the matrix is proportional to \u221a k. Given that EM is a more powerful extension of k-means, we can rely on similar observations too. Usually, the number of features d is much more than the number of components in the mixture, i.e. d k, so we expect d 2 to dominate the k 3.5 term in the cost needed to estimate the mixing weights. This makes the runtime of a single iteration proportional to: As we said, the quantum running time saves the factor that depends on the number of samples and introduces a number of other parameters. Using our experimental results we can see that when the number of samples is large enough one can expect the quantum running time to be faster than the classical one. Note as well that one can expect to save some more factors from the quantum running time with a more careful analysis. Experiments. In the algorithm, we need to set the parameters \u03b4 \u00b5 and \u03b4 \u03b8 to be small enough such that the likelihood is perturbed less than \u03c4 /4. We have reasons to believe that on well-clusterable data, the value of these parameters will be large enough, such as not to impact dramatically the runtime. A quantum version of k-means algorithm has already been simulated on real data under similar assumptions (Kerenidis et al., 2018) . There, the authors analyzed on the MNIST dataset the performances of q-means, the \u03b4-resistant version of the classical k-means algorithm. The experiment concluded that, for datasets that are expected to be clustered nicely by this kind of clustering algorithms, the value of the parameters \u03b4 \u00b5 , \u03b4 \u03b8 did not decrease by increasing the number of samples nor the number of features. We expect similar behaviour in the EM case, namely that for large datasets the impact on the runtime of the errors (\u03b4 \u00b5 , \u03b4 \u03b8 ) does not cancel out the exponential gain in the dependence on the number of samples. For instance, in all the experiments of q-means (Kerenidis et al., 2018) on the MNIST dataset the value of \u03b4 \u00b5 (which in their case was called just \u03b4) has been between 0.2 and 0.5. The value of \u03c4 is usually (for instance in scikit-learn (Pedregosa et al., 2011) ) chosen to be 10 \u22123 . The value of \u03b7 has always been below 11. We also analyzed some other real-world dataset, which can be fitted well with the EM algorithm (Reynolds et al., 2000; APPML; Voxforge.org) to perform speaker recognition: the task of recognizing a speaker from a voice sample, having access to a training set of recorded voices of all the possible speakers. Details of the measurements are reported in the Supplementary Material section, here we report only the results in Table 1 . After this, we also experimented the impact of errors on the mixing weights in the accuracy of a ML estimate of a GMM by perturbing the trained model, by adding some random noise. With a value of \u03b4 \u03b8 = 0.035, \u03b4 \u00b5 = 0.5 we correctly classified 98.2% utterances. Table 1 : We estimate some of the parameters of the VoxForge (Voxforge.org) dataset. The averages for the matrix V are taken over 34 samples, while for \u03a3 is over 170 samples. The accuracy reported in the experiments is measured on 170 samples in the test set, after the threshold on the eigenvalues of \u03a3. Each model is the result of the best of 3 different initializations of the EM algorithm. The first and the second column are the maximum singular values of all the covariance matrices, and the absolute value of the log-determinant. The column \u03ba * (\u03a3) consist in the thresholded condition number for the covariance matrices. In conclusion, the experimental results suggest that the influence of the extra parameters in the quantum running time (condition thresholds, errors, etc.) is moderate. This allows us to be optimistic that, when quantum computers with quantum access to data become a reality, our algorithm (and improved versions that reduce even more the complexity with respect to these extra parameters) could be useful in analyzing large datasets. 6 SUPPLEMENTARY MATERIAL Here we report useful Theorems, Lemmas, and Claims that we use in the main text. Theorem 6.1 (Determinant estimation (Boutsidis et al., 2017)). Let M \u2208 R d\u00d7d be a positive definite matrix with eigenvalues in the interval (\u03c3 min , 1). Then for all \u03b4 \u2208 (0, 1) and > 0 there is a classical algorithm that outputs log(det(M )) such that |log(det(M )) \u2212 log(det(M ))| \u2264 2 | log(det(M ))| with probability at least 1 \u2212 \u03b4 in time Require: Dataset V , tolerance \u03c4 > 0. Ensure: A GMM \u03b3 t = (\u03b8 t , \u00b5 t , \u03a3 t ) that maximizes locally the likelihood (\u03b3; V ) up to tolerance \u03c4 . 1: Select \u03b3 0 = (\u03b8 0 , \u00b5 0 , \u03a3 0 ) using classical initialization strategies described in Subsection 6.3. 2: t = 0 3: repeat Expectation \u2200i, j, calculate the responsibilities as: 5: Maximization Update the parameters of the model as: 6: t=t+1 7: until 8: 9: Return Proof. We need to find the K such that for all x, y \u2208 R d , we have that \u03c3 j (y) \u2212 \u03c3 j (x) \u2264 K y \u2212 x . Observing that \u03c3 j is differentiable and that if we apply Cauchy-Schwarz to the statement of the Mean-Value-Theorem we derive that \u2200x, y \u2208 U, \u2203c such that f (x) \u2212 f (y) \u2264 \u2207f (c) F x \u2212 y . So to show Lipschitz continuity it is enough to select K \u2264 \u2207\u03c3 j * The partial derivatives In our case we can deduce that: Claim 6.4. (Kerenidis & Prakash, 2017b) Let \u03b8 be the angle between vectors x, y, and assume that \u03b8 < \u03c0/2. Then, We will also use Claim 4.5 from (Kerenidis et al., 2018). Claim 6.5. (Kerenidis et al., 2018) Let b be the error we commit in estimating |c such that |c \u2212 |c < b , and a the error we commit in the estimating the norms, Definition 2 (Exponential Family(Murphy, 2012)). A probability density function or probability mass function p(v|\u03bd) , where V \u2286 R, \u03bd \u2208 R p is said to be in the exponential family if can be written as: where: \u2022 \u03bd \u2208 R p is called the canonical or natural parameter of the family, \u2022 o(\u03bd) is a function of \u03bd (which often is just the identity function), \u2022 T (v) is the vector of sufficient statistics: a function that holds all the information the data v holds with respect to the unknown parameters, \u2022 A(\u03bd) is the cumulant generating function, or log-partition function, which acts as a normalization factor, \u2022 h(v) > 0 is the base measure which is a non-informative prior and de-facto is scaling constant. To prove our results, we are going to use the quantum procedures listed hereafter. Theorem 6.6 (Amplitude estimation and amplification (Brassard et al., 2002) ). If there is unitary operator U such that U |0 l = |\u03c6 = sin(\u03b8) |x, 0 + cos(\u03b8) |G, 0 \u22a5 then sin 2 (\u03b8) can be estimated to multiplicative error \u03b7 in time \u03b7 sin(\u03b8) ) and |x can be generated in expected time O( We also need some state preparation procedures. These subroutines are needed for encoding vectors in v i \u2208 R d into quantum states |v i . An efficient state preparation procedure is provided by the QRAM data structures. We stress the fact that our result continues to hold, no matter how the efficient quantum loading of the data is provided. For instance, the data can be accessed through a QRAM, through a block encoding, or when the data can be produced by quantum circuits. Theorem 6.7 (QRAM data structure (Kerenidis & Prakash, 2017a) ). Let V \u2208 R n\u00d7d , there is a data structure to store the rows of V such that, 1. The time to insert, update or delete a single entry v ij is O(log 2 (n)). In our algorithm we will also use subroutines for quantum linear algebra. For a symmetric matrix M \u2208 R d\u00d7d with spectral norm M = 1 stored in the QRAM, the running time of these algorithms depends linearly on the condition number \u03ba(M ) of the matrix, that can be replaced by \u03ba \u03c4 (M ), a condition threshold where we keep only the singular values bigger than \u03c4 , and the parameter \u00b5(M ), a matrix dependent parameter defined as et al., 2018; Gily\u00e9n et al., 2018b) . Theorem 6.8 (Quantum linear algebra (Chakraborty et al., 2018; Gily\u00e9n et al., 2018b) ). Let M \u2208 R d\u00d7d such that M 2 = 1 and x \u2208 R d . Let , \u03b4 > 0. If M is stored in appropriate QRAM data structures and the time to prepare |x is T x , then there exist quantum algorithms that with probability at least 1 \u2212 1/poly(d) return a state |z such that Theorem 6.9 (Quantum linear algebra for matrix products (Chakraborty et al., 2018) ). Let M 1 , M 2 \u2208 R d\u00d7d such that M 1 = M 2 = 1 and x \u2208 R d , and a vector x \u2208 R d stored in QRAM. Let > 0. Then there exist quantum algorithms that with probability at least 1 \u2212 1/poly(d) returns a state |z such that |z \u2212 |M x \u2264 in time O((\u03ba(M )(\u00b5(M 1 )T M1 + \u00b5(M 2 )T M2 )) log(1/ )), where T M1 , T M2 is the time needed to index the rows of M 1 and M 2 . The linear algebra procedures above can also be applied to any rectangular matrix V \u2208 R N \u00d7d by considering instead The final component needed for the q-means algorithm is a linear time algorithm for vector state tomography that will be used to recover classical information from the quantum states corresponding to the new centroids in each step. Given a unitary U that produces a quantum state |x , by calling O(d log d/ 2 ) times U , the tomography algorithm is able to reconstruct a vector x that approximates |x such that | x \u2212 |x \u2264 . Theorem 6.10 (Vector state tomography (Kerenidis & Prakash, 2018) ). Given access to unitary U such that U |0 = |x and its controlled version in time T (U ), there is a tomography algorithm with time complexity O(T (U ) ) that produces unit vector x \u2208 R d such that x \u2212 x 2 \u2264 with probability at least (1 \u2212 1/poly(d)). Lemma 6.11 (Distance / Inner Products Estimation (Kerenidis et al., 2018; Wiebe et al., 2014; Lloyd et al., 2013a) ). Assume for a data matrix V \u2208 R N \u00d7d and a centroid matrix C \u2208 R k\u00d7d that the following unitaries |i |0 \u2192 |i |v i , and |j |0 \u2192 |j |c j can be performed in time T and the norms of the vectors are known. For any \u2206 > 0 and > 0, there exists a quantum algorithm that computes | with probability at least 1 \u2212 2\u2206 in time O vi cj T log(1/\u2206) . Unlike k-means clustering, choosing a good set of initial parameters for a mixture of Gaussian is by no means trivial, and in multivariate context is known that the solution is problem-dependent. There are plenty of proposed techniques, and here we describe a few of them. Fortunately, these initialization strategies can be directly translated into quantum subroutines without impacting the overall running time of the quantum algorithm. The simplest technique is called random EM, and consists in selecting initial points at random from the dataset as centroids, and sample the dataset to estimate the covariance matrix of the data. Then these estimates are used as the starting configuration of the model, and we may repeat the random sampling until we get satisfactory results. A more standard technique borrows directly the initialization strategy of k-means++ proposed in (Arthur & Vassilvitskii, 2007) , and extends it to make an initial guess for the covariance matrices and the mixing weights. The initial guess for the centroids is selected by sampling from a suitable, easy to calculate distribution. This heuristic works as following: Let c 0 be a randomly selected point of the dataset, as first centroid. The other k \u22121 centroids are selected by selecting a vector v i with probability proportional to d 2 (v i , \u00b5 l(vi) ), where \u00b5 l(vi) is the previously selected centroid that is the closest to v i in 2 distance. These centroids are then used as initial centroids for a round of k-means algorithm to obtain \u00b5 0 1 \u00b7 \u00b7 \u00b7 \u00b5 0 j . Then, the covariance matrices can be initialized as \u03a3 T , where C j is the set of samples in the training set that have been assigned to the cluster j in the previous round of k-means. The mixing weights are estimated as C j /n. Eventually \u03a3 0 j is regularized to be a PSD matrix. There are other possible choices for parameter initialization in EM, for instance, based on Hierarchical Agglomerative Clustering (HAC) and the CEM algorithm. In CEM we run one step of EM, but with a so-called classification step between E and M. The classification step consists in a hard-clustering after computing the initial conditional probabilities (in the E step). The M step then calculates the initial guess of the parameters (Celeux & Govaert, 1992) . In the small EM initialization method we run EM with a different choice of initial parameters using some of the previous strategies. The difference here is that we repeat the EM algorithm for a few numbers of iterations, and we keep iterating from the choice of parameters that returned the best partial results. For an overview and comparison of different initialization techniques, we refer to (Bl\u00f6mer & Bujna, 2013; Biernacki et al., 2003) . Quantum initialization strategies For the initialization of \u03b3 0 in the quantum algorithm we can use the same initialization strategies as in classical machine learning. For instance, we can use the classical random EM initialization strategy for QEM. A quantum initialization strategy can also be given using the k-means++ initializion strategy from (Kerenidis et al., 2018) , which returns k initial guesses for the centroids c , where is the average squared distance between two points of the dataset, and is the tolerance in the distance estimation. From there, we can perform a full round of q-means algorithm and get an estimate for \u00b5 0 1 \u00b7 \u00b7 \u00b7 \u00b5 0 k . With q-means and the new centroids store in the QRAM we can create the state Where l(v i ) is the label of the closest centroid to the i-th point. By sampling S \u2208 O(d) points from this state we get two things. First, from the frequency f j of the second register we can have an guess of \u03b8 0 j \u2190 |C j |/n \u223c f j /S. Then, from the first register we can estimate \u03a3 Sampling O(d) points and creating the state in Equation (8) takes time O(dk\u03b7) by Theorem 6.11 and the minimum finding procedure described in (Kerenidis et al., 2018) . Techniques illustrated in (Miyahara et al., 2019) can also be used to quantize the CEM algorithm which needs a hardclustering step. Among the different possible approaches, the random and the small EM greatly benefit from a faster algorithm, as we can spend more time exploring the space of the parameters by starting from different initial seeds, and thus avoid local minima of the likelihood. What we presented in the previous section is the most general model of GMM. For simple datasets, it is common to assume some restrictions on the covariance matrices of the mixtures. The translation into a quantum version of the model should be straightforward. We distinguish between these cases: 1. Soft k-means. This algorithm is often presented as a generalization of k-means, but it can actually be seen as special case of EM for GMM -albeit with a different assignment rule. In soft k-means, the assignment function is replaced by a softmax function with stiffness parameter \u03b2. This \u03b2 represents the covariance of the clusters. It is assumed to be equal for all the clusters, and for all dimensions of the feature space. Gaussian Mixtures with constant covariance matrix (i.e. \u03a3 j = \u03b2I for \u03b2 \u2208 R) can be interpreted as a kind of soft or fuzzy version of k-means clustering. The probability of a point in the feature space being assigned to a certain cluster j is: where \u03b2 > 0 is the stiffness parameter. 2. Spherical. In this model, each component has its own covariance matrix, but the variance is uniform in all the directions, thus reducing the covariance matrix to a multiple of the identity matrix (i.e. \u03a3 j = \u03c3 2 j I for \u03c3 j \u2208 R). 3. Diagonal. As the name suggests, in this special case the covariance matrix of the distributions is a diagonal matrix, but different Gaussians might have different diagonal covariance matrices. 4. Tied. In this model, the Gaussians share the same covariance matrix, without having further restriction on the Gaussian. 5. Full. This is the most general case, where each of the components of the mixture have a different, SDP, covariance matrix. Lemma 6.12 (Determinant evaluation). There is an algorithm that, given as input a matrix \u03a3 and a parameter 0 < \u03b4 < 1, outputs an estimate log(det(\u03a3)) such that |log(det(\u03a3)) \u2212 log(det(\u03a3))| \u2264 with probability 1 \u2212 \u03b4 in time: Proof. In order to apply Theorem 6.1, we need to be sure that all the eigenvalues lie in (\u03c3 min , 1). In order to satisfy this condition, we can scale the matrix by a constant factor c, such that \u03a3 = \u03a3/c. In this way, log det(\u03a3 ) = log . This will allow us to recover the value of log det(\u03a3) by using Theorem 6.1. We apply the Theorem with precision = 1/4 to get an estimate \u03b3 such that 2 . Then, to have an estimate with absolute error , we apply Theorem 6.1 with precision = 4\u03b3 . This gives us an estimate for log(det(\u03a3)) with error 2 log(det(\u03a3)) \u2264 in time: Lemma 6.13 (Error in the responsibilities of the exponential family). Let v i \u2208 R n be a vector, and let {p(v i |\u03bd j )} k j=1 be a set of k probability distributions in the exponential family, defined as p( Then, if we have estimates for each exponent with error , then we can compute each r ij such that |r ij \u2212r ij | \u2264 \u221a 2k for j \u2208 [k]. Proof. The proof follows from rewriting the responsibility of Equation (3) as: In this form, it is clear that the responsibilities can be seen a softmax function, and we can use Theorem 6.3 to bound the error in computing this value. Let T i \u2208 R k be the vector of the exponent, that is In an analogous way we define T i the vector where each component is the estimate with error . The error in the responsibility is defined Because the function \u03c3 j is Lipschitz continuous, as we proved in Theorem 6.3 with a Lipschitz constant K \u2264 \u221a 2, we have that, |\u03c3 j ( Lemma 6.14 (Quantum Gaussian Evaluation). Suppose we have stored in the QRAM a matrix V \u2208 R n\u00d7d , the centroid \u00b5 \u2208 R d and the covariance matrix \u03a3 \u2208 R d\u00d7d of a multivariate Gaussian distribution \u03c6(v|\u00b5, \u03a3), as well as an estimate for log(det(\u03a3)). Then for 1 > 0, there exists a quantum algorithm that with probability 1 \u2212 \u03b3 performs the mapping, \u2022 U G, 1 : |i |0 \u2192 |i |s i such that |s i \u2212 s i | < 1 , where ) is the exponent for the Gaussian probability density function. The running time of the algorithm is, Proof. We use quantum linear algebra and inner product estimation to estimate the quadratic form \u00b5 and separately approximate each term in the sum to error 1 /4. We describe the procedure to estimate Recall that (through Lemma 3.1) we also have an estimate of the log-determinant to error 1 . Thus we obtain an approximation for \u2212 + log(det(\u03a3))) within error 2 1 . We have the upper bound, for \u03a3 stored in a QRAM data structure. Further observing that u \u2264 \u221a \u03b7 and v i \u2264 \u221a \u03b7, the running time for this computation is O Lemma 6.15 (Calculating responsibilities). Suppose we have quantum access to a GMM with parameters \u03b3 t = (\u03b8 t , \u00b5 t , \u03a3 t ). There are quantum algorithms that can: 1. Perform the mapping |i |j |0 \u2192 |i |j |r ij such that |r ij \u2212 r ij | \u2264 1 with probability 1 \u2212 \u03b3 in time: ij with high probability in time: Proof. For the first statement, let's recall the definition of responsibility: . With the aid of U G, 1 of Lemma 3.2 we can estimate log(\u03c6(v i |\u00b5 j , \u03a3 j )) for all j up to additive error 1 , and then using the current estimate of \u03b8 t , we can calculate the responsibilities create the state, The estimate r ij is computed by evaluating a weighted softmax function with arguments log(\u03c6( The estimates log(\u03c6(v i |\u00b5 j , \u03a3 j ) are then uncomputed. The runtime of the procedure is given by calling k times Lemma 3.2 for Gaussian estimation (the arithmetic operations to calculate the responsibilities are absorbed). Let us analyze the error in the estimation of r ij . The responsibility r ij is a softmax function with arguments log(\u03c6(v i |\u00b5 j , \u03a3 j )) that are computed upto error 1 using Lemma 3.2. As the softmax function has a Lipschitz constant K \u2264 \u221a 2 by Lemma 6.13, we choose precision for Lemma 3.2 to be 1 / \u221a 2k to get the guarantee |r ij \u2212 r ij | \u2264 1 . Thus, the total cost of this step is T R1, 1 = k 1.5 T G, 1 . Now let's see how to encode this information in the amplitudes, as stated in the second claim of the Lemma. We estimate the responsibilities r ij to some precision and perform a controlled rotation on an ancillary qubit to obtain, We then undo the circuit on the second register and perform amplitude amplification on the rightmost auxiliary qubit being |0 to get |R j := Let us analyze the precision required to prepare |R j such that |R j \u2212 |R j \u2264 1 . As we have estimates |r ij \u2212 r ij | < for all i, j, the 2 -norm error n . Applying Claim 6.4, the error for the normalized vector |R j can be bounded as Rj . By the Cauchy-Schwarz inequality we have that . We can use this to obtain a bound , using the dataset assumptions in section 2. If we choose such that Lemma 6.16 (Computing \u03b8 t+1 ). We assume quantum access to a GMM with parameters \u03b3 t and let \u03b4 \u03b8 > 0 be a precision parameter. There exists an algorithm that estimates \u03b8 t+1 \u2208 R k such that \u03b8 t+1 \u2212 \u03b8 t+1 \u2264 \u03b4 \u03b8 in time T , and compute a state |\u00b5 j t+1 along with an estimate for the norm V T R t j = \u00b5 j t+1 with error norm . The last step of the algorithm consists in estimating the unit vector |\u00b5 j t+1 with precision tom using tomography. Considering that the tomography depends on d, which we expect to be bigger than the precision required by the norm estimation, we can assume that the runtime of the norm estimation is absorbed. Thus, we obtain: O k Let's now analyze the total error in the estimation of the new centroids, which we want to be \u03b4 \u00b5 . For this purpose, we use Claim 6.5, and choose parameters such that 2 \u221a \u03b7( tom + norm ) = \u03b4 \u00b5 . Since the error 3 for quantum linear algebra appears as a logarithmic factor in the running time, we can choose 3 tom without affecting the runtime. Let \u00b5 be the classical unit vector obtained after quantum tomography, and |\u00b5 be the state produced by the quantum linear algebra procedure starting with an approximation of |R t j . Using the triangle inequality we have |\u00b5 \u2212 \u00b5 < \u00b5 \u2212 |\u00b5 + |\u00b5 \u2212 |\u00b5 < tom + 1 < \u03b4 \u00b5 /2 \u221a \u03b7. The errors for the norm estimation procedure can be bounded We therefore choose parameters Since the amplitude estimation step we use for estimating the norms does not depends on d, which is expected to dominate the other parameters, we omit the amplitude estimation step. Substituting for T R2,\u03b4\u00b5 , we have the more concise expression for the running time of: Lemma 6.18 (Computing \u03a3 t+1 j ). We assume we have quantum access to a GMM with parameters \u03b3 t . We also have computed estimates \u00b5 j t+1 of all centroids such that \u00b5 j t+1 \u2212 \u00b5 t+1 j \u2264 \u03b4 \u00b5 for precision parameter \u03b4 \u00b5 > 0. Then, there exists a quantum algorithm that outputs estimates for the new covariance matrices {\u03a3 with high probability, in time, Proof. It is simple to check, that the update rule of the covariance matrix during the maximization step can be reduced to (Murphy, 2012, Exercise 11.2): First, note that we can use the estimates of the centroids to compute \u00b5 t+1 j (\u00b5 t+1 j ) T with error \u03b4 \u00b5 \u00b5 \u2264 \u03b4 \u00b5 \u221a \u03b7 in the update rule for the \u03a3 j . This follows from the fact that \u00b5 = \u00b5 + e where e is a vector of norm \u03b4 \u00b5 . Therefore does not depend on d, we consider it smaller than the runtime for performing tomography. Thus, the runtime for this operation is: Let's analyze the error of this procedure. We want a matrix \u03a3 j that is \u221a \u03b7\u03b4 \u00b5 -close to the correct one: Again, the error due to matrix multiplication can be taken as small as necessary, since is inside a logarithm. From Claim 6.5, we just need to fix the error of tomography and norm estimation such that \u03b7( unit + norms ) < \u221a \u03b7\u03b4 \u00b5 where we have used \u03b7 as an upper bound on \u03a3 j F . For the unit vectors, we require where |\u03a3 j is the error due to tomography and |\u03a3 j is the error due to Lemma 3.3. For this inequality to be true, we choose tom = 1 < \u03b4 \u00b5 /4 \u221a \u03b7. The same argument applies to estimating the norm \u03a3 j with relative error : \u221a \u03b7 (where here is the error of the amplitude estimation step used in Theorem 6.8 and 1 is the error in calling Lemma 3.3. Again, we choose . This can be derived from the fact that \u03ba(A \u2297 B) = \u03ba(A)\u03ba(B), \u03ba(AB) \u2264 \u03ba(A)\u03ba(B), and Since the tomography is more costly than the amplitude estimation step, we can disregard the runtime for the norm estimation step. As this operation is repeated k times for the k different covariance matrices, the total runtime of the whole algorithm is given by O Let us also note that for each of new computed covariance matrices, we use Lemma 3.1 to compute an estimate for their log-determinant and this time can be absorbed in the time T \u03a3 . Lemma 6.19 (Quantum estimation of likelihood). We assume we have quantum access to a GMM with parameters \u03b3 t . For \u03c4 > 0, there exists a quantum algorithm that estimates E[p(v i ; \u03b3 t )] with absolute error \u03c4 in time Proof. We obtain the likelihood from the ability to compute the value of a Gaussian distribution and quantum arithmetic. Using the mapping of Lemma 3.2 with precision 1 , we can compute \u03c6(v i |\u00b5 j , \u03a3 j ) for all the Gaussians, that is |i k\u22121 j=0 |j |p(v i |j; \u03b3 j ) . Then, by knowing \u03b8, and by using quantum arithmetic we can compute in a register the mixture of Gaussian's: p(v i ; \u03b3) = j\u2208[k] \u03b8 j p(v i |j; \u03b3). We now drop the notation for the model \u03b3 and write p(v i ) instead of p(v i ; \u03b3). Doing the previous calculations quantumly leads to the creation of the state |i |p(v i ) . We perform the mapping |i |p(v i ) \u2192 |i p(v i )| |0 + 1 \u2212 p(v i ) |1 and estimate p(|0 ) E[p(v i )] with amplitude estimation on the ancilla qubit. To get a \u03c4 -estimate of p(0) we need to decide the precision parameter we use for estimating p(v i |j; \u03b3) and the precision required by amplitude estimation. Let p(0) be the 1 -error introduced by using Lemma 3.2 and p(0) the error introduced by amplitude estimation. Using triangle inequality we set p(0) \u2212 p(0) < p(0) \u2212 p(0) + p(0) \u2212 p(0) < \u03c4 . To have |p(0) \u2212 p(0)| < \u03c4 , we should set 1 such that |p(0) \u2212 p(0)| < \u03c4 /4, and we set the error in amplitude estimation and in the estimation of the probabilities to be \u03c4 /2. The runtime of this procedure is therefore: recognition community to extract the so-called Mel Frequency Cepstrum Coefficients (MFCCs) features (Reynolds et al., 2000) . We selected d = 40 features for each speaker. Then, each speaker is modeled with a mixture of 16 different Gaussians. The test set consists of other 5 unseen utterances of the same 34 speakers (i.e. the training set and the test set have the same size). The task is to correctly label the unseen utterances with the name of the correct speaker. This is done by testing each of the GMM fitted during the training with the new voice sample, and selecting the model with the highest likelihood. Due to the differences in the speakers' audio data, the different dataset V 1 . . . V 34 are made of a variable number of points which ranges from n = 2000 to 4000. In the vanilla configuration without thresholding, 169 among 170 utterances (5 utterances for all 34 speakers) were correctly labeled by EM with ML estimate, while all the elements in the test set were correctly recognized using the Bayesian (MAP) framework. During the training, we measured all the values of \u03ba(\u03a3), \u03ba(V ), \u00b5(V ), \u00b5(\u03a3). For almost all GMM fitted (choosing a diagonal covariance matrix), there is at least a \u03a3 j (among the 16 used to model a single speaker) with bad condition number (i.e up to 2500 circa). As in (Kerenidis et al., 2018; Kerenidis & Luongo, 2018) we took a threshold on the matrix by discarding singular values smaller than a certain value m. Practically, we discarded any singular value smaller than 2 \u00d7 10 \u22122 . Thresholding the covariance matrices did not impact the accuracy (the generalization error) significantly. In the MAP estimate, only one element is not correctly classified, while this number goes up to two in the case of ML estimates. The results are in Table 1 . To check the resistence to noise, we perturbed each of the GMM \u03b3 t , once fitted. Then, we measured variations of the accuracy on the test set. For each model, the perturbation consists of three things. First we add to \u03b8 a uniform vector (with randomly selected negative or positive entries) of 2 norm of \u03b4 \u03b8 = 0.035. Then we perturb each centroid \u00b5 j with a vector of norm smaller than \u03b4 \u00b5 = 0.5. In this error vector the sign of each noise component is chosen randomly, and the magnitude is sampled uniformly in the interval (0, ). Then, we perturbed also the diagonal matrices \u03a3 j with a vector of norm smaller than \u03b4 \u00b5 \u221a \u03b7, where \u03b7 = 10. As we are using a diagonal GMM, this reduces to perturbing each singular value by some random noise upper bounded by \u00b1\u03b4 \u00b5 \u221a \u03b7/ \u221a d, making sure that each of the singular value stays positive, as covariance matrices are SPD. Last, the matrices are thresholded. Since the representation of the model used by our software stores the Cholesky's decomposition of the inverse, we worked with that representation. Notably, thresholding the \u03a3 j help to mitigate the error of noise and regularize the model. With these parameters, we were able to correctly label 167 utterances over 170. We leave for the future further experiments with bigger and different types of datasets or where the noise is also added during the training process. We used scikit-learn (Pedregosa et al., 2011) to run all the experiments. Maximum Likelihood is not the only way to estimate the parameters of a model, and in certain cases might not even be the best one. For instance, in high-dimensional spaces, it is pretty common for ML estimates to overfit. Moreover, it is often the case that we have prior information on the distribution of the parameters, and we would like our models to take this information into account. These issues are often addressed using a Bayesian approach, i.e. by using a so-called Maximum A Posteriori estimate (MAP) of a model (Murphy, 2012, Section 14.4.2.8) . MAP estimates work by assuming the existence of a prior distribution over the parameters \u03b3. The posterior distribution we use as objective function to maximize comes from the Bayes' rule applied on the likelihood, which gives the posterior as a product of the likelihood and the prior, normalized by the evidence. More simply, we use the Bayes' rule on the likelihood function, as p(\u03b3; V ) = p(V ;\u03b3)p(\u03b3) p(V ) . This allows us to treat the model \u03b3 as a random variable, and derive from the ML estimate a MAP estimate: Among the advantages of a MAP estimate over ML is that it avoids overfitting by having a kind of regularization effect on the model (Murphy, 2012, Section 6.5). Another feature consists in injecting into a maximum likelihood model some external information, perhaps from domain experts. This advantage comes at the cost of requiring \"good\" prior information on the problem, which might be non-trivial. In terms of labelling, a MAP estimates correspond to a hard"
}