{
    "title": "HylzTiC5Km",
    "content": "The unconditional generation of high fidelity images is a longstanding benchmark\nfor testing the performance of image decoders. Autoregressive image models\nhave been able to generate small images unconditionally, but the extension of\nthese methods to large images where fidelity can be more readily assessed has\nremained an open problem. Among the major challenges are the capacity to encode\nthe vast previous context and the sheer difficulty of learning a distribution that\npreserves both global semantic coherence and exactness of detail. To address the\nformer challenge, we propose the Subscale Pixel Network (SPN), a conditional\ndecoder architecture that generates an image as a sequence of image slices of equal\nsize. The SPN compactly captures image-wide spatial dependencies and requires a\nfraction of the memory and the computation. To address the latter challenge, we\npropose to use multidimensional upscaling to grow an image in both size and depth\nvia intermediate stages corresponding to distinct SPNs. We evaluate SPNs on the\nunconditional generation of CelebAHQ of size 256 and of ImageNet from size 32\nto 128. We achieve state-of-the-art likelihood results in multiple settings, set up\nnew benchmark results in previously unexplored settings and are able to generate\nvery high fidelity large scale samples on the basis of both datasets. A successful generative model has two core aspects: it produces targets that have high fidelity and it generalizes well on held-out data. Autoregressive (AR) models trained by conventional maximum likelihood estimation (MLE) have produced superior scores on held-out data across a wide range of domains such as text BID16 BID18 , audio BID13 , images and videos BID4 . These scores are a measure of the models' ability to generalize in that setting. From the perspective of sample fidelity, the outputs generated by AR models have also achieved state-of-the-art fidelity in many of the aforementioned domains with one notable exception. In the domain of unconditional large-scale image generation, AR samples have yet to manifest long-range structure and semantic coherence. One source of difficulties impeding high-fidelity image generation is the multi-faceted relationship between the MLE scores achieved by a model and the model's sample fidelity. On the one hand, MLE is a well-defined measure as improvements in held-out scores generally produce improvements in the visual fidelity of the samples. On the other hand, as opposed to for example adversarial methods BID0 , MLE forces the model to support the entire empirical distribution. This guarantees the model's ability to generalize at the cost of allotting capacity to parts of the distribution that are irrelevant to fidelity. A second source of difficulties arises from the high dimensionality of large images. A 256 \u00d7 256 \u00d7 3 image has a total of 196,608 positions that need to be architecturally connected in order to learn dependencies among them; the representations at each position require sufficient capacity to express their respective surrounding contexts. These requirements translate to large amounts of memory and computation. Figure 1: A representation of Multidimensional Upscaling. Left: depth upscaling is applied to a generated 3-bit 256 \u00d7 256 RGB subimage from CelebAHQ to map it to a full 8-bit 256 \u00d7 256 RGB image. Right: size upscaling followed by depth upscaling are applied to a generated 3-bit 32 \u00d7 32 RGB subimage from ImageNet to map it to the target resolution of the 8-bit 128 \u00d7 128 RGB image. We stress that the rightmost column of both figures are true unconditional samples from our model at full 8bit depth. These difficulties notwithstanding, we aim to learn the full distribution over 8-bit RGB images of size up to 256 \u00d7 256 well enough so that the samples have high fidelity. We aim to guide the model to focus first on visually more salient bits of the distribution and later on the visually less salient bits. We identify two visually salient subsets of the distribution: first, the subset determined by sub-images (\"slices\") of smaller size (e.g. 32 \u00d7 32) sub-sampled at all positions from the original image; and secondly, the subset determined by the few (e.g. 3) most significant bits of each RGB channel in the image. We use Multidimensional Upscaling to map from one subset of the distribution to the other one by upscaling images in size or in depth. For example, the generation of a 128 \u00d7 128 8-bit RGB image proceeds by first upscaling it in size from a 32 \u00d7 32 3-bit RGB image to a 128 \u00d7 128 3-bit RGB image; we then upscale the resulting image in depth to the original resolution of the 128 \u00d7 128 8-bit RGB image. We thus train three networks: (a) a decoder on the small size, low depth image slices subsampled at every n pixels from the original image with the desired target resolution; (b) a size-upscaling decoder that generates the large size, low depth image conditioned on the small size, low depth image; and (c) a depth-upscaling decoder that generates the large size, high depth image conditioned on the large size, low depth image. Figure 1 illustrates this process. To address the latter difficulties that ensue in the training of decoders (b) and (c), we develop the Subscale Pixel Network (SPN) architecture. The SPN divides an image of size N \u00d7N into sub-images of size N S \u00d7 N S sliced out at interleaving positions (see FIG1 ), which implicitly also captures a form of size upscaling. The N \u00d7 N image is generated one slice at a time conditioned on previously generated slices in a way that encodes a rich spatial structure. SPN consists of two networks, a conditioning network that embeds previous slices and a decoder proper that predicts a single target slice given the context embedding. The decoding part of the SPN acts over image slices with the same spatial structure and it can share weights for all of them. The SPN is an independent image decoder with an implicit size upscaling mechanism, but it can also be used as an explicit size upscaling network by initializing the first slice of the SPN input at sampling time with one generated separately during step (a).We extensively evaluate the performance of SPN and the size and depth upscaling methods both quantitatively and from a fidelity perspective on two unconditional image generation benchmarks, CelebAHQ-256 and ImageNet of various sizes up to 256. From a MLE scores perspective, we compare with previous work to obtain state-of-the-art results on CelebAHQ-256, both at full 8-bit resolution and at the reduced 5-bit resolution BID7 , and on ImageNet-64. We also establish MLE baselines for ImageNet-128 and ImageNet-256. From a sample fidelity perspective, we show the strong benefits of multidimensional upscaling as well as the benefits of the SPN. We produce CelebAHQ-256 samples (at full 8-bit resolution) that are of similar visual fidelity to those produced with methods such as GANs that lack however an intrinsic measure of generalization BID10 BID6 . We also produce some of the first successful samples on unconditional ImageNet-128 (also at 8-bit) showing again the striking impact of the SPN and of multidimensional upscaling on sample quality and setting a fidelity baseline for future methods. A standard AR image model such as the PixelCNN (van den BID14 generates an HxW colour image starting at the top-left position and ending at the bottom-right position, fully generating the three 8-bit channels of each pixel in a given position: DISPLAYFORM0 where x < corresponds to all previously generated intensity values in the ordering and h, w, and c are row, column, and colour channel indices. The raster scan ordering FIG3 (a)) is conventionally used in AR models. Each conditional distribution P (x h,w,c |x < ) is parametrized by a deep neural network (van den Oord et al., 2016b). We define an alternative ordering that divides a large image into a sequence of equally sized slices and has various core properties. First, it makes it easy to compactly encode long-range dependencies across the many pixels in the large images. It also induces a spatial structure over the original image by aligning the subsampled slices; this also has an implicit size upscaling side effect. From the perspective of the neural architecture, it makes it possible for the same decoder within the SPN to be consistently applied to all slices, since they are structurally similar; the smaller slices also allow for self-attention BID16 in the SPN to be used without local contexts . We think of the ordering as the two-dimensional analogue of the one-dimensional subscale ordering introduced in .The subscale ordering is defined as follows: DISPLAYFORM0 where x < corresponds to all previously generated intensity values according to this ordering. FIG3 (d) illustrates the subscale ordering. A scaling factor S is selected and each slice of size H/S \u00d7W/S is obtained by selecting a pixel every S pixels in both height and width; there are thus S 2 interleaved slices in the original image, with each specified by its row and column offset (i, j). We sometimes refer to this offset as the \"meta-position\" of a slice. , 2016b) . (c) is from BID12 . The Subscale ordering alone, with size-only, depth-only and with multidimensional upscaling are, respectively, in blocks (d), (e), (f) and (g). The subscale ordering itself already captures size upscaling implicitly. Analogous to the multi-scale ordering BID14 , and depicted in 3(b), we can perform size upscaling explicitly, by training a single slice decoder on subimages and generate the first slice of a subscale ordering from the single slice decoder itself. The rest of the image is then generated according to the subscale ordering by the main network (see 3(e)). The single-slice model can be trained on just the first slices of images, or on slices at all positions in all images given the shared spatial structure among the slices. For this reason, the same SPN that captures the subscale ordering can act simultaneously as a full-blown image model as well as a size upscaling model if initialized with the outputs of a single-slice decoder. A separate formulation of size upscaling is the Parallel Multi-Scale BID12 ordering where the pixels in an image are doubled at every stage by distinct neural networks and are generated in parallel without sequentiality (3(c)). Multidimensional upscaling applies upscaling not just in the height and width of the image, but also in the remaining dimension that is channel depth. This is performed in stages such that a network first generates the d 1 most significant bits of an image using a conventional or subscale ordering; then a second network generates the next d 2 most significant bits of the image conditioned on all the d 1 bits of the image; and so on to further stages. Using the conventional ordering as basis, the first stage of depth upscaling looks as follows: DISPLAYFORM0 Next, a second stage of depth upscaling has the following form, conditioned on the first d 1 bits of each channel: DISPLAYFORM1 h,w,c |x d1:d2 DISPLAYFORM2 We do not share weights among the networks at different stages of depth upscaling. We note that in depth upscaling bits of lower significance are only generated when the more significants bits at all positions have been generated in a previous stage. Just like for size upscaling from the previous section, the goal of multidimensional upscaling is to let the model focus on visually salient bits of an image unaffected by less salient and less predictable bits of the image. Depth upscaling is related to the method underlying the Grayscale PixelCNN that models 4-bit greyscale images subsampled from colored images BID8 ) construct a representation of the generated context for each dimension of each pixel. Existing AR approaches inherently require an amount of computation and memory that is superlinear in the number of pixels. In particular, the quadratic memory requirements of self-attention become severely limiting for images larger than 32 \u00d7 32 and intractable in practice for the 196,608 distinct positions we consider in a 256 \u00d7 256 colour image. Mitigating the memory requirements and computational requirements of encoding the dependencies amongst so many variables often comes at the expense of global context. Modeling choices such as cropping images within the decoders BID4 or performing self-attention over local neighborhoods neglect global dependencies, while model parallelism, though technically feasible with the joint use of a very large number of accelerators, does not overcome the challenges in learning the global structure. To address these challenges, we devise the Subscale Pixel Network (SPN), an architecture that embodies the subscale ordering from Section 2.2. For an image of size H \u00d7 W \u00d7 3 \u00d7 D, where D is the number of bits used for the current generation stage, one first chooses a scaling factor S and obtains the S 2 slices of the original image of size H/S \u00d7 W/S \u00d7 3 \u00d7 D. We use H = W = 256 and S = 8 as well as H = W = 128 and S = 4, for the larger images we process, so that the slices have size 32 \u00d7 32 \u00d7 3 \u00d7 D. This scheme of choosing S such that slices are always 32 \u00d7 32 renders the memory and computation requirements effectively constant as the true image size H \u00d7 W changes. The SPN architecture is composed of two parts: an embedding part for slices at preceding metapositions that conditions the decoder for the current slice that is being generated FIG4 ). The embedding part is a convolutional neural network with residual blocks that takes as input preceding slices that are concatenated along the depth dimension. One detail is the way the slices are ordered along the channel dimension when concatenated. As illustrated in FIG4 (a), empty padding slices are used to preserve relative meta-positions of each preceding slice with respect to the current target slice. For example, the slice above any target slice in the two-dimensional meta-grid is always aligned in the same position along the depth axis in the input. This achieves equivariance in the embedding architecture with respect to the (i, j) offset of a slice. The padding slices also ensure that the depth of the input slice tensor remains the same for all target slices. In addition to the slice tensor, the embedding part also receives as input the meta-position of the target slice as an embedding of 8 units tiled spatially across the slice tensor. The pixel intensity values are also embedded as one-hot indices of size 8. The context embedding network passes its input through a series of self-attention layers The decoder takes as input the encoded slice tensor s in a position-preserving manner: each position in the target slice is given as input the encoded representations of pixels at that same position in the preceding slices. In addition it processes the target slice in the raster-scan order. The decoder that we use is a hybrid architecture combining masked convolution and self-attention BID1 . We employ an initial 1D self-attention network BID16 that is used to gather the entire available context in the slice (see FIG4 ). The slice is reshaped into a 1D tensor before it is given as input to masked 1D self-attention layers; the masking is performed over the previous pixels only (as opposed to over the current RGB channels) in the self-attention layers. Then the output of the layers is reshaped back into a 2D tensor, concatenated depth-wise with the output of the slice embedding network, and given as conditioning input to a Gated PixelCNN as in Equation 5 in van den BID15 . The PixelCNN network models the target slice with full masking over pixels and channel dimensions. We can see how memory requirements are significantly lower -up to S 2 = 64\u00d7 lower with S = 8 -due to the smaller spatial size of the slices and their compact concatenation along the channel dimension of the input tensor. Due to this structure, the entire previously generated context is captured at each position of the decoder. The log-likelihood derived from equation 2 decomposes as a sum over slices. An unbiased estimator of the log-loss is obtained by uniformly sampling a choice of target slice and evaluating its logprobability conditioned upon previous slices as depicted in FIG4 (a). We perform maximum likelihood learning by doing stochastic gradient descent on this Monte Carlo estimate, with all gradients computed by backpropagation. As seen in Section 2.3, the SPN naturally serves as a size-upscaling network when the first slice of the input tensor is initialized with with an externally generated subimage. In our experiments, we ensure that the smaller subimages used for the initialization and those used in the training of the SPN decoder are identical to each other. Analogously, the SPN can be used to upscale the depth of the channels of an image. The image to be upscaled in depth is itself divided into slices by the subscale method (secion 2) and the slices are then ImageNet 32x32 ImageNet 64x64 Gated PixelCNN (van den Oord et al., 2016c) 3.83 3.57 Parallel Multiscale BID12 3.95 3.70 PixelSNAIL BID1 3.80 -Image Transformer 3.77 -Glow BID7 4 DISPLAYFORM0 concatenated along the channel dimension into a slice tensor for the conditioning image x :d1 . The latter is then added as a fixed additional input to the embedding part of the SPN in order to model DISPLAYFORM1 ) is a normal SPN, but trained on data with low bit depth. We demonstrate experimentally that our model is capable of high fidelity samples at high resolution, producing unconditional CelebA-HQ samples of quality better than the Glow model BID7 and improving the MLE scores. Furthermore, we show that these results extend to high-resolution ImageNet images, with state-of-the-art log-likelihoods at 128x128 by a large margin and the first benchmark on 256x256 ImageNet. Unconditional samples at these resolutions are characterized by unprecedented global coherence. Because our networks operate on small images (32 \u00d7 32 slices), we can train large networks both in terms of the number of hidden units and in terms of network depth (see Appendix C for details of sizes). The context-embedding network contains 5 convolutional layers and 6-8 self-attention layers depending on the dataset. The masked decoder consists of a PixelCNN with 15 layers in all experiments. The 1D Transformer in the decoder FIG4 ) has between 8 and 10 layers depending on the dataset. See Table 4 for all dataset-specific hyperparameter details.4.1 DOWNSAMPLED IMAGENET AT 32 \u00d7 32 AND 64 \u00d7 64We first benchmark the performance of our hybrid decoder alone (i.e. no subscaling, FIG4 ) and show that it compares favorably to state of the art models on 32 \u00d7 32 Downsampled ImageNet (see Table 1 ). We find that SPN hurts in this low-resolution setting with S = 2 and even further with S = 4. This is likely because the size of the resulting image slices becomes very small and the image coarse grained. On 64 \u00d7 64 Downsampled ImageNet, we achieve a state of the art log-likelihood of 3.52 bits/dim. We hypothesize that PixelSNAIL would achieve a similar score, but results at this resolution were not reported in BID1 . At this resolution, SPN scores similarly with 3.53 bits/dim. The improvement over Glow in the 5-bit setting is very significant TAB5 .ImageNet 64 x 64 (5bit) CelebA-HQ 256 x 256 (5bit) Glow BID7 For these experiments we use the standard ILSVRC Imagenet dataset BID9 resized with Tensorflow's resize area function. Parallel Multiscale PixelCNN BID12 ) is the only model in the literature which reports log-likelihood on 128 \u00d7 128 ImageNet. SPN improves the log-likelihood over this model from 3.55 bits/dim to 3.08 bits/dim (see TAB3 ). FIG5 gives 128 \u00d7 128 8-bit ImageNet samples for both the setting of depth upscaling only and of complete multidimensional upscaling. These settings do not affect the NLL, but the samples with depth upscaling show significant semantic coherence that is usually lacking in samples without upscaling. In addition, multidimensional upscaling seems to increase the overall rate of success of the samples. Additional intermediate ImageNet samples can be seen in Figures 10, 11 and 12 in the Appendix. At 256 \u00d7 256 we can produce high-fidelity samples of celebrity faces from the CelebAHQ dataset. The quality compares favorably to the samples of other models such as Glow and GANs BID6 . We show in TAB5 that the achieved MLE scores are a significant improvement over previously reported scores. FIG6 showcases some samples for 8-bit CelebAHQ-256. Figure 7 in the Appendix includes 5-bit samples, Figure 8 includes 3-bit samples while Figure 9 includes 3-bit samples with the temperature of the output distribution set to 0.95. The problem of whether it is possible to learn the distribution of complex natural images and attain high sample fidelity has been a long-standing one in the tradition of generative models. The SPN and Multidimensional Upscaling model that we introduce accomplishes a large step towards solving this problem, by attaining both state-of-the-art MLE scores on large-scale images from complex domains such as CelebAHQ-256 and ImageNet-128 and by being able to generate high fidelity full 8-bit samples from the resulting learnt distributions without alterations to the sampling process (via e.g. heavy modifications of the temperature of the output distribution). The generated samples show an unprecedented amount of semantic coherence and exactness of details even at the large scale size of full 8-bit 128 \u00d7 128 and 256 \u00d7 256 images. In some cases for purposes of analysis the entropy of the softmax output distributions has been artificially reduced via a \"temperature\" divisor on the predicted logits. When we say the temperature is 0.95, we mean that the logits of a trained model have been divided by this constant at sampling time. Table 4 for all the detailed hyperparameters. Our experiments operate at a fairly large scale in terms of both the amount of compute used and the size of the networks. We proportionately increase the batch size so that the number of pixels in a batch is not affected by the subscaling. These large batch sizes (a maximum of 2048) are achieved by increasing the degree of data parallelism by running on Google Cloud TPU pods (Jouppi et al., 2017) . For Imagenet 32 we used 64 tensorcores. For ImageNet 64, 128 and 256, we use 128 tensorcores. The fast interconnect between these devices affords much faster synchronous gradient computation than would be possible using the same number of GPUs. When overfitting is a problem, as in small datasets like CelebA-HQ, we rather decrease the batch size and use a lower number of 32 tensorcores. Our SPN architectures have between \u223c50M and \u223c250M parameters depending on the dataset. See Table 4 for the number of parameters in the SPN architecture for each dataset. Depth-upscaling Published as a conference paper at ICLR 2019Figure 8: 256x256 CelebA-HQ 3bit samples from SPN doubles the number of parameters due to using two separate networks with untied weights. Sizeupscaling adds more parameters still for the separate decoder-only network which models the first slice as seen in FIG3 (g). Thus the maximal number of parameters used to generate a sample in the paper occurs in the multidimensional upscaling setting for ImageNet 128, where the total parameter count reaches \u223c650M (the decoder-only network used to model the first slice has \u223c150M parameters)."
}