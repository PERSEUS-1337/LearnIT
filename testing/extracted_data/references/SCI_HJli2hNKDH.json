{
    "title": "HJli2hNKDH",
    "content": "A major component of overfitting in model-free reinforcement learning (RL) involves the case where the agent may mistakenly correlate reward with certain spurious features from the observations generated by the Markov Decision Process (MDP). We provide a general framework for analyzing this scenario, which we use to design multiple synthetic benchmarks from only modifying the observation space of an MDP. When an agent overfits to different observation spaces even if the underlying MDP dynamics is fixed, we term this observational overfitting. Our experiments expose intriguing properties especially with regards to implicit regularization, and also corroborate results from previous works in RL generalization and supervised learning (SL). Generalization for RL has recently grown to be an important topic for agents to perform well in unseen environments. Complication arises when the dynamics of the environments entangle with the observation, which is often a high-dimensional projection of the true latent state. One particular framework, which we denote by zero-shot supervised framework (Zhang et al., 2018a; Nichol et al., 2018; Justesen et al., 2018) and is used to study RL generalization, is to treat it analogous to a classical supervised learning (SL) problem -i.e. assume there exists a distribution of MDP's, train jointly on a finite \"training set\" sampled from this distribution, and check expected performance on the entire distribution, with the fixed trained policy. In this framework, there is a spectrum of analysis, ranging from almost purely theoretical analysis (Wang et al., 2019; Asadi et al., 2018) to full empirical results on diverse environments Packer et al., 2018) . However, there is a lack of analysis in the middle of this spectrum. On the theoretical side, previous work do not provide analysis for the case when the underlying MDP is relatively complex and requires the policy to be a non-linear function approximator such as a neural network. On the empirical side, there is no common ground between recently proposed empirical benchmarks. This is partially caused by multiple confounding factors for RL generalization that can be hard to identify and separate. For instance, an agent can overfit to the MDP dynamics of the training set, such as for control in Mujoco (Pinto et al., 2017; Rajeswaran et al., 2017) . In other cases, an RNN-based policy can overfit to maze-like tasks in exploration , or even exploit determinism and avoid using observations (Bellemare et al., 2012; Machado et al., 2018) . Furthermore, various hyperparameters such as the batch-size in SGD (Smith et al., 2018) , choice of optimizer (Kingma & Ba, 2014) , discount factor \u03b3 (Jiang et al., 2015) and regularizations such as entropy and weight norms (Cobbe et al., 2018) can also affect generalization. Due to these confounding factors, it can be unclear what parts of the MDP or policy are actually contributing to overfitting or generalization in a principled manner, especially in empirical studies with newly proposed benchmarks. In order to isolate these factors, we study one broad factor affecting generalization that is most correlated with themes in SL, specifically observational overfitting, where an agent overfits due to properties of the observation which are irrelevant to the latent dynamics of the MDP family. To study this factor, we fix a single underlying MDP's dynamics and generate a distribution of MDP's by only modifying the observational outputs. Our contributions in this paper are the following: 1. We discuss realistic instances where observational overfitting may occur and its difference from other confounding factors, and design a parametric theoretical framework to induce observational overfitting that can be applied to any underlying MDP. 2. We study observational overfitting with linear quadratic regulators (LQR) in a synthetic environment and neural networks such as multi-layer perceptrons (MLPs) and convolutions in classic Gym environments. A primary novel result we demonstrate for all cases is that implicit regularization occurs in this setting in RL. We further test the implicit regularization hypothesis on the benchmark CoinRun from using MLPs, even when the underlying MDP dynamics are changing per level. 3. In the Appendix, we expand upon previous experiments by including full training curve and hyperparamters. We also provide an extensive analysis of the convex one-step LQR case under the observational overfitting regime, showing that under Gaussian initialization of the policy and using gradient descent on the training cost, a generalization gap must necessarily exist. The structure of this paper is outlined as follows: Section 2 discusses the motivation behind this work and the synthetic construction to abstract certain observation effects. Section 3 demonstrates numerous experiments using this synthetic construction that suggest implicit regularization is at work. Finally, Section 3.4 tests the implicit regularization hypothesis on CoinRun, as well as ablates various ImageNet architectures and margin metrics in the Appendix. We start by showing an example of observational overfitting in Figure 1 . This example highlights the issues surrounding MDP's with rich, textured observations -specifically, the agent can use any features that are correlated with progress, even those which may not generalize across levels. This is an important issue for vision-based policies, as many times it is not obvious what part of the observation causes an agent to act or generalize. Figure 1: Example of observational overfitting in Sonic from Gym Retro (Nichol et al., 2018) . Saliency maps (Greydanus et al., 2018) highlight (in red) the top-left timer and background objects such as clouds and textures because they are correlated with progress, as they move backwards while agent is moving forwards. The agent could memorize optimal actions for training levels even if its observation was only from the timer, and \"blacking-out\" the timer consistently improved generalization performance (see Appendix A.2.3). Currently most architectures used in model-free RL are simple (with fewer than one million parameters) compared to the much larger and more complex ImageNet architectures used for classification. This is due to the fact that most RL environments studied either have relatively simple and highly structured images (e.g. Atari) compared to real world images, or conveniently do not directly force the agent to observe highly detailed images. For instance in large scale RL such as DOTA2 (OpenAI, 2018) or Starcraft 2 (Vinyals et al., 2017) , the agent observations are internal minimaps pertaining to object xy-locations, rather than human-rendered observations. Several artificial benchmarks (Zhang et al., 2018b; Gamrian & Goldberg, 2019) have been proposed before to portray this notion of overfitting, where an agent must deal with a changing backgroundhowever, a key difference in our work is that we explicitly require the \"background\" to be correlated with the progress rather than loosely correlated (e.g. through determinism between the background and the game avatar) or not at all. This makes a more explicit connection to causal inference (Arjovsky et al., 2019; Heinze-Deml & Meinshausen, 2019; Heinze-Deml et al., 2019) where spurious correlations between ungeneralizable features and progress may make training easy, but are detrimental to test performance because they induce false attributions. Previously, many works interpret the decision-making of an agent through saliency and other network visualizations (Greydanus et al., 2018; on common benchmarks such as Atari. Other recent works such as (Igl et al., 2019) analyze the interactions between noise-injecting explicit regularizations and the information bottleneck. However, our work is motivated by learning theoretic frameworks to capture this phenomena, as there is vast literature on understanding the generalization properties of SL classifiers (Vapnik & Chervonenkis, 1971; McAllester, 1999; Bartlett & Mendelson, 2002) and in particular neural networks (Neyshabur et al., 2015b; Dziugaite & Roy, 2017; Bartlett et al., 2017; Arora et al., 2018c) . For an RL policy with high-dimensional observations, we hypothesize its overfitting can come from more theoretically principled reasons, as opposed to purely good inductive biases on game images. As an example of what may happen in high dimensional observation space, consider linear least squares regression task where given the set X \u2208 R m\u00d7d and Y \u2208 R m , we want to find w \u2208 R d that minimizes X,Y (w) = Y \u2212 Xw 2 where m is the number of samples and d is the input dimension. We know that if X X is full rank (hence d \u2264 m), X,Y (.) has a unique global minimum w * = (X X) \u22121 X Y . On the other hand if X X is not full rank (eg. when m < d), then there are many global minima w * such that Y = Xw * 1 . Luckily, if we use any gradient based optimization to minimize the loss and initialize with w = 0, the solution will only span column spaces of X and converges to minimum 2 norm solution among all global minima due to implicit regularization (Gunasekar et al., 2017) . Thus a high dimensional observation space with a low dimensional state space can induce multiple solutions, some of which are not generalizable to other functions or MDP's but one could hope that implicit regularization would help avoiding this issue. We analyze this case in further detail for the convex one-step LQR case in Section 3.1 and Appendix A.4.3. In the zero-shot framework for RL generalization, we assume there exists a distribution D over MDP's M for which there exists a fixed policy \u03c0 opt that can achieve maximal return on expectation over MDP's generated from the distribution. An appropriate finite training set M train = {M 1 , . . . , M n } can then be created by repeatedly randomly sampling M \u223c D. Thus for a MDP M and any policy \u03c0, expected episodic reward is defined as R M (\u03c0). In many empirical cases, the support of the distribution D is made by parametrized MDP's where some process, given a parameter \u03b8, creates a mapping \u03b8 \u2192 M \u03b8 (e.g. through procedural generation), and thus we may simplify notation and instead define a distribution \u0398 that induces D, which implies a set of samples \u0398 train = {\u03b8 1 , . . . , \u03b8 n } also induces a M train = {M 1 , . . . , M n }, and we may redefine reward as R M \u03b8 (\u03c0) = R \u03b8 (\u03c0). 1 Given any X with full rank X X, it is possible to create many global minima by projecting the data onto As a simplified model of the observational problem from Sonic, we can construct a mapping \u03b8 \u2192 M \u03b8 by first fixing a base MDP M = (S, A, r, T ), which corresponds to state space, action space, reward, and transition. The only effect of \u03b8 is to introduce an additional observation function \u03c6 \u03b8 : S \u2192 O, where the agent receives input from the high dimensional observation space O rather than from the state space S. Thus, for our setting, \u03b8 actually parameterizes a POMDP family which can be thought of as simply a combination of a base MDP M and an observational function \u03c6 \u03b8 , hence Let \u0398 train = {\u03b8 1 , . . . , \u03b8 n } be a set of n i.i.d. samples from \u0398, and suppose we train \u03c0 to optimize reward against is the average reward over this empirical sample. We want to generalize to the distribution \u0398, which can be expressed as the average episode reward R over the full distribution, i.e. Thus we define the generalization gap as J \u0398 (\u03c0) \u2212 J \u0398 (\u03c0). We can model the effects of Figure 1 more generally, not specific to sidescroller games. We assume that there is an underlying state s (e.g. xy-locations of objects in a game), whose features may be very well structured, but that this state has been projected to a high dimensional observation space by \u03c6 \u03b8 . To abstract the notion of generalizable and non-generalizable features, we construct a simple and natural candidate class of functions, where In this setup, f (\u00b7) is a function invariant for the entire MDP population \u0398, while g \u03b8 (\u00b7) is a function dependent on the sampled parameter \u03b8. h is a \"combination\" function which combines the two outputs of f and g to produce a final observation. While f projects this latent data into salient and important, invariant features such as the avatar, monsters, and items, g \u03b8 projects the latent data to unimportant features that do not contribute to extra generalizable information, and can cause overfitting, such as the changing background or textures. A visual representation is shown in Figure  2 . This is a simplified but still insightful model relevant in more realistic settings. For instance, in settings where g \u03b8 does matter, learning this separation and task-identification (Yu et al., 2017; Peng et al., 2018) could potentially help fast adaptation in meta-learning (Finn et al., 2017) . From now on, we denote this setup as the (f, g)-scheme. This setting also leads to more interpretable generalization bounds -Lemma 2 of (Wang et al., 2019) provides a high probability (1 \u2212 \u03b4) bound for the \"intrinsic\" generalization gap when m levels are , where is the Rademacher Complexity under the MDP, where \u03b8 i are the \u03b6 i parameters used in the original work, and the transition T and initialization I are fixed, therefore omitted, to accommodate our setting. The Rademacher Complexity term captures how invariant policies in the set \u03a0 with respect to \u03b8. For most RL benchmarks, this is not interpretable due to multiple confounding factors such as the varying level dynamics. For instance, it is difficult to imagine what behaviors or network weights a policy would possess in order to produce the same total rewards, regardless of changing dynamics. However, in our case, because the environment parameters \u03b8 are only from g \u03b8 , the Rademacher Complexity is directly based on how much the policy \"looks at\" g \u03b8 . More formally, let \u03a0 * be the set of policies \u03c0 * which are not be affected by changes in g \u03b8 ; i.e. \u2207 \u03b8 \u03c0 * (\u03c6 \u03b8 (s)) = 0 \u2200s and thus R \u03b8 (\u03c0 * ) = R const \u2200\u03b8, which implies that the environment parameter \u03b8 has no effect on the reward; Normally in a MDP such as a game, the concatenation operation may be dependent on time (e.g. textures move around in the frame). In the scope of this work, we simplify the concatenation effect and assume h(\u00b7) is a static concatenation, but still are able to demonstrate insightful properties. We note that this inductive bias on h allows explicit regularization to trivially solve this problem, by penalizing a policy's first layer that is used to \"view\" g \u03b8 (s) (Appendix A.1.1), hence we only focus on implicit regularizations. This setting is naturally attractive to analyzing architectural differences, as it is more closely related in spirit to image classifiers and SL. One particular line of work to explain the effects of certain architectural modifications in SL such as overparametrization and residual connections is implicit regularization (Neyshabur et al., 2015a; Gunasekar et al., 2017; Neyshabur, 2017) , as overparametrization through more layer depth and wider layers has proven to have no p -regularization equivalent (Arora et al., 2019) , but rather precondition the dynamics during training. Thus, in order to fairly experimentally measure this effect, we always use fixed hyperparameters and only vary based on architecture. In this work, we only refer to architectural implicit regularization techniques, which do not have a explicit regularization equivalent. Some techniques e.g. coordinate descent (Bradley et al., 2011) are equivalent to explicit 1 -regularization. We first analyze the case of the LQR as a surrogate for what may occur in deep RL, which has been done before for various topics such as sample complexity (Dean et al., 2019) and model-based RL . This is analogous to analyzing linear/logistic regression (Kakade et al., 2008; McAllester, 2003) as a surrogate to understanding extensions to deep SL techniques (Neyshabur et al., 2018a; Bartlett et al., 2017) . In particular, this has numerous benefits -the cost (negative of reward) function is deterministic, and allows exact gradient descent (i.e. the policy can differentiate through the cost function) as opposed to necessarily using stochastic gradients in normal RL, and thus can cleanly provide evidence of implicit regularization. Furthermore, in terms of gradient dynamics and optimization, LQR readily possesses nontrivial qualities compared to linear regression, as the LQR cost is a non-convex function but all of its minima are global minima (Fazel et al., 2018) . To show that overparametrization alone is an important implicit regularizer in RL, LQR allows the use of linear policies (and consequently also allows stacking linear layers) without requiring a stochastic output such as discrete Gumbel-softmax or for the continuous case, a parametrized Gaussian. This is setting able to show that overparametrization alone can affect gradient dynamics, and is not a consequence of extra representation power due to additional non-linearities in the policy. There have been multiple recent works on this linear-layer stacking in SL and other theoretical problems such as matrix factorization and matrix completion (Arora et al., 2018b; a; Gunasekar et al., 2017) , but to our knowledge, we are the first to analyze this case in the context of RL generalization. We explicitly describe setup as follows: for a given \u03b8, we let f (s) = W c \u00b7 s, while g \u03b8 (s) = W \u03b8 \u00b7 s where W c , W \u03b8 are semi-orthogonal matrices, to prevent information loss relevant to outputting the optimal action, as the state is transformed into the observation. Hence, if s t is the underlying state at time t, then the observation is o t = W c W \u03b8 s t and thus the action is a t = Ko t , where K is the policy matrix. While W c remains a constant matrix, we sample W \u03b8 randomly, using the \"level ID\" integer \u03b8 as the seed for random generation. In terms of dimensions, if s is of shape d state , then f also projects to a shape of d state , while g \u03b8 projects to a much larger shape d noise , implying that the observation to the agent is of dimension d signal + d noise . In our experiments, we set as default (d signal , d noise ) = (100, 1000). If P is the unique minimizer of the original cost function, then the unique minimizer of the population . However, if we have a single level, then there exist multiple solutions, \u2200\u03b1. This extra bottom component W \u03b8 P T causes overfitting. In Appendix A.4.3, we show that in the 1-step LQR case (which can be extended to convex losses whose gradients are linear in the input), gradient descent cannot remove this component, and thus overfitting necessarily occurs. Furthermore, we find that increasing d noise increases the generalization gap in the LQR setting. This is empirically verified in Figure 3 using an actual non-convex LQR loss, and the results suggest that the gap scales by O( \u221a d noise ). In terms of overparametrization, we experimentally added more (100 \u00d7 100) linear layers K = K 0 K 1 , ..., K j and increased widths for a 2-layer case (Figure 3) , and observe that both settings reduce the generalization gap, and also reduce the norms (spectral, nuclear, Frobenius) of the final end-to-end policy K, without changing its expressiveness. This suggests that gradient descent under overparametrization implicitly biases the policy towards a \"simpler\" model in the LQR case. A \u2265 1 \u2200A and A * = A F , A 1 . We see that the naive spectral bound diverges at 2 layers, and the weight-counting sums are too loose. As a surrogate model for deep RL, one may ask if the generalization gap of the final end-to-end policy K can be predicted by functions of the layers K 0 , ..., K j . This is an important question as it is a required base case for predicting generalization when using stochastic policy gradient with nonlinear activations such as ReLU or Tanh. From examining the distribution of singular values on K (Appendix A.1.1), we find that more layers does not bias the policy towards a low rank solution in the nonconvex LQR case, unlike (Arora et al., 2018b) which shows this does occur for matrix completion, and in general, convex losses. Ultimately, we answer in the negative: intriguingly, SL bounds have very little predictive power in the RL domain case. To understand why SL bounds may be candidates for the LQR case, we note that as a basic smoothness bound C(K) \u2212 C(K ) \u2264 O( K \u2212 K ) (Appendix A.4) can lead to very similar reasoning with SL bounds. Since our setup is similar to SL in that \"LQR levels\" which may be interpreted as a dataset, we use bounds of the form \u2206\u00b7\u03a6, where \u2206 is a \"macro\" product term \u2206 = Bartlett et al., 2017) . However, the \u03a6 terms increase too rapidly as shown in Figure 3 . Terms such as Frobenius product (Golowich et al., 2018) and Fischer-Rao (Liang et al., 2019) are effective for the SL depth case, but are both ineffective in the LQR depth case. For width, the only product which is effective is the nuclear norm product. In Section 3.1, we find that observational overfitting exists and overparametrization potentially helps in the linear setting. In order to analyze the case when the underlying dynamics are nonlinear, we let M be a classic Gym environment and we generate a M \u03b8 = (M, w \u03b8 ) by performing the exact same (f, g)-scheme as the LQR case, i.e. sampling \u03b8 to produce an observation function We again can produce training/test sets of MDPs by repeatedly sampling \u03b8, and for policy optimization, we use Proximal Policy Gradient (Schulman et al., 2017) . Although bounds on the smoothness term R \u03b8 (\u03c0) \u2212 R \u03b8 (\u03c0 ) affects upper bounds on Rademacher Complexity (and thus generalization bounds), we have no such theoretical guarantees in the Mujoco case as it is difficult to analyze the smoothness term for complicated transitions such as Mujoco's physics simulator. However, in Figure 4 , we can observe empirically that the underlying state dynamics has a significant effect on generalization performance as the policy nontrivially increased test performance such as in CartPole-v1 and Swimmer-v2, while it could not for others. This suggests that the Rademacher complexity and smoothness on the reward function vary highly for different environments. Figure 4: Each Mujoco task is given 10 training levels (randomly sampling g \u03b8 parameters). We used a 2-layer ReLU policy, with 128 hidden units each. Dimensions of outputs of (f, g) were (30, 100) respectively. Even though it is common practice to use basic (2-layer) MLPs in these classic benchmarks, there are highly nontrivial generalization effects from modifying on this class of architectures. Our results in Figures 5 and 6 show that increasing width and depth for basic MLPs can increase generalization and is significantly dependent on the choice of activation, and other implicit regularizations such as using residual layers can also improve generalization. Specifically, switching between ReLU and Tanh activations produces different results during overparametrization. For instance, increasing Tanh layers improves generalization on CartPole-v1, and width increase with ReLU helps on Swimmer-v2. Tanh is noted to consistently improve generalization performance. However, stacking Tanh layers comes at a cost of also producing vanishing gradients which can produce subpar training performance, for e.g. HalfCheetah. To allow larger depths, we use ReLU residual layers, which also improves generalization and stabilizes training. Previous work did not find such an architectural pattern for GridWorld environments, suggesting that this effect may exist primarily for observational overfitting cases. While there have been numerous works which avoid overparametrization on simplifying policies (Rajeswaran et al., 2017; Mania et al., 2018) or compactifying networks (Choromanski et al., 2018; Gaier & Ha, 2019) , we instead find that there are generalization benefits to overparametrization even in the nonlinear control case. From the above results with MLPs, one may wonder if similar results may carry to convolutional networks, as they are widely used for vision-based RL tasks. As a ground truth reference for our experiment, we the canonical networks proven to generalize well in the dataset CoinRun, which are from worst to best, NatureCNN Mnih et al. (2013 ), IMPALA Espeholt et al. (2018 , and IMPALA-LARGE (IMPALA with more residual blocks and higher convolution depths), which have respective parameter numbers (600K, 622K, 823K). We setup a similar (f, g)-scheme appropriate for the inductive bias of convolutions, by passing the vanilla Gym 1D state corresponding to joint locations and velocities, through multiple deconvolutions. We do so rather than using the RGB image from env.render() to enforce that the actual state is indeed low dimensional and minimize complications in experimentation, as e.g. inference of velocity information would require frame-stacking. Specifically in our setup, we project the actual state to a fixed length, reshaping it into a square, and replacing f and g \u03b8 both with the same orthogonally-initialized deconvolution architecture to each produce a 84 \u00d7 84 image (but g \u03b8 's network weights are still generated by \u03b8 1 , ..., \u03b8 m similar to before). We combine the two outputs by using one half of the \"image\" from f , and one half from g \u03b8 , as shown back in Figure 2 . shows that the same ranking between the three architectures exists as well on the GymDeconv dataset. We show that generalization ranking among NatureCNN/IMPALA/IMPALA-LARGE remains the same regardless of whether we use our synthetic constructions or CoinRun. This suggests that the RL generalization quality of a convolutional architecture is not limited to real world data, as our test purely uses numeric observations, which are not based on a human-prior. From these findings, one may conjecture that these RL generalization performances are highly correlated and may be due to common factors. One of these factors we suggest is due to implicit regularization. In order to support this claim, we perform a memorization test by only showing g \u03b8 's output to the policy. This makes the dataset impossible to generalize to, as the policy network cannot invert every single observation function {g \u03b81 (\u00b7), g \u03b82 (\u00b7), ..., g \u03b8n (\u00b7)} simultaneously. also constructs a memorization test for mazes and grid-worlds, and showed that more parameters increased the memorization ability of the policy. While it is intuitive that more parameters would incur more memorization, we show in Figure 8 that this is perhaps not a complete picture when implicit regularization is involved. Using the underlying MDP as a Swimmer-v2 environment, we see that NatureCNN, IMPALA, IMPALA-LARGE have reduced memorization performances. IMPALA-LARGE, which has more depth parameters and more residual layers (and thus technically has more capacity), memorizes less than IMPALA due its inherent inductive bias. While memorization performance is dampened in 8, we perform another deconvolution memorization test using an LQR as the underlying MDP in Appendix A.1.1 that shows that there can exist specific hard limits to memorization, which also follows the same ranking above. We further test our overparametrization hypothesis from Sections 3.1, 3.2 to the CoinRun benchmark, using unlimited levels for training. For MLP networks, we downsized CoinRun from native 64 \u00d7 64 to 32 \u00d7 32, and flattened the 32 \u00d7 32 \u00d7 3 image for input to an MLP. Two significant differences from the synthetic cases are that 1. Inherent dynamics are changing per level in CoinRun, and 2. The relevant and irrelevant CoinRun features change locations across the 1-D input vector. Regardless, in Figure 9 , we show that overparametrization can still improve generalization in this more realistic RL benchmark, much akin to (Neyshabur et al., 2018b) which showed that overparametrization for MLP's improved generalization on 32 \u00d7 32 \u00d7 3 CIFAR-10. Figure 9: Overparametrization improves generalization for CoinRun. While we also extend the case of large-parameter convolutional networks using ImageNet networks in Appendix A.2.1, an important question is how to predict the generalization gap only from the training phase. A particular set of metrics, popular in the SL community are margin distributions (Jiang et al., 2018; Bartlett et al., 2017) , as they deal with the case for softmax outputs which do not explicitly penalize the weight norm of a network, by normalizing the \"confidence\" margin of the logit outputs. While using margins on state-action pairs (from an on-policy replay buffer) is not technically rigorous, one may be curious to see if they have predictive power, especially as MLPs are relatively simple to norm-bound. We plotted these margin distributions in Appendix A.2.2, but found that the weight norm bounds used in SL are simply too dominant for this RL case. This, with the bound results found earlier for the LQR case, suggests that current norm bounds are simply too loose for the RL case even though we have shown overparametrization helps generalization in RL, and hopefully this motivates more of the study of such theory. We have identified and isolated a key component of overfitting in RL as the particular case of \"observational overfitting\", which is particularly attractive for studying architectural implicit regularizations. We have analyzed this setting extensively, by examining 3 main components: 1. The analytical case of LQR and linear policies under exact gradient descent, which lays the foundation for understanding theoretical properties of networks in RL generalization. 2. The empirical but principled Projected-Gym case for both MLP and convolutional networks which demonstrates the effects of neural network policies under nonlinear environments. 3. The large scale case for CoinRun, which can be interpreted as a case where relevant features are moving across the input, where empirically, MLP overparametrization also improves generalization. We noted that current network policy bounds using ideas from SL are unable to explain overparametrization effects in RL, which is an important further direction. In some sense, this area of RL generalization is an extension of static SL classification from adding extra RL components. For instance, adding a nontrivial \"combination function\" between f and g \u03b8 that is dependent on time (to simulate how object pixels move in a real game) is both an RL generalization issue and potentially video classification issue, and extending results to the memory-based RNN case will also be highly beneficial. Furthermore, it is unclear whether such overparametrization effects would occur in off-policy methods such as Q-learning and also ES-based methods. In terms of architectural design, recent works (Jacot et al., 2018; Garriga-Alonso et al., 2019; Lee et al., 2019) have shed light on the properties of asymptotically overparametrized neural networks in the infinite width and depth cases and their performance in SL. Potentially such architectures (and a corresponding training algorithm) may be used in the RL setting which can possibly provide benefits, one of which is generalization as shown in this paper. We believe that this work provides an important initial step towards solving these future problems. We further verify that explicit regularization (norm based penalties) also reduces generalization gaps. However, explicit regularization may be explained due to the bias of the synthetic tasks, since the first layer's matrix may be regularized to only \"view\" the output of f , especially as regularizing the first layer's weights substantially improves generalization. Figure A2 : Explicit Regularization on layer norms. We provide another deconvolution memorization test, using an LQR as the underlying MDP. While fg-Gym-Deconv shows that memorization performance is dampened, this test shows that there can exist specific hard limits to memorization. Specifically, NatureCNN can memorize 30 levels, but not 50; IMPALA can memorize 2 levels but not 5; IMPALA-LARGE cannot memorize 2 levels at all. Training, Test Rewards (f = NULL) IMPALA_2_levels IMPALA_5_levels IMPALA_30_levels IMPALA_LARGE_2_levels NatureCNN_30_levels NatureCNN_50_levels Figure A3 : Deconvolution memorization test using LQR as underlying MDP. For reference, we also extend the case of large-parameter convolutional networks using ImageNet networks. We experimentally verify in Table 1 that large ImageNet models perform very differently in RL than SL. We note that default network with the highest test reward was IMPALA-LARGE-BN (IMPALA-LARGE, with Batchnorm) at \u2248 5.5 test score. In order to verify that this is inherently a feature learning problem rather than a combinatorial problem involving objects, such as in (Santoro et al., 2018) , we show that state-of-the-art attention mechanisms for RL such as Relational Memory Core (RMC) using pure attention on raw 32 \u00d7 32 pixels does not perform well here, showing that a large portion of generalization and transfer must be based on correct convolutional setups. We provide the training/testing curves for the ImageNet/large convolutional models used. Note the following: 1. RMC32x32 projects the native image from CoinRun from 64 \u00d7 64 to 32 \u00d7 32, and uses all pixels as components for attention, after adding the coordinate embedding found in (Santoro et al., 2018) . Optimal parameters were (mem slots = 4, head size = 32, num heads = 4, num blocks = 2, gate style = 'memory'). 2. Auxiliary Loss in ShakeShake was not used during training, only the pure network. 3. VGG-A is a similar but slightly smaller version of VGG-16. A key question is how to predict the generalization gap only from the training phase. A particular set of metrics, popular in the SL community are margin distributions (Jiang et al., 2018; Bartlett et al., 2017) , as they deal with the case for softmax categorical outputs which do not explicitly penalize the weight norm of a network, by normalizing the \"confidence\" margin of the logit outputs. While using margins on state-action pairs (from an on-policy replay buffer) is not technically rigorous, one may be curious to see if they have predictive power, especially as MLP's are relatively simple to norm-bound, and as seen from the LQR experiments, the norm of the policy may be correlated with the generalization performance. For a policy, the the margin distribution will be defined as (x, y) \u2192 , where F \u03c0 (x) y is the logit value (before applying softmax) of output y given input x, and S is the matrix of states in the replay buffer, and R \u03c0 is a norm-based Lipschitz measure on the policy network logits. In general, R \u03c0 is a bound on the Lipschitz constant of the network but can also be simply expressions which allow the margin distribution to have high correlation with the generalization gap. Thus, we use measures inspired by recent literature in SL in which we designate Spectral-L1, Distance, and Spectral-Frobenius measures for R \u03c0 , and we replace the classical supervised learning pair (x, y) = (s, a) with the state-action pairs found on-policy. The expressions for R \u03c0 (after removing irrelevant constants) are as follows, with their analogous papers: 1. Spectral-L1 measure: Bartlett et al., 2017) 2. Distance measure: Nagarajan & Kolter, 2019) 3. Spectral-Fro measure: We verify in Figure A5 , that indeed, simply measuring the raw norms of the policy network is a poor way to predict generalization, as it generally increases even as training begins to plateau. This is inherently because the softmax on the logit output does not penalize arbitrarily high logit values, and hence proper normalization is needed. The margin distribution converges to a fixed distribution even long after training has plateaued. However, unlike SL, the margin distribution is conceptually not fully correlated with RL generalization on the total reward, as a policy overconfident in some state-action pairs does not imply bad testing performance. This correlation is stronger if there are Lipschitz assumptions on state-action transitions, as noted in (Wang et al., 2019) . For empirical datasets such as CoinRun, a metric-distance between transitioned states is ill-defined however. Nevertheless, the distribution over the on-policy replay buffer at each policy gradient iteration is a rough measure of overall confidence. We note that there are two forms of modifications, network dependent (explicit modifications to the policy -norm regularization, dropout, etc.) and data dependent (modifications only to the data in the replay buffer -action stochasticity, data augmentation, etc.). Ultimately however, we find that current norm measures R \u03c0 become too dominant in the fraction, leading to the monotonic decreases in the means of the distributions as we increase parametrization. Figure A6 : Margin Distributions at the end of training. In the Gym-Retro benchmark using Sonic (Nichol et al., 2018) , the agent is given 47 training levels with rewards corresponding to increases in horizontal location. The policy is trained until 5k reward. At test time, 11 unseen levels are partitioned into starting positions, and the rewards are measured and averaged. We briefly mention that the agent strongly overfits to the scoreboard (i.e. an artifact correlated with progress in the level), which may be interpreted as part of the output of g \u03b8 (\u00b7). In fact, the agent is still able to train to 5k reward from purely observing the timer as the observation. By blacking out this scoreboard with a black rectangle, we see an increase in test performance. Settings IMPALA NatureCNN Blackout 1250 \u00b1 40 1141 \u00b1 40 NoBlackout 1130 \u00b1 40 1052 \u00b1 40 (Fazel et al., 2018) for the the full solution and notations. Using the same notation (A, B, Q, R), denote C(K) = x0\u223cD x T 0 P K x 0 as the cost and u t = \u2212Kx t as the policy, where P K satisfies the infinite case for the Lyapunov equation: We may calculate the precise LQR cost by vectorizing (i.e. flattening) both sides' matrices and using the Kroncker product \u2297, which leads to a linear regression problem on P K , which has a precise solution, implementable in TensorFlow: Parameter Generation A Orthogonal initialization, scaled 0.99 Orthogonal Initialization, scaled 0.5 The basis for producing f, g \u03b8 outputs is due to using batch matrix multiplication operations, or \"BMV\", where the same network architecture uses different network weights for each batch dimension, and thus each entry in a batchsize of B will be processed by the same architecture, but with different network weights. This is to simulate the effect of g \u03b8i . The numeric ID i of the environment is used as an index to collect a specific set of network weights \u03b8 i from a global memory of network weights (e.g. using tensorflow.gather). We did not use nonlinear activations for the BMV architectures, as they did not change the outcome of the results. Architecture Setup BMV-Deconv (filtersize = 2, stride = 1, outchannel = 8, padding = \"VALID\") (filtersize = 4, stride = 2, outchannel = 4, padding = \"VALID\") (filtersize = 8, stride = 2, outchannel = 4, padding = \"VALID\") (filtersize = 8, stride = 3, outchannel = 3, padding = \"VALID\") BMV-Dense f : Dense 30, g : Dense 100 A.3.3 IMAGENET MODELS For the networks used in the supervised learning tasks, we direct the reader to the following repository: https://github.com/tensorflow/models/blob/master/research/ slim/nets/nets_factory.py. We also used the RMC: deepmind/sonnet/blob/ master/sonnet/python/modules/relational_memory.py See (Cobbe et al., 2018) for the default parameters used for CoinRun. We only varied nminibatches in order to fit memory onto GPU. We also did not use RNN additions, in order to measure performance only from the feedforward network -the framestacking/temporal aspect is replaced by the option to present the agent velocity in the image. In this section, we use notation consistent with (Fazel et al., 2018) for our base proofs. However, in order to avoid confusion with a high dimensional policy K we described in 3.1, we denote our low dimensional base policy as P and state as s t rather than x t . Let \u00b7 be the spectral norm of a matrix (i.e. largest singular value). Suppose C(P ) was the infinite horizon cost for an (A, B, Q, R)-LQR where action a t = \u2212P \u00b7 s t , s t is the state at time t, state transition is s t+1 = A \u00b7 s t + B \u00b7 a t , and timestep cost is s T t Qs t + a T t Ra t . C(P ) for an infinite horizon LQR, while known to be non-convex, still possess the property that when \u2207C(P * ) = 0, P * is a global minimizer, or the problem statement is rank deficient. To ensure that our cost C(P ) always remains finite, we restrict our analysis when P \u2208 P, where P = {P : P \u2264 \u03b1 and A \u2212 BP \u2264 1} for some constant \u03b1, by choosing A, B and the initialization of P appropriately, using the hyperparameters found in A.3.1. We further define the observation modified cost as C(K; W \u03b8 ) = C K W c W \u03b8 T . As described in Lemma 16 of (Fazel et al., 2018) , we define and T P = sup X T P (X) X over all non-zero symmetric matrices X. Lemma 27 of (Fazel et al., 2018) provides a bound on the difference C(P ) \u2212 C(P ) for two different policies P, P when LQR parameters A, B, Q, R are fixed. During the derivation, it states that when P \u2212 P \u2264 min \u03c3min(Q)\u00b5 4C(P ) B ( A\u2212BP +1) , P , then: C(P ) \u2212 C(P ) \u2264 2 T P (2 P R P \u2212 P + R P \u2212 P 2 )+ 2 T P 2 2 B ( A \u2212 BP + 1) P \u2212 P P 2 R Lemma 17 also states that: where Assuming that in our problem setup, x 0 , Q, R, A, B were fixed, this means many of the parameters in the bounds are constant, and thus we conclude: C(P ) \u2212 C(P ) \u2264 O C(P ) 2 P 2 P \u2212 P ( A \u2212 BP + B + 1) + P P \u2212 P 2 Since we assumed A \u2212 BP \u2264 1 or else T P (X) is infinite, we thus collect the terms: Since \u03b1 is a bound on P for P \u2208 P, note that P 2 P \u2212 P + P P \u2212 P 2 = P \u2212 P ( P 2 + P + P \u2212 P ) \u2264 P \u2212 P ( P 2 + P ( P + P ) \u2264 (3\u03b1 2 ) P \u2212 P From (11), this leads to the bound: Note that this directly implies a similar bound in the high dimensional observation case -in particular, We first start with a convex cost 1-step LQR toy example under this regime, which shows that linear components such as \u03b2 0 W \u03b8 T cannot be removed from the policy by gradient descent dynamics to improve generalization. To shorten notation, let W c \u2208 R n\u00d7n and W \u03b8 \u2208 R p\u00d7n , where n p. This is equivalent to setting d signal = d state = n and d noise = p, and thus the policy K \u2208 R n\u00d7(n+p) . In the 1-step LQR, we allow s 0 \u223c N (0, I), a 0 = K W c W \u03b8 s 0 and s 1 = s 0 + a 0 with cost 1 2 s 1 2 , then C(K; W \u03b8 ) = E s0 1 2 and Define the population cost as C(K) := E W \u03b8 [C(K; W \u03b8 )]. Let the notation O(p, n) denote the following set of orthogonal matrices: O(p, n) = {W \u2208 R p\u00d7n : W T W = I} . We use the shorthand O(n) = O(n, n). Proposition 1. Suppose that W \u03b8 \u223c Unif(O(p, n)) and W c \u223c Unif(O(n)). Then Here, the expectation is over the randomness of the samples {W i } m i=1 and the initalization K 0 . The contribution from E 1 is due to the generalization error of the minimum-norm stationary point of C m (\u00b7; {W i }). The contribution from E 2 is due to the full-rank initialization of K 0 . We remark that our proof specifically relies on the rank of the Hessian as m increases, rather than a more common concentration inequality used in empirical risk minimization arguments, which leads to a 1 \u221a m scaling. Furthermore, the above expression for E[C(K \u221e )] does not scale increasingly with poly(p) for the convex 1-Step LQR case, while empirically, the non-convex infinite LQR case does indeed increase from increasing the noise dimension p (as shown in Section 3.1). Interestingly, this suggests that there is an extra contribution from the non-convexity of the cost, where the observation-modified gradient dynamics tends to reach worse optima. A.4.3.2 PROOF OF THEOREM 1 Fix integers n, p with p \u2265 n and suppose that n divides p. Draw a random W \u2208 O(p) uniformly from the Haar measure on O(p) and divide W column-wise into W 1 , W 2 , ..., W p/n (that is W i \u2208 R p\u00d7n , W"
}