{
    "title": "Skx6WaEYPH",
    "content": "In this paper, we study the adversarial attack and defence problem in deep learning from the perspective of Fourier analysis. We first explicitly compute the Fourier transform of deep ReLU neural networks and show that there exist decaying but non-zero high frequency components in the Fourier spectrum of neural networks. We then demonstrate that the vulnerability of neural networks towards adversarial samples can be attributed to these insignificant but non-zero high frequency components. Based on this analysis, we propose to use a simple post-averaging technique to smooth out these high frequency components to improve the robustness of neural networks against adversarial attacks. Experimental results on the ImageNet and the CIFAR-10 datasets have shown that our proposed method is universally effective to defend many existing adversarial attacking methods proposed in the literature, including FGSM, PGD, DeepFool and C&W attacks. Our post-averaging method is simple since it does not require any re-training, and meanwhile it can successfully defend over 80-96% of the adversarial samples generated by these methods without introducing significant performance degradation (less than 2%) on the original clean images. Although deep neural networks (DNN) have shown to be powerful in many machine learning tasks, Szegedy et al. (2013) found that they are vulnerable to adversarial samples. Adversarial samples are subtly altered inputs that can fool the trained model to produce erroneous outputs. They are more commonly seen in image classification task and typically the perturbations to the original images are so small that they are imperceptible to human eye. Research in adversarial attacks and defences is highly active in recent years. In the attack side, many attacking methods have been proposed (Szegedy et al., 2013; Goodfellow et al., 2014; Papernot et al., 2016a; Moosavi-Dezfooli et al., 2016; Kurakin et al., 2016; Madry et al., 2017; Carlini and Wagner, 2017a; Chen et al., 2017; Alzantot et al., 2018; , with various ways to generate effective adversarial samples to circumvent new proposed defence methods. However, since different attacks usually are effective to different defences or datasets, there is no consensus on which attack is the strongest. Hence for the sake of simplicity, in this work, we will evaluate our proposed defence approach against four popular attacks for empirical analysis. In the defence side, various defence mechanisms have also been proposed, including adversarial training (Rozsa et al., 2016; Kurakin et al., 2016; Tram\u00e8r et al., 2017; Madry et al., 2017) , network distillation (Papernot et al., 2016b) , gradient masking (Nguyen and Sinha, 2017) , adversarial detection (Feinman et al., 2017) and adding modifications to neural networks (Xie et al., 2017) . Nonetheless, many of them were quickly defeated by new types of attacks (Carlini and Wagner, 2016; 2017b; c; a; Alzantot et al., 2018) . Madry et al. (2017) tried to provide a theoretical security guarantee for adversarial training by a min-max loss formulation, but the difficulties in non-convex optimization and in finding the ultimate adversarial samples for training may loosen this robustness guarantee. As a result, so far there is no defence that is universally robust to all adversarial attacks. Along the line of researches, there were also investigations into the properties and existence of adversarial samples. Szegedy et al. (2013) first observed the transferability of adversarial samples across models trained with different hyper-parameters and across different training sets. They also attributed the adversarial samples to the low-probability blind spots in the manifold. In (Goodfellow et al., 2014) , the authors explained adversarial samples as \"a result of models being too linear, rather than too nonlinear.\" In (Papernot et al., 2016) , the authors showed the transferability occurs across models with different structures and even different machine learning techniques in addition to neural networks. In summary, the general existence and transferability of adversarial samples are well known but the reason of adversarial vulnerability still needs further investigation. Generally speaking, when we view neural network as a multivariate function f (x) of input x, if a small imperceptible perturbation \u2206x leads to a huge fluctuation \u2206f (x), the large quantity \u2206f (x)/\u2206x essentially corresponds to high frequency components in the Fourier spectrum of f (x). In this paper, we will start with the Fourier analysis of neural networks and elucidate why there always exist some decaying but nonzero high frequency response components in neural networks. Based on this analysis, we show that neural networks are inherently vulnerable to adversarial samples due to the underlying model structure. Next, we propose a simple post-averaging method to tackle this problem. Our proposed method is fairly simple since it works as a post-processing stage of any given neural network models and it does not require re-training the networks at all. Furthermore, we have evaluated the post-averaging method against four popular adversarial attacking methods and our method is shown to be universally effective in defending all examined attacks. Experimental results on the ImageNet and the CIFAR-10 datasets have shown that our simple post-averaging method can successfully defend over 80-96% of the adversarial samples generated by these attacks with little performance degradation (less than 2%) on the original clean images. In order to understand the behaviour of adversarial samples, it is essential to find the Fourier transform of neural networks. Fortunately, for some widely used neural networks, namely fully-connected neural networks using ReLU activation functions, we may explicitly derive their Fourier transform under some minor conditions. As we will show, these theoretical results will shed light on how adversarial samples happen in neural networks. As we know, any fully-connected ReLU neural networks (prior to the softmax layer) essentially form piece-wise linear functions in input space. Due to space limit, we will only present the main results in this section and the proofs and more details may be found in Appendix. Definition 2.1. A piece-wise linear function is a continuous function f : R n \u2212 \u2192 R such that there are some hyperplanes passing through origin and dividing R n into M pairwise disjoint regions R m , (m = 1, 2, ..., M ), on each of which f is linear: Composition of a piece-wise linear function with a ReLU activation function is also a piece-wise linear function. Theorem 2.3. The output of any hidden unit in an unbiased fully-connected ReLU neural network is a piece-wise linear function. This is straightforward because the input to any hidden node is a linear combination of piece-wise linear functions and this input is composed with the ReLU activation function to yield the output, which is also piece-wise linear. However, each region R m is the intersection of a different number of half-spaces, enclosed by various hyperplanes in R n . In general, these regions R m (m = 1, \u00b7 \u00b7 \u00b7 , M ) do not have simple shapes. For the purpose of mathematical analysis, we need to decompose each region into a union of some well-defined shapes having a uniform form, which is called infinite simplex. Definition 2.4. Let V = {v 1 , v 2 , ..., v n } be a set of n linearly independent vectors in R n . An infinite simplex, R + V , is defined as the region linearly spanned by V using only positive weights: Theorem 2.5. Each piece-wise linear function f (x) can be formulated as a summation of some simpler functions: , each of which is linear and non-zero only in an infinite simplex as follows: where V l is a set of n linearly independent vectors, and w l is a weight vector. In practice, we can always assume that the input to neural networks, x, is bounded. As a result, for computational convenience, we may normalize all inputs x into the unit hyper-cube, U n = [0, 1] n . Obviously, this assumption can be easily incorporated into the above analysis by multiplying each is the Heaviside step function. Alternatively, we may simplify this term by adding n 2 additional hyperplanes to further split the input space to ensure all the elements of x do not change signs within each region R + Vq . In this case, within each region R + Vq , the largest absolute value among all elements of x is always achieved by a specific element, which is denoted as r q . In other words, the dimension x rq achieves the largest absolute value inside R + Vq . Similarly, the normalized piece-wise linear function may be represented as a summation of some functions: f (x) = Q q=1 g q (x), where each g q (x) (q = 1, 2, \u00b7 \u00b7 \u00b7 , Q) has the following form: For every V q , there exists an n \u00d7 n invertible matrix A q to linearly transform all vectors of V q into standard basis vectors e i in R n . As a result, each function g q (x) may be represented in terms of standard bases V * = {e 1 , \u00b7 \u00b7 \u00b7 , e n } as follows: q . Lemma 2.6. Fourier transform of the following function: 0 otherwise may be presented as: where \u03c9 r is the r-th component of frequency vector \u03c9 (r = 1, \u00b7 \u00b7 \u00b7 , n), and \u03c9 0 = 0. Finally we derive the Fourier transform of fully-connected ReLU neural networks as follows. Theorem 2.7. The Fourier transform of the output of any hidden node in a fully-connected unbiased 1 ReLU neural network may be represented as Obviously, neural networks are the so-called approximated bandlimited models as defined in (Jiang, 2019) , which have decaying high frequency components in Fourier spectrum. Theorem 2.7 further suggests that the matrices A \u22121 q may contribute to the high frequency components when the corresponding region R + Vq are too small. This is clear because the determinant of A q is proportional to the volume of R + Vq in R n . In summary, the high frequency components of neural networks are mostly attributed to these tiny regions in the input space. As we will show later, these small regions may be explicitly exploited to generate adversarial samples for neural networks. As shown in Theorem 2.3, neural network may be viewed as a sequential division of the input space into many small regions, as illustrated in Figure 1 . Each layer is a further division of the existing regions from the previous layers, with each region being divided differently. Hence a neural network with multiple layers would result in a tremendous amount of sub-regions in the input space. For example, when cutting an n-dimensional space using N hyperplanes, the maximum number of regions may be computed as For a hidden layer of N = 1000 nodes and input dimension is n = 200, the maximum number of regions is roughly equal to 10 200 . In other words, even a middle-sized neural network can partition input space into a huge number of sub-regions, which can easily exceed the total number of atoms in the universe. When we learn a neural network, we can not expect there is at least one training sample inside each region. For those regions that do not have any training sample, the resultant linear functions in them may be arbitrary since they do not contribute to the training objective function at all. Of course, most of these regions are extremely small in size. When we measure the expected loss function over the entire space, their contributions are negligible since the chance for a randomly sampled point to fall into these tiny regions is extremely small. However, adversarial attack is imposing a new challenge since adversarial samples are not naturally sampled. Given that the total number of regions is huge, those tiny regions are almost everywhere in the input space. For any data point in the input space, we almost surely can find such a tiny region in proximity where the linear function is arbitrary. If a point inside this tiny region is selected, the output of the neural network may be unexpected. We believe that these tiny unlearned regions may be a major reason why neural networks are vulnerable to adversarial samples. In layered deep neural networks, the linear functions in all regions are not totally independent. If we use v (l) to denote the weight matrix in layer l, the resultant linear weight w k in eq. (2) is actually the sum of all concatenated v (l) along all active paths. When we make a small perturbation \u2206x to any input x, the fluctuation in the output of any hidden node can be approximated represented as: where N denotes the total number of hyperplanes to be crossed when moving x to x + \u2206x. In any practical neural network, we normally have at least tens of thousands of hyperplanes crossing the hypercube U n = [0, 1] n . In other words, for any input x in a high-dimensional space, a small perturbation can always easily cross a large number of hyperplanes to enter a tiny unlearned region. When N is fairly large, the above equation indicates that the output of a neural network can still fluctuate dramatically even after all weight vectors are regularized by L 1 or L 2 norm. As a reference, we have verified this on some ImageNet data using a VGG16 model. When PGD is used to generate adversarial samples with average perturbation ||\u2206x|| 2 \u2264 0.35, which is extremely small perturbation since x has over a hundred thousand dimensions on ImageNet, we have observed that in average about N = 5278 hyperplanes are crossed per layer even after such a small perturbation is added. At last, since the ubiquitous existence of unlearned tiny regions is an intrinsic property of neural networks given its current model structure, we believe that adversarial training strategies will not be sufficient to completely get rid of adversarial samples. In principle, neural networks must be strictly bandlimited to filter out those decaying high frequency components in order to completely eliminate all adversarial samples. We definitely need more research efforts to figure out how to do this effectively and efficiently for neural networks. 3 THE PROPOSED DEFENCE APPROACH: POST-AVERAGING 3.1 POST-AVERAGING In this paper, we propose a simple post-processing method to smooth out those high frequency components as much as possible, which relies on a simple idea similar to moving-average in onedimensional sequential data. Instead of generating prediction merely from one data point, we use the averaged value within a small neighborhood around the data point, which is called post-averaging here. Mathematically, the post-averaging is computed as an integral over a small neighborhood centered at the input: where x is the input and f (x) represents the output of the neural network, and C denotes a small neighborhood centered at the origin and V C denotes its volume. When we choose C to be an n-sphere in R n of radius r, we may simply derive the Fourier transform of f C (x) as follows: where J n 2 (\u00b7) is the first kind Bessel function of order n/2. Since the Bessel functions, J \u03bd (\u03c9), decay with rate 1/ \u221a \u03c9 as |\u03c9| \u2192 \u221e (Watson, 1995), we have as |\u03c9| \u2192 \u221e. Therefore, if r is chosen properly, the post-averaging operation can significantly bandlimit neural networks by smoothing out high frequency components. Note that the similar ideas have been used in (Jiang et al., 1999; Jiang and Lee, 2003) to improve robustness in speech recognition. However, it is intractable to compute the above integral for any meaningful neural network used in practical applications. In this work, we propose to use a simple numerical method to approximate it. For any input x, we select K points in the neighborhood C centered at x, i.e. {x 1 , x 2 , \u00b7 \u00b7 \u00b7 , x K } , to approximately compute the integral as Obviously, in order to defend against adversarial samples, it is important to have samples outside the current unlearned tiny region. In the following, we use a simple sampling method based on directional vectors. To generate a relatively even set of samples for eq. (7), we first determine some directional vectorsv, and then move the input x along these directions using several step sizes within the sphere of radius r: , \u00b1r], andv is a selected unit-length directional vector. For each selected direction, we generate six samples within C along both the positive and the negative directions to ensure efficiency and even sampling. We use this implementation for the convenience to extend with different types of sampling strategies. We tried several direction sampling strategies, including using the directions towards the closest region boundaries, and found that the simple random direction sampling gives the best performance. In this sampling method, we fill the directional vectors with random numbers generated from a standard normal distribution, and then normalize them to have unit length. In this section, we evaluate the above post-averaging method on defending against several popular adversarial attacking methods. \u2022 Dataset: We evaluated our method on both the ImageNet (Russakovsky et al., 2015) and CIFAR-10 (Krizhevsky et al., 2009) datasets. Since our proposed post-averaging method does not need to re-train neural networks, we do not need to use any training data in our experiments. For evaluation purpose, we use the validation set of the ImageNet dataset. The validation set consists of 50000 images labelled into 1000 categories. For computational efficiency, we randomly choose 5000 images from the ImageNet validation set and evaluate our model on these 5000 images. For the CIFAR-10 dataset, we use the full test set, which consists of 10000 images labelled into 10 categories. \u2022 Target model: For model on ImageNet, we use a pre-trained ResNet-152 (He et al., 2016) network that is available from PyTorch, while for CIFAR-10, we use a pre-trained ResNet-110 network from Yerlan Idelbayev 2 . In our experiments, we directly use these pre-trained models without any modification. \u2022 Source of adversarial attacking methods: We use Foolbox , an open source tool box to generate adversarial samples using different adversarial attacking methods. In this work, we tested our method against four popular attacking methods in the literature: Fast Gradient Sign method (FGSM) (Goodfellow et al., 2014), Projected Gradient Descent (PGD) method (Kurakin et al., 2016; Madry et al., 2017) , DeepFool (DF) attack method (Moosavi-Dezfooli et al., 2016) and Carlini & Wagner (C&W) L2 attack method (Carlini and Wagner, 2017a) . We used these attack methods in their default settings. \u2022 Threat model: In our experiments, we use an l \u221e norm to constrain the allowed perturbation distance. For each experiment, we define: \u2022 Clean set: The dataset that consists of the original images from ImageNet or CIFAR-10. \u2022 Attacked set: For every correctly classified image in the Clean set, if an adversarial sample is successfully generated under the attacking criteria, the original sample is replaced with the adversarial sample; if no adversarial sample is found, the original sample is kept in the dataset. Meanwhile, all the misclassified images are kept in the dataset without any change. Therefore the Attacked set has the same number of images as the clean set. In our experiments, we evaluate the original network and the network defended by post-averaging on both the Clean and the Attacked sets. The performance is measured in terms of : \u2022 Accuracy: number of correctly classified images over the whole dataset. \u2022 Defence rate: number of successfully defended adversarial samples over the total number of adversarial samples in the Attacked set. By \"successfully defended\", it refers to the case where an adversarial sample is correctly classified after the original model is defended by the post-averaging approach. Table 1 shows the performance of our defence approach against different attacking methods. In this table, the samples for post-averaging are selected within an n-sphere of radius r as in eq.(8), with K = 15 different directions. Thus results in a total of 15 \u00d7 2 \u00d7 3 + 1 = 91 samples (including the input) for each input image to be used in eq. (7). Moreover, all the adversarial samples generated are restricted to be within the perturbation range = 8 /255. We show the top-1 accuracy of the original model and the defended model on both the Clean and the Attacked set respectively, as well as the defence rate of the defended model. Besides, we also show the number of adversarial samples successfully generated by each attacking method in the last column. From Table 1 , we can see that our proposed defence approach is universally robust to all of the attacking methods we have examined. It has achieved above 80-96% defence rates in all the experiments with only a minor performance degradation in the Clean set (less than 2%). Especially on the ImageNet dataset, our method is able to defend about 95% of the adversarial samples. However, an interesting observation from the experimental results is that the defence rate in the CIFAR-10 dataset is lower than the usually more challenging ImageNet dataset. We think this may be because data points are sparser in the ImageNet space than in the CIFAR-10 space, as ImageNet has a much larger dimensionality. Generally, using a larger sampling radius r can increase the chance of moving out of the unlearned regions as we desired, but it will also introduce more noise that can harm the prediction accuracy; On the other hand, using a smaller sampling radius r can reduce the performance degradation but it may not be sufficient to defend against adversarial samples. The optimal value for r varies with different datasets due to their dimensionality and data sparsity. In experiments, we found that r = 30 for ImageNet and r = 6 for CIFAR-10 achieved relatively better performance. Figure 2 shows how the model defence rate on ImageNet varies with different r. As shown in the figure, the optimal value for r also varies in different attacking methods, but the performance variations are small. In general, our model retains high defence rate throughout the r range [15, 30] . We also tested the effect of K, the number of sampling directions used, on the model performance. From Table 2 , we can see that our model performance is not very sensitive to K. It is able to achieve a good defence rate with only K = 6, that is, 37 samples used for each input image. In implementation, these samples can be easily packed into a mini-batch for fast computation in GPUs. When running on the same machine, we measured the averaged inference time for a single input image on the original network as 0.04 seconds, while the inference time for our models with different K are shown in Table 2 . By comparison, we can know that the inference time after adding post-averaging is roughly 2 3 K of the original inference time. At last, we evaluated our post-averaging defence approach against attacks with different allowed perturbation ranges . The results are shown in Figure 3 . As we can see, our model retains very good attack defence rate up to = 32 /255. Note that the defence rate against PGD and C&W doesn't change much along the variation of , this is because PGD and C&W have already successfully generated adversarial samples for most of the correctly classified inputs when is small. Hence their generated adversarial samples will not change much when using larger . For FGSM, our method yields lower defending performance. The possible reason is that FGSM tends to generate much larger perturbations than other three stronger attacking methods under the same setting. A large perturbation is more likely to move samples across class-specific decision boundaries to generate much more confusing samples. In our opinion, this is a general phenomenon in pattern classification, not particular to adversarial attacks. In this paper, we have presented some theoretical results by Fourier analysis of ReLU neural networks. These results are useful for us to understand why neural networks are vulnerable to adversarial samples. Based on the results, we hypothesize that the inevitable and ubiquitous existence of tiny unlearned regions in the model function mapping may be a major reason for adversarial vulnerability. As a possible defence strategy, we have proposed a simple post-averaging method. Experimental results on the ImageNet and the CIFAR-10 datasets have demonstrated that our simple defence technique turns out to be very effective against many popular attack methods in the literature. Finally, it will be interesting to see whether our post-averaging method will be still robust against any new attack methods in the future. Definition B.1. A piece-wise linear function is a continuous function f : R n \u2212 \u2192 R such that there are some hyperplanes passing through origin and dividing R n into M pairwise disjoint regions R m , (m = 1, 2, ..., M ), on each of which f is linear: Proof. This proposition immediately follows lemma B.2. Definition B.4. Let V = {v 1 , v 2 , ..., v n } be a set of n independent vectors in R n . An infinite simplex, R + V , is defined as the region linearly spanned by V using only positive weights: Theorem B.5. Each piece-wise linear function f (x) can be formulated as a summation of some functions: , each of which is linear and non-zero only in an infinite simplex as follows: where V k is a set of n independent vectors, and w k is a weight vector. Proof. Each region R p of a piece-wise linear function, f (x), which describes the behavior of a ReLU node if intersects with an affine hyper-plane results in a convex polytope. This convex polytope can be triangulated into some simplices. Define V k , (k = 1, 2, ..., K), sets of vertexes of these simplices. The infinite simplexes created by these vector sets will have the desired property and f (x) can be written as: As explained earlier in the original article by adding n 2 hyper-planes to those defining the piece-wise linear function, the output of a ReLU node may be represented as f (x) = Q q=1 g q (x). These hyper-planes are those perpendicular to standard basis vectors and subtraction of one of these vectors from another one. That is, e i (i = 1, . . . , n) and e i \u2212 e j (1 \u2264 i < j \u2264 n). Given this representation, the final step to achieve the Fourier transform is the following lemma: Lemma B.6. Fourier transform of the following function: 0 otherwise may be presented as: where \u03c9 r is the rth component of frequency vector \u03c9 (r = 1, \u00b7 \u00b7 \u00b7 , n), and \u03c9 0 = 0. Proof. Alternatively, s(x) may be represented as: Therefore, we need to compute Fourier transform of h(x)h(1 \u2212 x): By taking the inverse Fourier transform of the function: where \u03b4 n is n-dimensional Dirac Delta function, it can be shown that it is the Fourier transform of Now we can find the Fourier transform of s(x) where \u2126 = {\u03c9 0 , ..., \u03c9 n }, \u03c3 B is the summation over elements of B and A r = If B does not contain \u03c9 r and have at least 2 elements then the terms for B and B \u222a {\u03c9 r } will cancel each other out. Also, sign(|B| \u2212 1) will vanish if B has only one element. Therefore, there only remains empty set and sets with two elements one of them being \u03c9 r . Given the fact that A r = 0, the result of the integral will be: or equivalently: Therefore: where\u03c9 q = \u03c9A \u22121 q . As for the Fourier transform computed in section 3.1, it should be mentioned that the integral in equation 6 is the Fourier transform of: which can be derived utilizing the property of the Fourier transforms for radially symmetric functions (Stein and Weiss, 1971) : Given this transform:"
}