{
    "title": "HyxzRsR9Y7",
    "content": "The success of popular algorithms for deep reinforcement learning, such as policy-gradients and Q-learning, relies heavily on the availability of an informative reward signal at each timestep of the sequential decision-making process. When rewards are only sparsely available during an episode, or a rewarding feedback is provided only after episode termination, these algorithms perform sub-optimally due to the difficultly in credit assignment. Alternatively, trajectory-based policy optimization methods, such as cross-entropy method and evolution strategies, do not require per-timestep rewards, but have been found to suffer from high sample complexity by completing forgoing the temporal nature of the problem. Improving the efficiency of RL algorithms in real-world problems with sparse or episodic rewards is therefore a pressing need. In this work, we introduce a self-imitation learning algorithm that exploits and explores well in the sparse and episodic reward settings. We view each policy as a state-action visitation distribution and formulate policy optimization as a divergence minimization problem. We show that with Jensen-Shannon divergence, this divergence minimization problem can be reduced into a policy-gradient algorithm with shaped rewards learned from experience replays. Experimental results indicate that our algorithm works comparable to existing algorithms in environments with dense rewards, and significantly better in environments with sparse and episodic rewards. We then discuss limitations of self-imitation learning, and propose to solve them by using Stein variational policy gradient descent with the Jensen-Shannon kernel to learn multiple diverse policies. We demonstrate its effectiveness on a challenging variant of continuous-control MuJoCo locomotion tasks. Deep reinforcement learning (RL) has demonstrated significant applicability and superior performance in many problems outside the reach of traditional algorithms, such as computer and board games BID28 , continuous control BID25 , and robotics . Using deep neural networks as functional approximators, many classical RL algorithms have been shown to be very effective in solving sequential decision problems. For example, a policy that selects actions under certain state observation can be parameterized by a deep neural network that takes the current state observation as input and gives an action or a distribution over actions as output. Value functions that take both state observation and action as inputs and predict expected future reward can also be parameterized as neural networks. In order to optimize such neural networks, policy gradient methods BID29 BID37 BID38 and Q-learning algorithms BID28 capture the temporal structure of the sequential decision problem and decompose it to a supervised learning problem, guided by the immediate and discounted future reward from rollout data. Unfortunately, when the reward signal becomes sparse or delayed, these RL algorithms may suffer from inferior performance and inefficient sample complexity, mainly due to the scarcity of the immediate supervision when training happens in single-timestep manner. This is known as the temporal credit assignment problem BID44 . For instance, consider the Atari Montezuma's revenge game -a reward is received after collecting certain items or arriving at the final destination in the lowest level, while no reward is received as the agent is trying to reach these goals. The sparsity of the reward makes the neural network training very inefficient and also poses challenges in exploration. It is not hard to see that many of the real-world problems tend to be of the form where rewards are either only sparsely available during an episode, or the rewards are episodic, meaning that a non-zero reward is only provided at the end of the trajectory or episode. In addition to policy-gradient and Q-learning, alternative algorithms, such as those for global-or stochastic-optimization, have recently been studied for policy search. These algorithms do not decompose trajectories into individual timesteps, but instead apply zeroth-order finite-difference gradient or gradient-free methods to learn policies based on the cumulative rewards of the entire trajectory. Usually, trajectory samples are first generated by running the current policy and then the distribution of policy parameters is updated according to the trajectory-returns. The cross-entropy method (CEM, Rubinstein & Kroese (2016) ) and evolution strategies BID36 are two nominal examples. Although their sample efficiency is often not comparable to the policy gradient methods when dense rewards are available from the environment, they are more widely applicable in the sparse or episodic reward settings as they are agnostic to task horizon, and only the trajectorybased cumulative reward is needed. Our contribution is the introduction of a new algorithm based on policy-gradients, with the objective of achieving better performance than existing RL algorithms in sparse and episodic reward settings. Using the equivalence between the policy function and its state-action visitation distribution, we formulate policy optimization as a divergence minimization problem between the current policy's visitation and the distribution induced by a set of experience replay trajectories with high returns. We show that with the Jensen-Shannon divergence (D JS ), this divergence minimization problem can be reduced into a policy-gradient algorithm with shaped, dense rewards learned from these experience replays. This algorithm can be seen as self-imitation learning, in which the expert trajectories in the experience replays are self-generated by the agent during the course of learning, rather than using some external demonstrations. We combine the divergence minimization objective with the standard RL objective, and empirically show that the shaped, dense rewards significantly help in sparse and episodic settings by improving credit assignment. Following that, we qualitatively analyze the shortcomings of the self-imitation algorithm. Our second contribution is the application of Stein variational policy gradient (SVPG) with the Jensen-Shannon kernel to simultaneously learn multiple diverse policies. We demonstrate the benefits of this addition to the self-imitation framework by considering difficult exploration tasks with sparse and deceptive rewards. Related Works. Divergence minimization has been used in various policy learning algorithms. Relative Entropy Policy Search (REPS) BID33 restricts the loss of information between policy updates by constraining the KL-divergence between the state-action distribution of old and new policy. Policy search can also be formulated as an EM problem, leading to several interesting algorithms, such as RWR BID32 and PoWER BID20 . Here the M-step minimizes a KL-divergence between trajectory distributions, leading to an update rule which resembles return-weighted imitation learning. Please refer to BID7 for a comprehensive exposition. MATL BID47 uses adversarial training to bring state occupancy from a real and simulated agent close to each other for efficient transfer learning. In Guided Policy Search (GPS, BID21 ), a parameterized policy is trained by constraining the divergence between the current policy and a controller learnt via trajectory optimization. Learning from Demonstrations (LfD). The objective in LfD, or imitation learning, is to train a control policy to produce a trajectory distribution similar to the demonstrator. Approaches for self-driving cars BID4 and drone manipulation BID34 have used human-expert data, along with Behavioral Cloning algorithm to learn good control policies. Deep Q-learning has been combined with human demonstrations to achieve performance gains in Atari and robotics tasks BID46 BID30 . Human data has also been used in the maximum entropy IRL framework to learn cost functions under which the demonstrations are optimal . BID17 use the same framework to derive an imitation-learning algorithm (GAIL) which is motivated by minimizing the divergence between agent's rollouts and external expert demonstrations. Besides humans, other sources of expert supervision include planningbased approaches such as iLQR and MCTS . Our algorithm departs from prior work in forgoing external supervision, and instead using the past experiences of the learner itself as demonstration data. Exploration and Diversity in RL. Count-based exploration methods utilize state-action visitation counts N (s, a), and award a bonus to rarely visited states BID42 . In large statespaces, approximation techniques BID45 , and estimation of pseudo-counts by learning density models BID3 BID13 has been researched. Intrinsic motivation has been shown to aid exploration, for instance by using information gain or prediction error BID41 as a bonus. Hindsight Experience Replay adds additional goals (and corresponding rewards) to a Q-learning algorithm. We also obtain additional rewards, but from a discriminator trained on past agent experiences, to accelerate a policy-gradient algorithm. Prior work has looked at training a diverse ensemble of agents with good exploratory skills BID27 BID6 BID12 . To enjoy the benefits of diversity, we incorporate a modification of SVPG BID27 in our final algorithm. In very recent work, BID31 propose exploiting past good trajectories to drive exploration. Their algorithm buffers (s, a) and the corresponding return for each transition in rolled trajectories, and reuses them for training if the stored return value is higher than the current state-value estimate. Our approach presents a different objective for self-imitation based on divergence-minimization. With this view, we learn shaped, dense rewards which are then used for policy optimization. We further improve the algorithm with SVPG. Reusing high-reward trajectories has also been explored for program synthesis and semantic parsing tasks BID23 BID0 . We start with a brief introduction to RL in Section 2.1, and then introduce our main algorithm of self-imitating learning in Section 2.2. Section 2.3 further extends our main method to learn multiple diverse policies using Stein variational policy gradient with Jensen-Shannon kernel. A typical RL setting involves an environment modeled as a Markov Decision Process with an unknown system dynamics model p(s t+1 |s t , a t ) and an initial state distribution p 0 (s 0 ). An agent interacts sequentially with the environment in discrete time-steps using a policy \u03c0 which maps the an observation s t \u2208 S to either a single action a t (deterministic policy), or a distribution over the action space A (stochastic policy). We consider the scenario of stochastic policies over high-dimensional, continuous state and action spaces. The agent receives a per-step reward r t (s t , a t ) \u2208 R, and the RL objective involves maximization of the expected discounted sum of rewards, \u03b7(\u03c0 \u03b8 ) = E p0,p,\u03c0 \u221e t=0 \u03b3 t r(s t , a t ) , where \u03b3 \u2208 (0, 1] is the discount factor. The action-value function is DISPLAYFORM0 . We define the unnormalized \u03b3-discounted statevisitation distribution for a policy \u03c0 by \u03c1 \u03c0 (s) = \u221e t=0 \u03b3 t P (s t = s|\u03c0), where P (s t = s|\u03c0) is the probability of being in state s at time t, when following policy \u03c0 and starting state s 0 \u223c p 0 . The expected policy return \u03b7(\u03c0 \u03b8 ) can then be written as E \u03c1\u03c0(s,a) [r(s, a)], where \u03c1 \u03c0 (s, a) = \u03c1 \u03c0 (s)\u03c0(a|s) is the state-action visitation distribution. Using the policy gradient theorem BID43 , we can get the direction of ascent \u2207 \u03b8 \u03b7(\u03c0 \u03b8 ) = E \u03c1\u03c0(s,a) \u2207 \u03b8 log \u03c0 \u03b8 (a|s)Q \u03c0 (s, a) . Although the policy \u03c0(a|s) is given as a conditional distribution, its behavior is better characterized by the corresponding state-action visitation distribution \u03c1 \u03c0 (s, a), which wraps the MDP dynamics and fully decides the expected return via \u03b7(\u03c0) = E \u03c1\u03c0 [r(s, a)]. Therefore, distance metrics on a policy \u03c0 should be defined with respect to the visitation distribution \u03c1 \u03c0 , and the policy search should be viewed as finding policies with good visitation distributions \u03c1 \u03c0 that yield high reward. Suppose we have access to a good policy \u03c0 * , then it is natural to consider finding a \u03c0 such that its visitation distribution \u03c1 \u03c0 matches \u03c1 \u03c0 * . To do so, we can define a divergence measure D(\u03c1 \u03c0 , \u03c1 \u03c0 * ) that captures the similarity between two distributions, and minimize this divergence for policy improvement. Assume there exists an expert policy \u03c0 E , such that policy optimization can be framed as minimizing the divergence min \u03c0 D(\u03c1 \u03c0 , \u03c1 \u03c0 E ), that is, finding a policy \u03c0 to imitate \u03c0 E . In practice, however, we do not have access to any real guiding expert policy. Instead, we can maintain a selected subset M E of highly-rewarded trajectories from the previous rollouts of policy \u03c0, and optimize the policy \u03c0 to minimize the divergence between \u03c1 \u03c0 and the empirical state-action pair distribution {(s i , a i )} M E : DISPLAYFORM0 Since it is not always possible to explicitly formulate \u03c1 \u03c0 even with the exact functional form of \u03c0, we generate rollouts from \u03c0 in the environment and obtain an empirical distribution of \u03c1 \u03c0 . To measure the divergence between two empirical distributions, we use the Jensen-Shannon divergence, with the following variational form (up to a constant shift) as exploited in GANs BID15 : DISPLAYFORM1 where d(s, a) and d E (s, a) are empirical density estimators of \u03c1 \u03c0 and \u03c1 \u03c0 E , respectively. Under certain assumptions, we can obtain an approximate gradient of D JS w.r.t the policy parameters, thus enabling us to optimize the policy. Gradient Approximation: Let \u03c1 \u03c0 (s, a) and \u03c1 \u03c0 E (s, a) be the state-action visitation distributions induced by two policies \u03c0 and \u03c0 E respectively. Let d \u03c0 and d \u03c0 E be the surrogates to \u03c1 \u03c0 and \u03c1 \u03c0 E , respectively, obtained by solving Equation 2. Then, if the policy \u03c0 is parameterized by \u03b8, the gradient of D JS (\u03c1 \u03c0 , \u03c1 \u03c0 E ) with respect to policy parameters (\u03b8) can be approximated as: DISPLAYFORM2 where DISPLAYFORM3 .. The derivation of the approximation and the underlying assumptions are in Appendix 5.1. Next, we introduce a simple and inexpensive approach to construct the replay memory M E using highreturn past experiences during training. In this way, \u03c1 \u03c0 E can be seen as a mixture of deterministic policies, each representing a delta point mass distribution in the trajectory space or a finite discrete visitation distribution of state-action pairs. At each iteration, we apply the current policy \u03c0 \u03b8 to sample b trajectories {\u03c4 } b 1 . We hope to include in M E , the top-k trajectories (or trajectories with returns above a threshold) generated thus far during the training process. For this, we use a priorityqueue list for M E which keeps the trajectories sorted according to the total trajectory reward. The reward for each newly sampled trajectory in {\u03c4 } b 1 is compared with the current threshold of the priority-queue, updating M E accordingly. The frequency of updates is impacted by the exploration capabilities of the agent and the stochasticity in the environment. We find that simply sampling noisy actions from Gaussian policies is sufficient for several locomotion tasks (Section 3). To handle more challenging environments, in the next sub-section, we augment our policy optimization procedure to explicitly enhance exploration and produce an ensemble of diverse policies. In the usual imitation learning framework, expert demonstrations of trajectories-from external sources-are available as the empirical distribution of \u03c1 \u03c0 E of an expert policy \u03c0 E . In our approach, since the agent learns by treating its own good past experiences as the expert, we can view the algorithm as self-imitation learning from experience replay. As noted in Equation 3, the gradient estimator of D JS has a form similar to policy gradients, but for replacing the true reward function with per-timestep reward defined as log( DISPLAYFORM4 ). Therefore, it is possible to interpolate the gradient of D JS and the standard policy gradient. We would highlight the benefit of this interpolation soon. The net gradient on the policy parameters is: DISPLAYFORM5 where Q r is the Q function with true rewards, and \u03c0 E is the mixture policy represented by the DISPLAYFORM6 . r \u03c6 (s, a) can be computed using parameterized networks for densities d \u03c0 and d \u03c0 E , which are trained by solving the D JS optimization (Eq 2) using the current policy rollouts and M E , where \u03c6 includes the parameters for d \u03c0 and d \u03c0 E . Using Equation 3, the interpolated gradient can be further simplified to: DISPLAYFORM7 where DISPLAYFORM8 is the Q function calculated using \u2212 log r \u03c6 (s, a) as the reward. This reward is high in the regions of the S \u00d7 A space frequented more by the expert than the learner, and low in regions visited more by the learner than the expert. The effective Q in Equation 5 is therefore an interpolation between Q r obtained with true environment rewards, and Q r \u03c6 obtained with rewards which are implicitly shaped to guide the learner towards expert behavior. In environments with sparse or deceptive rewards, where the signal from Q r is weak or sub-optimal, a higher weight on Q r \u03c6 enables successful learning by imitation. We show this empirically in our experiments. We further find that even in cases with dense environment rewards, the two gradient components can be successfully combined for policy optimization. The complete algorithm for self-imitation is outlined in Appendix 5.2 (Algorithm 1).Limitations of self-imitation. We now elucidate some shortcomings of the self-imitation approach. Since the replay memory M E is only constructed from the past training rollouts, the quality of the trajectories in M E is hinged on good exploration by the agent. Consider a maze environment where the robot is only rewarded when it arrives at a goal G placed in a far-off corner. Unless the robot reaches G once, the trajectories in M E always have a total reward of zero, and the learning signal from Q r \u03c6 is not useful. Secondly, self-imitation can lead to sub-optimal policies when there are local minima in the policy optimization landscape; for example, assume the maze has a second goal G in the opposite direction of G, but with a much smaller reward. With simple exploration, the agent may fill M E with below-par trajectories leading to G , and the reinforcement from Q r \u03c6 would drive it further to G . Thirdly, stochasticity in the environment may make it difficult to recover the optimal policy just by imitating the past top-k rollouts. For instance, in a 2-armed bandit problem with reward distributions Bernoulli (p) and Bernoulli (p+ ), rollouts from both the arms get conflated in M E during training with high probability, making it hard to imitate the action of picking the arm with the higher expected reward. We propose to overcome these pitfalls by training an ensemble of self-imitating agents, which are explicitly encouraged to visit different, non-overlapping regions of the state-space. This helps to discover useful rewards in sparse settings, avoids deceptive reward traps, and in environments with reward-stochasticity like the 2-armed bandit, increases the probability of the optimal policy being present in the final trained ensemble. We detail the enhancements next. One approach to achieve better exploration in challenging cases like above is to simultaneously learn multiple diverse policies and enforce them to explore different parts of the high dimensional space. This can be achieved based on the recent work by BID27 on Stein variational policy gradient (SVPG). The idea of SVPG is to find an optimal distribution q(\u03b8) over the policy parameters \u03b8 which maximizes the expected policy returns, along with an entropy regularization that enforces diversity on the parameter space, i.e. DISPLAYFORM0 Without a parametric assumption on q, this problem admits a challenging functional optimization problem. Stein variational gradient descent (SVGD, BID26 ) provides an efficient solution for solving this problem, by approximating q with a delta measure q = n i=1 \u03b4 \u03b8i /n, where DISPLAYFORM1 is an ensemble of policies, and iteratively update {\u03b8 i } with DISPLAYFORM2 where k(\u03b8 j , \u03b8 i ) is a positive definite kernel function. The first term in \u2206\u03b8 i moves the policy to regions with high expected return (exploitation), while the second term creates a repulsion pressure between policies in the ensemble and encourages diversity (exploration). The choice of kernel is critical. BID27 used a simple Gaussian RBF kernel k(\u03b8 j , \u03b8 i ) = exp(\u2212 \u03b8 j \u2212 \u03b8 i 2 2 /h), with the bandwidth h dynamically adapted. This, however, assumes a flat Euclidean distance between \u03b8 j and \u03b8 i , ignoring the structure of the entities defined by them, which are probability distributions. A statistical distance, such as D JS , serves as a better metric for comparing policies BID1 BID19 . Motivated by this, we propose to improve SVPG using JS kernel k(\u03b8 j , \u03b8 i ) = exp(\u2212D JS (\u03c1 \u03c0 \u03b8 j , \u03c1 \u03c0 \u03b8 i )/T ), where \u03c1 \u03c0 \u03b8 (s, a) is the state-action visitation distribution obtained by running policy \u03c0 \u03b8 , and T is the temperature. The second exploration term in SVPG involves the gradient of the kernel w.r.t policy parameters. With the JS kernel, this requires estimating gradient of D JS , which as shown in Equation 3, can be obtained using policy gradients with an appropriately trained reward function. Our full algorithm is summarized in Appendix 5.3 (Algorithm 2). In each iteration, we apply the SVPG gradient to each of the policies, where the \u2207 \u03b8 \u03b7(\u03c0 \u03b8 ) in Equation 6 is the interpolated gradient from self-imitation (Equation 5). We also utilize state-value function networks as baselines to reduce the variance in sampled policy-gradients. Our goal in this section is to answer the following questions: 1) How does self-imitation fare against standard policy gradients under various reward distributions from the environment, namely episodic, noisy and dense? 2) How far does the SVPG exploration go in overcoming the limitations of selfimitation, such as susceptibility to local-minimas?We benchmark high-dimensional, continuous-control locomotion tasks based on the MuJoCo physics simulator by extending the OpenAI Baselines BID8 framework. Our control policies (\u03b8 i ) are modeled as unimodal Gaussians. All feed-forward networks have two layers of 64 hidden units each with tanh non-linearity. For policy-gradient, we use the clipped-surrogate based PPO algorithm BID39 . Further implementation details are in the Appendix. Table 1 : Performance of PPO and Self-Imitation (SI) on tasks with episodic rewards, noisy rewards with masking probability pm, and dense rewards. All runs use 5M timesteps of interaction with the environment. ES performance at 5M timesteps is taken from BID36 . Missing entry denotes that we were unable to obtain the 5M timestep performance from the paper. DISPLAYFORM0 We evaluate the performance of self-imitation with a single agent in this sub-section; combination with SVPG exploration for multiple agents is discussed in the next. We consider the locomotion tasks in OpenAI Gym under 3 separate reward distributions: Dense refers to the default reward function in Gym, which provides a reward for each simulation timestep. In episodic reward setting, rather than providing r(s t , a t ) at each timestep of an episode, we provide t r(s t , a t ) at the last timestep of the episode, and zero reward at other timesteps. This is the case for many practical settings where the reward function is hard to design, but scoring each trajectory, possibly by a human BID5 , is feasible. In noisy reward setting, we probabilistically mask out each out each per-timestep reward r(a t , s t ) in an episode. Reward masking is done independently for every new episode, and therefore, the agent receives non-zero feedback at different-albeit only few-timesteps in different episodes. The probability of masking-out or suppressing the rewards is denoted by p m .In FIG0 , we plot the learning curves on three tasks with episodic rewards. Recall that \u03bd is the hyper-parameter controlling the weight distribution between gradients with environment rewards and the gradients with shaped reward from r \u03c6 (Equation 5). The baseline PPO agents use \u03bd = 0, meaning that the entire learning signal comes from the environment. We compare them with selfimitating (SI) agents using a constant value \u03bd = 0.8. The capacity of M E is fixed at 10 trajectories. We didn't observe our method to be particularly sensitive to the choice of \u03bd and the capacity value. For instance, \u03bd = 1 works equally well. Further ablation on these two hyper-parameters can be found in the Appendix. In FIG0 , we see that the PPO agents are unable to make any tangible progress on these tasks with episodic rewards, possibly due to difficulty in credit assignment -the lumped rewards at the end of the episode can't be properly attributed to the individual state-action pairs during the episode. In case of Self-Imitation, the algorithm has access to the shaped rewards for each timestep, derived from the high-return trajectories in M E . This makes credit-assignment easier, leading to successful learning even for very high-dimensional control tasks such as Humanoid. Table 1 summarizes the final performance, averaged over 5 runs with random seeds, under the various reward settings. For the noisy rewards, we compare performance with two different reward masking values -suppressing each reward r(s t , a t ) with 90% probability (p m = 0.9), and with 50% probability (p m = 0.5). The density of rewards increases across the reward settings from left to right in Table 1 . We find that SI agents (\u03bd = 0.8) achieve higher average score than the baseline PPO agents (\u03bd = 0) in majority of the tasks for all the settings. This indicates that not only does self-imitation vastly help when the environment rewards are scant, it can readily be incorporated with the standard policy gradients via interpolation, for successful learning across reward settings. For completion, we include performance of CEM and ES since these algorithms depend only on the total trajectory rewards and don't exploit the temporal structure. CEM perform poorly in most of the cases. ES, while being able to solve the tasks, is sample-inefficient. We include ES performance from BID36 after 5M timesteps of training for a fair comparison with our algorithm. We now conduct experiments to show how self-imitation can lead to sub-optimal policies in certain cases, and how the SVPG objective, which trains an ensemble with an explicit D JS repulsion between policies, can improve performance.2D-Navigation. Consider a simple Maze environment where the start location of the agent (blue particle) is shown in the figure on the right, along with two regions -the red region is closer to agent's starting location but has a per-timestep reward of only 1 point if the agent hovers over it; the green region is on the other side of the wall but has a per-timestep reward of 10 points. We run 8 independent, non-interacting, self-imitating (with \u03bd = 0.8) agents on this task. This ensemble is denoted as SI-independent. Figures 2a plots the state-visitation density for SI-independent after training, from which it is evident that the agents get trapped in the local minima. The red-region is relatively easily explored and trajectories leading to it fill the M E , causing sub-optimal imitation. We contrast this with an instantiation of our full algorithm, which is referred to as SI-interact-JS. It is composed of 8 self-imitating agents which share information for gradient calculation with the SVPG objective (Equation 6). The temperature T = 0.5 is held constant, and the weight on exploration-facilitating repulsion term (\u03b1) is linearly decayed over time. FIG2 depicts the state-visitation density for this ensemble. SI-interact-JS explores wider portions of the maze, with multiple agents reaching the green zone of high reward. Figures 2c and 2d show the kernel matrices for the two ensembles after training. Cell (i, j) in the matrix corresponds to the kernel value k(\u03b8 i , \u03b8 j ) = exp(\u2212JS(\u03c1 i , \u03c1 j )/T ). For SI-independent, many darker cells indicate that policies are closer (low JS). For SI-interact-JS, which explicitly tries to decrease k(\u03b8 i , \u03b8 j ), the cells are noticeably lighter, indicating dissimilar policies (high JS). Behavior of PPO-independent (\u03bd = 0) is similar to SI-independent (\u03bd = 0.8) for the Maze task. Locomotion. To explore the limitations of self-imitation in harder exploration problems in highdimensional, continuous state-action spaces, we modify 3 MuJoCo tasks as follows -SparseHalfCheetah, SparseHopper and SparseAnt yield a forward velocity reward only when the centerof-mass of the corresponding bot is beyond a certain threshold distance. At all timesteps, there is an energy penalty to move the joints, and a survival bonus for bots that can fall over causing premature episode termination (Hopper, Ant). FIG3 plots the performance of PPO-independent, SI-independent, SI-interact-JS and SI-interact-RBF (which uses RBF-kernel from BID27 instead of the JS-kernel) on the tasks. Each of these 4 algorithms is an ensemble of 8 agents using the same amount of simulation timesteps. The results are averaged over 3 separate runs, where for each run, the best agent from the ensemble after training is selected. The SI-independent agents rely solely on action-space noise from the Gaussian policy parameterization to find high-return trajectories which are added to M E as demonstrations. This is mostly inadequate or slow for sparse environments. Indeed, we find that all demonstrations in M E for SparseHopper are with the bot standing upright (or tilted) and gathering only the survival bonus, as action-space noise alone can't discover hopping behavior. Similarly, for SparseHalfCheetah, M E has trajectories with the bot haphazardly moving back and forth. On the other hand, in SI-interact-JS, the D JS repulsion term encourages the agents to be diverse and explore the state-space much more effectively. This leads to faster discovery of quality trajectories, which then provide good reinforcement through self-imitation, leading to higher overall score. SI-interact-RBF doesn't perform as well, suggesting that the JS-kernel is more formidable for exploration. PPO-independent gets stuck in the local optimum for SparseHopper and SparseHalfCheetah -the bots stand still after training, avoiding energy penalty. For SparseAnt, the bot can cross our preset distance threshold using only action-space noise, but learning is slow due to na\u00efve exploration. We approached policy optimization for deep RL from the perspective of JS-divergence minimization between state-action distributions of a policy and its own past good rollouts. This leads to a self-imitation algorithm which improves upon standard policy-gradient methods via the addition of a simple gradient term obtained from implicitly shaped dense rewards. We observe substantial performance gains over the baseline for high-dimensional, continuous-control tasks with episodic and noisy rewards. Further, we discuss the potential limitations of the self-imitation approach, and propose ensemble training with the SVPG objective and JS-kernel as a solution. Through experimentation, we demonstrate the benefits of a self-imitating, diverse ensemble for efficient exploration and avoidance of local minima. An interesting future work is improving our algorithm using the rich literature on exploration in RL. Since ours is a population-based exploration method, techniques for efficient single agent exploration can be readily combined with it. For instance, parameter-space noise or curiosity-driven exploration can be applied to each agent in the SI-interact-JS ensemble. Secondly, our algorithm for training diverse agents could be used more generally. In Appendix 5.6, we show preliminary results for two cases: a) hierarchical RL, where a diverse group of Swimmer bots is trained for downstream use in a complex Swimming+Gathering task; b) RL without environment rewards, relying solely on diversity as the optimization objective. Further investigation is left for future work. Let d * \u03c0 (s, a) and d * E (s, a) be the exact state-action densities for the current policy (\u03c0 \u03b8 ) and the expert, respectively. Therefore, by definition, we have (up to a constant shift): a) is a local surrogate to \u03c1 \u03c0 \u03b8 (s, a). By approximating it to be constant in an \u2212ball neighborhood around \u03b8, we get the following after taking gradient of the above equation w.r.t \u03b8: DISPLAYFORM0 DISPLAYFORM1 where DISPLAYFORM2 The last step follows directly from the policy gradient theorem ( Calculate g 1 = \u2207 \u03b8 \u03b7 r1 (\u03c0 \u03b8 ) with PPO objective using r 1 reward Calculate g 2 = \u2207 \u03b8 \u03b7 r2 (\u03c0 \u03b8 ) with PPO objective using r 2 reward 9Update \u03b8 with (1 \u2212 \u03bd)g 1 + \u03bdg 2 using ADAM We show the sensitivity of self-imitation to \u03bd and the capacity of M E , denoted by C. The experiments in this subsection are done on Humanoid and Hopper tasks with episodic rewards. The tables show the average performance over 5 random seeds. For ablation on \u03bd, C is fixed at 10; for ablation on C, \u03bd is fixed at 0.8. With episodic rewards, a higher value of \u03bd helps boost performance since the RL signal from the environment is weak. With \u03bd = 0.8, there isn't a single best choice for C, though all values of C give better results than baseline PPO (\u03bd = 0). The diversity-promoting D JS repulsion can be used for various other purposes apart from aiding exploration in the sparse environments considered thus far. First, we consider the paradigm of hierarchical reinforcement learning wherein multiple sub-policies (or skills) are managed by a highlevel policy, which chooses the most apt sub-policy to execute at any given time. In FIG7 , we use the Swimmer environment from Gym and show that diverse skills (movements) can be acquired in a pre-training phase when D JS repulsion is used. The skills can then be used in a difficult downstream task. During pre-training with SVPG, exploitation is done with policy-gradients calculated using the norm of the velocity as dense rewards, while the exploration term uses the JS-kernel. As before, we compare an ensemble of 8 interacting agents with 8 independent agents. Figures 4a and 4b depict the paths taken by the Swimmer after training with independent and interacting agents, respectively. The latter exhibit variety. FIG7 is the downstream task of Swimming+Gathering where the bot has to swim and collect the green dots, whilst avoiding the red ones. The utility of pre-training a diverse ensemble is shown in FIG7 , which plots the performance on this task while training a higher-level categorical manager policy (|A| = 8). Diversity can sometimes also help in learning a skill without any rewards from the environment, as observed by BID10 in recent work. We consider a Hopper task with no rewards, but we do require weak supervision in form of the length of each trajectory L. Using policy-gradient Let the policy parameters be parameterized by \u03b8. To achieve diverse, high-return policies, we seek to obtain the distribution q * (\u03b8) which is the solution of the optimization problem: max q E \u03b8\u223cq [\u03b7(\u03b8)] + \u03b1H(q), where H(q) = E \u03b8\u223cq [\u2212 log q(\u03b8)] is the entropy of q. Solving the above equation by setting derivative to zero yields the an energy-based formulation for the optimal policy-parameter distribution: q * (\u03b8) \u221d exp( \u03b7(\u03b8) \u03b1 ). Drawing samples from this posterior using traditional methods such as MCMC is computationally intractable. Stein variational gradient descent (SVGD; BID26 ) is an efficient method for generating samples and also converges to the posterior of the energy-based model. Let {\u03b8} n 1 be the n particles that constitute the policy ensemble. SVGD provides appropriate direction for perturbing each particle such that induced KL-divergence between the particles and the target distribution q * (\u03b8) is reduced. The perturbation (gradient) for particle \u03b8 i is given by (please see BID26 for derivation): DISPLAYFORM0 DISPLAYFORM1 where k(\u03b8 j , \u03b8 i ) is a positive definite kernel function. Using q * (\u03b8) \u221d exp( DISPLAYFORM2 \u03b1 ) as target distribution, and k(\u03b8 j , \u03b8 i ) = exp(\u2212D JS (\u03c1 \u03c0 \u03b8 j , \u03c1 \u03c0 \u03b8 i )/T ) as the JS-kernel, we get the gradient direction for ascent: DISPLAYFORM3 where \u03c1 \u03c0 \u03b8 (s, a) is the state-action visitation distribution for policy \u03c0 \u03b8 , and T is the temperature. Also, for our case, \u2207 \u03b8j \u03b7(\u03c0 \u03b8j ) is the interpolated gradient from self-imitation (Equation 5). The \u2212\u2207 \u03b8j D JS (\u03c1 \u03c0 \u03b8 j , \u03c1 \u03c0 \u03b8 i ) gradient in the above equation is the repulsion factor that pushes \u03c0 \u03b8i away from \u03c0 \u03b8j . Similar repulsion can be achieved by using the gradient +\u2207 \u03b8i D JS (\u03c1 \u03c0 \u03b8 j , \u03c1 \u03c0 \u03b8 i ); note that this gradient is w.r.t \u03b8 i instead of \u03b8 j and the sign is reversed. Empirically, we find that the latter results in slightly better performance. DISPLAYFORM0 This can be done in two ways -using implicit and explicit distributions. In the implicit method, we could train a parameterized discriminator network (\u03c6) using state-actions pairs from \u03c0 i and \u03c0 j to implicitly approximate the ratio r s, a) ]. We could then use the policy gradient theorem to obtain the gradient of D JS as explained in Section 2.2. This, however, requires us to learn O(n 2 ) discriminator networks for a population of size n, one for each policy pair (i, j). To reduce the computational and memory resource burden to O(n), we opt for explicit modeling of \u03c1 \u03c0i . Specifically, we train a network \u03c1 \u03c8i to approximate the state-action visitation density for each policy \u03c0 i . The \u03c1 \u03c81 . . . \u03c1 \u03c8n networks are learned using the D JS optimization (Equation 2), and we can easily obtain the ratio r ij (s, a) = \u03c1 \u03c8i (s, a)/[\u03c1 \u03c8i (s, a) + \u03c1 \u03c8j (s, a)]. The agent then uses log r ij (s, a) as the SVPG exploration rewards in the policy gradient theorem. DISPLAYFORM1 We use state-value function networks as baselines to reduce the variance in sampled policy-gradients. Each agent \u03b8 i in a population of size n trains n + 1 state-value networks corresponding to real environment rewards r(s, a), self-imitation rewards \u2212 log r \u03c6 (s, a), and n \u2212 1 SVPG exploration rewards log r ij (s, a). In this section, we provide evaluation for a recently proposed method for self-imitation learning (SIL; BID31 ). The SIL loss function take the form: DISPLAYFORM0 In words, the algorithm buffers (s, a) and the corresponding return (R) for each transition in rolled trajectories, and reuses them for training if the stored return value is higher than the current statevalue estimate V \u03b8 (s).We use the code provided by the authors 2 . As per our understanding, PPO+SIL does not use a single set of hyper-parameters for all the MuJoCo tasks (Appendix A; BID31 ). We follow their methodology and report numbers for the best configuration for each task. This is different from our experiments since we run all tasks on a single fix hyper-parameter set (Appendix 5.5), and therefore a direct comparison of the average scores between the two approaches is tricky. Table 3 : Performance of PPO+SIL BID31 on tasks with episodic rewards, noisy rewards with masking probability pm, and dense rewards. All runs use 5M timesteps of interaction with the environment. Table 3 shows the performance of PPO+SIL on MuJoCo tasks under the various reward distributions explained in Section 3.1 -dense, episodic and noisy. We observe that, compared to the dense rewards setting (default Gym rewards), the performance suffers under the episodic case and when the rewards are masked out with p m = 0.9. Our intuition is as follows. PPO+SIL makes use of the cumulative return (R) from each transition of a past good rollout for the update. When rewards are provided only at the end of the episode, for instance, cumulative return does not help with the temporal credit assignment problem and hence is not a strong learning signal. Our approach, on the other hand, derives dense, per-timestep rewards using an objective based on divergence-minimization. This is useful for credit assignment, and as indicated in Table 1 . (Section 3.1) leads to learning good policies even under the episodic and noisy p m = 0.9 settings. Our approach makes use of replay memory M E to store the past good rollouts of the agent. Offpolicy RL methods such as DQN BID28 also accumulate agent experience in a replay buffer and reuse them for learning (e.g. by reducing TD-error). In this section, we evaluate the performance of one such recent algorithm -Twin Delayed Deep Deterministic policy gradient (TD3; BID14 ) on tasks with episodic and noisy rewards. TD3 builds on DDPG BID25 and surpasses its performance on all the MuJoCo tasks evaluated by the authors. Table 4 : Performance of TD3 BID14 on tasks with episodic rewards, noisy rewards with masking probability pm, and dense rewards. All runs use 5M timesteps of interaction with the environment. Table 4 shows that the performance of TD3 suffers appreciably with the episodic and noisy p m = 0.9 reward settings, indicating that popular off-policy algorithms (DDPG, TD3) do not exploit the past experience in a manner that accelerates learning when rewards are scarce during an episode. * For 3 tasks used in our paper-Swimmer and the high-dimensional Humanoid, HumanoidStandup-the TD3 code from the authors 3 is unable to learn a good policy even in presence of dense rewards (default Gym rewards). These tasks are also not included in the evaluation by BID14 . We run a new exploration baseline -EX 2 BID13 and compare its performance to SIinteract-JS on the hard exploration MuJoCo tasks considered in Section 3.2. The EX 2 algorithm does implicit state-density \u03c1(s) estimation using discriminative modeling, and uses it for noveltybased exploration by adding \u2212 log \u03c1(s) as the bonus. We used the author provided code 4 and hyperparameter settings. TRPO is used as the policy gradient algorithm. BID13 and SI-interact-JS on the hard exploration MuJoCo tasks from Section 3.2. SparseHalfCheetah, SparseHalfCheetah, SparseAnt use 1M, 1M and 2M timesteps of interaction with the environment, respectively. Results are averaged over 3 separate runs."
}