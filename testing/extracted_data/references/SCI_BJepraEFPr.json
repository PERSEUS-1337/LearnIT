{
    "title": "BJepraEFPr",
    "content": "Dialogue systems require a great deal of different but complementary expertise to assist, inform, and entertain humans. For example, different domains (e.g., restaurant reservation, train ticket booking) of goal-oriented dialogue systems can be viewed as different skills, and so does ordinary chatting abilities of chit-chat dialogue systems. In this paper, we propose to learn a dialogue system that independently parameterizes different dialogue skills, and learns to select and combine each of them through Attention over Parameters (AoP). The experimental results show that this approach achieves competitive performance on a combined dataset of MultiWOZ (Budzianowski et al., 2018), In-Car Assistant (Eric et al.,2017), and Persona-Chat (Zhang et al., 2018). Finally, we demonstrate that each dialogue skill is effectively learned and can be combined with other skills to produce selective responses. Unlike humans who can do both, goal-oriented dialogues (Williams & Young, 2007; Young et al., 2013) and chit-chat conversations (Serban et al., 2016a; Vinyals & Le, 2015) are often learned with separate models. A more desirable approach for the users would be to have a single chat interface that can handle both casual talk and tasks such as reservation or scheduling. This can be formulated as a problem of learning different conversational skills across multiple domains. A skill can be either querying a database, generating daily conversational utterances, or interacting with users in a particular task-domain (e.g. booking a restaurant). One challenge of having multiple skills is that existing datasets either focus only on chit-chat or on goal-oriented dialogues. This is due to the fact that traditional goal-oriented systems are modularized (Williams & Young, 2007; Hori et al., 2009; Lee et al., 2009; Levin et al., 2000; Young et al., 2013) ; thus, they cannot be jointly trained with end-to-end architecture as in chit-chat. However, recently proposed end-to-end trainable models Wu et al., 2019; Reddy et al., 2018; Yavuz et al., 2018) and datasets (Bordes & Weston, 2017; allow us to combine goal-oriented (Budzianowski et al., 2018; and chit-chat (Zhang et al., 2018) into a single benchmark dataset with multiple conversational skills as shown in Table 1. A straight forward solution would be to have a single model for all the conversational skills, which has shown to be effective to a certain extent by (Zhao et al., 2017) and (McCann et al., 2018) . Putting aside the performance in the tasks, such fixed shared-parameter framework, without any task-specific designs, would lose controllability and interpretability in the response generation. In this paper, instead, we propose to model multiple conversational skills using the Mixture of Experts (MoE) (Jacobs et al., 1991) paradigm, i.e., a model that learns and combine independent specialized experts using a gating function. For instance, each expert could specialize in different dialogues domains (e.g., Hotel, Train, ChitChat etc.) and skills (e.g., generate SQL query). A popular implementation of MoE ) uses a set of linear transformation (i.e., experts) in between two LSTM (Schmidhuber, 1987) layers. However, several problems arise with this implementation: 1) the model is computationally expensive as it has to decode multiple times each expert and make the combination at the representation-level; 2) no prior knowledge is injected in the expert selection (e.g., domains); 3) Seq2Seq model has limited ability in extracting information from a Knowledge Base (KB) (i.e., generated by the SQL query) , as required in end-to-end task-oriented dialogues Table 1 : An example from the dataset which includes both chit-chat and task-oriented conversations. The model has to predict all the Sys turn, which includes SQL query and generating response from a the Memory content, which is dynamically updated with the queries results. The skills are the prior knowledge needed for the response, where Persona refers to chit-chat. Spk. Conversation Skills Usr: Can you help me find a cheap 2 star hotel? SELECT * FROM hotel WHERE pricerange='cheap' AND stars=2 AND type='hotel' SQL+HOTEL Mem: (Result table from (Bordes & Weston, 2017) . The latter can be solved by using more advanced multi-hop models like the Transformer , but the remaining two need to be addressed. Hence, in this paper we: \u2022 propose a novel Transformer-based architecture called Attention over Parameters (AoP). This model parameterize the conversational skills of end-to-end dialogue systems with independent decoder parameters (experts), and learns how to dynamically select and combine the appropriate decoder parameter sets by leveraging prior knowledge from the data such as domains and skill types; \u2022 proof that AoP is algorithmically more efficient (Appendix A1) compared to forwarding all the Transformer decoders and then mix their output representation, like is normally done in MoE. Figure 1 illustrates the high-level intuition of the difference; \u2022 empirically show the effectiveness of using specialized parameters in a combined dataset of Multi-WOZ (Budzianowski et al., 2018) , In-Car Assistant , and Persona-Chat (Zhang et al., 2018) , which to the best of our knowledge, is the first evaluation of this genre i.e. end-to-end large-scale multi-domains/skills. Moreover, we show that our model is highly interpretable and is able to combine different learned skills to produce compositional responses. Dialogue Task-oriented dialogue models (Gao et al., 2018) can be categorized in two types: modulebased (Williams & Young, 2007; Hori et al., 2009; Lee et al., 2009; Levin et al., 2000; Young et al., 2013) and end-to-end. In this paper, we focus on the latter which are systems that train a single model directly on text transcripts of dialogues. These tasks are tackled by selecting a set of predefined utterances (Bordes & Weston, 2017; Liu & Perez, 2017; Williams et al., 2017; Seo et al., 2017) or by generating a sequence of tokens Wen et al., 2017; Serban et al., 2016b; Zhao et al., 2017; Serban et al., 2017) . Especially in the latter, copy-augmented models Wu et al., 2019; Reddy et al., 2018; Yavuz et al., 2018) are very effective since extracting entities from a knowledge base is fundamental. On the other hand, end-to-end open domain chit-chat models have been widely studied (Serban et al., 2016a; Vinyals & Le, 2015; Wolf et al., 2019) . Several works improved on the initially reported baselines with various methodologies (Kulikov et al., 2018; Yavuz et al., 2018; Hancock et al., 2019; Lucas et al., 2009; Joshi et al., 2017; Zemlyanskiy & Sha, 2018; Dinan et al., 2019) . Finally, (Zhao et al., 2017) was the first attempt of having an end-to-end system for both task-oriented models and chit-chat. However, the dataset used for the evaluation was small, evaluated only in single domain, and the chit-chat ability was added manually through rules. The idea of having specialized parameters, or so-called experts, has been widely studied topics in the last two decades (Jacobs et al., 1991; Jordan & Jacobs, 1994) . For instance, different architecture and methodologies have been used such as SVM (Collobert et al., 2002) , Gaussian Processes (Tresp, 2001; Theis & Bethge, 2015; Deisenroth & Ng, 2015) , Dirichlet Processes (Shahbaba & Neal, 2009 ), Hierarchical Experts (Yao et al., 2009 ), Infinity Number of Experts (Rasmussen & Ghahramani, 2002) , and sequential expert addition (Aljundi et al., 2017) . More recently, the Mixture Of Expert model was proposed which added a large number of experts between two LSTMs (Schmidhuber, 1987) . To the best of our knowledge, none of these previous works applied the results of the gating function to the parameters itself. On the other hand, there are Conditional Computational models which learn to dynamically select their computation graph (Bengio et al., 2013; Davis & Arel, 2013) . Several methods have been used such as reinforcement learning (Bengio et al., 2016) , a halting function (Graves, 2016; Dehghani et al., 2019; Figurnov et al., 2017) , by pruning (Lin et al., 2017; He et al., 2018) and routing/controller function (Rosenbaum et al., 2018) . However, this line of work focuses more on optimizing the inference performance of the model more than specializing parts of it for computing a certain task. Multi-task Learning Even though our model processes only input sequence and output sequences of text, it actually jointly learns multiple tasks (e.g. SQL and BOOK query, memory retrieval, and response generation), thus it is also related to multi-task learning (Caruana, 1997) . Interested readers may refer to (Ruder, 2017; Zhou et al., 2011) for a general overview on the topic. In Natural Language Processing, multi-task learning has been applied in a wide range of applications such as parsing (Collobert et al., 2011; Hashimoto et al., 2017; , machine translation in multiple languages (Johnson et al., 2017) , and parsing image captioning and machine translation (Luong et al., 2016) . More interestingly, DecaNLP (McCann et al., 2018) has a large set of tasks that are cast to question answering (QA), and learned by a single model. In this work, we focus more on conversational data, but in future works, we plan to include these QA tasks. We use the standard encoder-decoder architecture and avoid any task-specific designs Wu et al., 2019; Reddy et al., 2018) , as we aim to build a generic conversation model for both chit-chat and task-oriented dialogues. More specifically, we use a Transformer for both encoder and decoder. Let us define the sequence of tokens in the dialogue history as D = {d 1 , . . . , d m } and the dynamic memory content as a sequence of tokens M = {m 1 , . . . , m z }. The latter can be the result of a SQL query execution (e.g., table) or plain texts (e.g., persona description), depending on the task. The dialogue history D and the memory M are concatenated to obtain the final input denoted by We then denote Y = {y 1 , . . . , y k } as the sequence of tokens that the model is expected to produce. Without loss of generality, Y can be both plain text and SQL-like queries. Hence, the model has to learn when to issue database queries and when to generate human-like responses. Finally, we define a binary skill vector V = {v 1 , . . . , v r } that specifies the type of skills required to generate Y . This can be considered as a prior vector for learning to select the correct expert during the training 1 . For example, in Table 1 the first response is of type SQL in the Hotel domain, thus the skill vector V will have v SQL = 1 and v Hotel = 1, while all the other skill/domains are set to zero 2 . More importantly, we may set the vector V to have multiple ones to enforce the model to compose skills to achieve a semantic compositionality of different experts. To map the input sequence to the output sequence, we use a standard Transformer and denote the encoder and decoder as TRS enc and TRS dec , respectively. The input of a Transformer is the embedded representation of the input words; thus, we define a word embedding matrix E \u2208 R d\u00d7|V | where d is the embedding size and |V | is the cardinality of the vocabulary. The input X, with its positional embedding (Appendix A2 for more information), are encoded as the following equation: where H \u2208 R d model \u00d7n , and E. Then the decoder receives the target sequence shifted by one Y :k\u22121 = {<SOS>, y 1 , . . . , y k } as the input. Using teacher-forcing (Williams & Zipser, 1989) , the model is trained to produce the correct sequence Y . The output of the decoder is produced as follow: where O \u2208 R d model \u00d7k . Finally, a distribution over the vocabulary is generated for each token by an affine transformation W \u2208 R d model \u00d7|V | followed by a Softmax function. In addition, P (Y |X) is mixed with the encoder-decoder attention distribution to enable to copy token from the input sequence as in (See et al., 2017) . The model is then trained to minimize a standard cross entropy loss function and at inference time to generate one token at the time in an auto-regressive manner (Graves, 2013) . Hence, the training loss is defined as: The main idea is to produce a single set of parameters for decoder TRS dec by the weighted sum of r independently parameterized decoders. This process is similar to attention (Luong et al., 2015) where the memories are the parameters and the query is the encoded representation. Let us define \u0398 = [\u03b8 1 , . . . , \u03b8 r ] as the list of parameters for r decoders, since a TRS dec is represented by its parameters \u03b8. Since each \u03b8 can be sized in the order of millions, we assign the corresponding key vectors to each \u03b8, similar to key-value memory networks (Miller et al., 2016) . Thus, we use a key matrix K \u2208 R d model \u00d7r and a Recurrent Neural Networks (RNN), in this instance a GRU (Cho et al., 2014) , to produce the query vector by processing the encoder output H. The attention weights for each decoders' parameters is computed as follow: where q \u2208 R d model and \u03b1 \u2208 R r is the attention vectors where each \u03b1 i is the score corresponding to \u03b8 i . Hence, the new set of parameters is computed as follow: The combined set of parameters \u03b8 * are then used to initialize a new TRS dec , and Equation 2 will be applied to the input based on this. Equation 6 is similar to the gating function proposed 1 the vector V will be absent during the testing 2 With the assumption that at each index in V is assigned a semantic skill (e.g. SQL position i) in Jacobs et al., 1991) , but the resulting scoring vector \u03b1 is applied directly to the parameter instead of the output representation of each decoder. This indeed makes the computation algorithmically faster since the forward computation is done only once and summing r elements of size |\u03b8| is linear compared to forwarding r multiplications with the input. Interested readers may refer to Appendix A1 for the proof. Importantly, if we apply \u03b1 to each of the output representation O i generated by the TRS i dec , we end up having a Transformer-based implementation of MoE 3 . We call this model as Attention over Representation (AoR). Moreover, an additional loss term is used to supervise the attention vector \u03b1 by using the prior knowledge vector V . Since multiple decoder parameters can be selected at the same time, we use a binary cross-entropy to train each \u03b1 i . Thus a second loss is defined as: The final loss is the summation of L P (Y |X) and L V . Finally, in AoP, but in general in the MoE framework, stacking multiple layers (e.g., Transformer) leads to models with a large number of parameters, since multiple experts are repeated across layers. An elegant workaround is the Universal Transformer (Dehghani et al., 2019) , which loops over an unique layer and, as shown by (Dehghani et al., 2019) , holds similar or better performance than a multi-layer Transformer. In our experiment, we report a version of AoP that uses this architecture, which for instance does not add any further parameter to the model. To evaluate the performance of our model for different conversational skills, we propose to combine three publicly available datasets: MultiWOZ (Budzianowski et al., 2018) , Stanford Multi-domain Dialogue and Persona-Chat (Zhang et al., 2018 MultiWOZ (MWOZ) is a human-to-human multi-domain goal-oriented dataset annotated with dialogue acts and states. In this dataset, there are seven domains (i.e., Taxi, Police, Restaurant, Hospital, Hotel, Attraction, Train) and two APIs interfaces: SQL and BOOK. The former is used to retrieve information about a certain domain and the latter is used to book restaurants, hotels, trains, and taxis. We refine this dataset to include SQL/BOOK queries and their outputs using the same annotations schema as (Bordes & Weston, 2017) . Hence, each response can either be plain text conversation with the user or SQL/BOOK queries, and the memory is dynamically populated with the results from the queries as the generated response is based on such information. This transformation allows us to train end-to-end models that learns how and when to produce SQL queries, to retrieve knowledge from a dynamic memory, and to produce plain text response. A detailed explanation is reported in Appendix A4, together with some samples. Stanford Multi-domain Dialogue (SMD) is another human-to-human multi-domain goal-oriented dataset that is already designed for end-to-end training. There are three domains in this dataset (i.e., Point-of-Interest, Weather, Calendar). The difference between this dataset and MWOZ is that each dialogue is associated with a set of records relevant to the dialogues. The memory is fixed in this case so the model does not need to issue any API calls. However, retrieving the correct entities from the memory is more challenging as the model has to compare different alternatives among records. Persona-Chat is a multi-turn conversational dataset, in which two speakers are paired and different persona descriptions (4-5 sentences) are randomly assigned to each of them. For example, \"I am an old man\" and \"I like to play football\" are one of the possible persona descriptions provided to the system. Training models using this dataset results in a more persona consistent and fluent conversation compared to other existing datasets (Zhang et al., 2018) . Currently, this dataset has become one of the standard benchmarks for chit-chat systems, thus, we include it in our evaluation. For all three datasets, we use the training/validation/test split provided by the authors and we keep all the real entities in input instead of using their delexicalized version as in (Budzianowski et al., 2018; ). This makes the task more challenging, but at the same time more interesting since we force the model to produce real entities instead of generic and frequent placeholders. Goal-Oriented For both MWOZ and SMD, we follow the evaluation done by existing works Zhao et al., 2017; . We use BLEU 4 score (Papineni et al., 2002) to measure the response fluency and Entity F1-Score (Wen et al., 2017; Zhao et al., 2017) to evaluates the ability of the model to generate relevant entities from the dynamic memory. Since MWOZ also includes SQL and BOOK queries, we compute the exact match accuracy (i.e., ACC SQL and ACC BOOK ) and BLEU score (i.e., BLEU SQL and BLEU BOOK ). Furthermore, we also report the F1-score for each domain in both MWOZ and SMD. Chit-Chat We compare perplexity, BLEU score, F1-score (Dinan et al., 2019) , and Consistency score of the generate sentences with the human-generated prediction. The Consistency score is computed using a Natural Language Inference (NLI) model trained on dialogue NLI (Sean et al., 2018) , a recently proposed corpus based on Persona dataset. We fine-tune a pre-trained BERT model (Devlin et al., 2018) using the dialogue DNLI corpus and achieve a test set accuracy of 88.43%, which is similar to the best-reported model in (Sean et al., 2018) . The consistency score is defined as follow: where u is a generated utterance and p j is one sentence in the persona description. In Sean et al. (2018) , the authors showed that by re-ranking the beam search hypothesis using the DNLI score (i.e., C score), they achieved a substantial improvement in dialogue consistency. Intuitively, having a higher consistency C score means having a more persona consistent dialogue response. In our experiments, we compare Sequence-to-Sequence (Seq2Seq) (See et al., 2017) , Transformer (TRS) , Mixture of Expert (MoE) and Attention over Representation (AoR) with our proposed Attention over Parameters (AoP). In all the models, we used the same copy-mechanism as in (See et al., 2017) . In AoR instead of mixing the parameters as in Equation 7, we mix the output representation of each transformer decoder (i.e. Equation 2). For all AoP, AoR, and MoE, r = 13 is the number of decoders (experts): 2 skills of SQL and BOOK, 10 different domains for MWOZ+SMD, and 1 for Persona-Chat. Furthermore, we include also the following experiments: AoP that uses the gold attention vector V , which we refer as AoP w/ Oracle (or AoP + O); AoP trained by removing the L V from the optimization (AoP w/o L V ); and as aforementioned, the Universal Transformer for both AoP (AoP + U) and the standard Transformer (TRS + U) (i.e., 6 hops). All detailed model description and the full set of hyper-parameters used in the experiments are reported in Appendix A5. Table 2 and Table 3 show the respectively evaluation results in MWOZ+SMD and Persona-Chat datasets. From Table 2 , we can identify four patterns. 1) AoP and AoR perform consistently better then other baselines which shows the effectiveness of combining parameters by using the correct prior V ; 2) AoP performs consistently, but marginally, better than AoR, with the advantage of an algorithmic faster inference; 3) Using Oracle (AoP+O) gives the highest performance in all the measures, which shows the performance upper-bound for AoP. Hence, the performance gap when not using oracle attention is most likely due to the error in attention \u03b1 (i.e., 2% error rate). Moreover, Table 2 shows that by removing L V (AoP w/o L V ) the model performance decreases, which confirms that good inductive bias is important for learning how to select and combine different parameters (experts). Additionally, in Appendix A6, we report the per-domain F1-Score for SQL, BOOK and sentences, and Table 3 and Table 2 with the standard deviation among the three runs. Furthermore, from Table 3 , we can notice that MoE has the lowest perplexity and F1-score, but AoP has the highest Consistency and BLUE score. Notice that the perplexity reported in (Zhang et al., 2018) is lower since the vocabulary used in their experiments is smaller. In general, the difference in performance among different models is marginal except for the Consistency score; thus, we can conclude that all the models can learn this skill reasonably well. Consistently with the previous results, when L V is removed from the optimization, the models' performance decreases. Finally, in both Table 2 and Table 3 , we report the results obtained by using the Universal Transformer, for both AoP and the Transformer. By adding the layer recursion, both models are able to consistently improve all the evaluated measures, in both Persona-Chat and the Task-Oriented tasks. Especially AoP, which achieves better performance than Oracle (i.e. single layer) in the SQL accuracy, and a consistently better performance in the Persona-Chat evaluation. To demonstrate the effectiveness of our model in learning independent skills and composing them together, we manually trigger skills by modifying \u03b1 and generate 14 different responses for the same input dialogue context. This experiment allows us to verify whether the model accurately captures the meaning of each skill and whether it can properly learn to compose the selected parameters (skills). Table 3 first shows the dialogue history along with the response of AoP on the top, and then different responses generated by modifying \u03b1 (i.e., black cells correspond to 1 in the vector, while the whites are 0). By analyzing Table 3 5 we can notice that: \u2022 The model learns the correct semantics of each skill. For instance, the AoP response is of type SQL and Train, and by deactivating the SQL skill and activating other domain-skills, including Train, we can see that the responses are grammatical and they are coherent with the selected skill semantics. For instance, by just selecting Train, the generated answer becomes \"what time would you like to leave?\" which is coherent with the dialogue context since such information has not been yet provided. Interestingly, when Persona skill is selected, the generated response is conversational and also coherent with the dialogue, even though it is less fluent. \u2022 The model effectively learns how to compose multiple skills. For instance, when SQL or BOOK are triggered the response produces the correct SQL-syntax (e.g. \"SELECT * FROM ..\" etc.). By also adding the corresponding domain-skill, the model generates the correct query format and attributes relative to the domain type (e.g. in SQL, Restaurant, the model queries with the relevant attribute food for restaurants). In this paper, we propose a novel way to train a single end-to-end dialogue model with multiple composable and interpretable skills. Unlike previous work, that mostly focused on the representationlevel mixing , our proposed approach, Attention over Parameters, learns how to softly combine independent sets of specialized parameters (i.e., making SQL-Query, conversing with consistent persona, etc.) into a single set of parameters. By doing so, we not only achieve compositionality and interpretability but also gain algorithmically faster inference speed. To train and evaluate our model, we organize a multi-domain task-oriented datasets into end-to-end trainable formats and combine it with a conversational dataset (i.e. Persona-Chat). Our model learns to consider each task and domain as a separate skill that can be composed with each other, or used independently, and we verify the effectiveness of the interpretability and compositionality with competitive experimental results and thorough analysis. A.1 COMPUTATIONAL COST AOP Corollary A.0.1. The computation cost of Attention over Parameters (AoP) is always lower than Mixture Of Experts (MoE) as long as the processed sequence is longer than 1. Proof. Let f \u03b8 : R d \u2192 R n a generic function parametrized by \u03b8. Without loss of generality, we define \u03b8 as a affine transformation W \u2208 R d\u00d7n . Let X \u2208 R t\u00d7d a generic input sequence of length t and d dimensional size. Let the set F = [f \u03b81 , \u00b7 \u00b7 \u00b7 , f \u03b8r ] be the set of r experts. Hence, the operation done by MoE are: 10) Thus the computational cost in term of operation is O(rtdn + rtn) since the cost of f \u03b8i (X) is O(tdn) and it is repeated r times, and the cost of summing the representation is O(rtn). On the other hand, the operation done by AoP are: in this case the computational cost in term of operation is O((r + t)dn) since the cost of summing the parameters is O(rdn) and the cost of f \u03b8 * is O(tdn). Hence, it is easy to verify that if t > 1 then: Furthermore, the assumption of using a simple affine transformation W is actually an optimal case. Indeed, assuming that the cost of parameters sum is equal to the number of operation is optimistic, for instance already by using attention the number of operations increases but the number of parameters remains constant. Since the model input may include structured data (e.g. DB records) we further define another embedding matrix for encoding the types and the segments as P \u2208 R d\u00d7|S| where S is the set of positional tokens and |S| its cardinality. P is used to inform the model of the token types such as speaker information (e.g. Sys and Usr), the data-type for the memory content (e.g. Miles, Traffic etc.), and segment types like dialogue turn information and database record index (Wolf et al., 2019) . Figure 4 shows an example of the embedded representation of the input. Hence, we denote X T and X R as the type and segment tokens for each token in input X, respectively. Figure 5 shows the attention vector \u03b1 over parameters for different generated sentences. In this figure, and by analyzing more examples 5 , we can identify two patterns: \u2022 AoP learns to focus on the correct skills (i.e., SQL, BOOK) when API-calls are needed. From the first example in Figure 5 , we can see that the activations in \u03b1 are consistent with those in the correct attention vector P . There are also false positives, in which AoP puts too high weights on BOOK when the correct response is plain text that should request more information from the user (i.e., i can help you with that. when would you like to leave the hotel?). However, we can notice that this example is, in fact, \"almost correct\" as triggering a booking API call may also be considered a valid response. Meanwhile, the third example also fails to attend to the correct skill, but, in fact, generates a very fluent and relevant response. This is most likely because the answer is simple and generic. \u2022 The attention often focuses on multiple skills not directly relevant to the task. We observe this pattern especially when there are other skill-related entities mentioned in the context or the response. For example, in the second dialog example in Figure 5 , we can notice that AoP not only accurately focuses on taxi domain, but also has non-negligible activations for restaurant and hotel. This is because the words \"hotel\" and \"restaurant\" are both mentioned in the dialogue context and the model has to produce two entities of the same type (i.e. finches bed and breakfast and ask). As mentioned in the main article, we convert MultiWOZ into an end-to-end trainable dataset. This requires to add sql-syntax queries when the system includes particular entities. To do so we leverage two annotations such as the state-tracker and the speech acts. The first is used to generate the a well-formed query, including key and attribute, the second instead to decide when to include the query. More details on the dialogue state-tracker slots and slots value, and the different speech acts can be found in (Budzianowski et al., 2018) . A query is create by the slots, and its values, that has been updated in the latest turn. The SQL query uses the following syntax: Similarly for the booking api BOOK the syntax is the following: In both cases the slot values are kept as real entities. More challenging is to decide when to issue such apis. Speech acts are used to decide by using the \"INFORM-DOMAIN\" and \"RECOMMEND-DOMAIN\" tag. Thus any response that include those speech tag will trigger an api if and only if: \u2022 there has been a change in the state-tracker from the previous turn \u2022 the produced query has never been issued before By a manual checking, this strategy results to be effective. However, as reported by (Budzianowski et al., 2018 ) the speech act annotation includes some noise, which is reflected also into our dataset. The results from the SQL query can be of more that 1K records with multiple attributes. Following (Budzianowski et al., 2018) we use the following strategy: \u2022 If no speech act INFORM or RECOMMEND and the number of records are more than 5, we use a special token in the memory < T M >. \u2022 If no speech act INFORM or RECOMMEND and the number of records are less or equal than 5, we put all the records in memory. \u2022 If any speech act INFORM or RECOMMEND, we filter the records to include based on the act value. Notice that this is a fair strategy, since all the resulting record are correct possible answers and the annotators pick-up on of the record randomly (Budzianowski et al., 2018) . Notice that the answer of a booking call instead, is only one record containing the booking information (e.g. reference number, taxi plate etc.) or \"Not Available\" token in case the booking cannot made. We used a standard Transformer architecture with pre-trained Glove embedding (Pennington et al., 2014) . For the both Seq2Seq and MoE we use Adam (Kingma & Ba, 2014) optimizer with a learning rate of 1 \u00d7 10 \u22123 , where instead for the Transformer we used a warm-up learning rate strategy as in . In both AoP and AoR we use an additional transformer layer on top the output of the model. Figure 6 ,7,8 shows the high level design MoE, AoR and AoP respectively. In all the model we used a batch size of 16, and we early stopped the model using the Validation set. All the experiments has been conducted using a single Nvidia 1080ti. We used a small grid-search for tuning each model. The selected hyper-parameters are reported in Table 4 , and we run each experiment 3 times and report the mean and standard deviation of each result. model consist of r feed-forward neural network (experts) which are embedded between two LSTM layers, a trainable gating network to select experts. Figure 7 : Attention over Representation (AoR) consist of a transformer encoder which encode the source input and compute the attention over the skills. Then r transformer decoder layers computes r specialized representation and the output response is generated based on the weighted sum the representation. In the figure, we omitted the output layer. Figure 8 : Attention over Parameters (AoP) consist of a transformer encoder which encode the source input and compute the attention over the skills. Then, r specialized transformer decoder layers and a dummy transformer decoder layer parameterized by the weighted sum of the r specialized transformer decoder layers parameters. In the figure, we omitted the output layer."
}